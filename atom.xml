<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DebugTalk</title>
  <subtitle>探索一个软件工程师的无限可能</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://debugtalk.com/"/>
  <updated>2019-01-03T13:34:47.690Z</updated>
  <id>http://debugtalk.com/</id>
  
  <author>
    <name>九毫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HttpRunner 2.0 正式发布</title>
    <link href="http://debugtalk.com/post/httprunner-2.0-release/"/>
    <id>http://debugtalk.com/post/httprunner-2.0-release/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-01-03T13:34:47.690Z</updated>
    
    <content type="html"><![CDATA[<p>在 2017 年 6 月份的时候我写了一篇博客，<a href="https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>，并同时开始了 ApiTestEngine（HttpRunner的前身）的开发工作。转眼间一年半过去了，回顾历程不禁感慨万千。HttpRunner 从最开始的个人业余练手项目，居然一路迭代至今，不仅在大疆内部成为了测试技术体系的基石，在测试业界也有了一定的知名度，形成了一定的开源生态并被众多公司广泛使用，这都是我始料未及的。</p>
<p>但随着 HttpRunner 的发展，我在收获成就感的同时，亦感到巨大的压力。HttpRunner 在被广泛使用的过程中暴露出了不少缺陷，而且有些缺陷是设计理念层面的，这主要都是源于我个人对自动化测试理解的偏差造成的。因此，在近期相当长的一段时间内，我仔细研究了当前主流自动化测试工具，更多的从产品的角度，学习它们的设计理念，并回归测试的本质，对 HttpRunner 的概念重新进行了梳理。</p>
<p>难以避免地，HttpRunner 面临着一些与之前版本兼容的问题。对此我也纠结了许久，到底要不要保持兼容性。如果不兼容，那么对于老用户来说可能会造成一定的升级成本；但如果保持兼容，那么就相当于继续保留之前错误的设计理念，对后续的推广和迭代也会造成沉重的负担。最终，我还是决定告别过去，给 HttpRunner 一个新的开始。</p>
<p>经过两个月的迭代开发，HttpRunner 2.0 版本的核心功能已开发完毕，并且在大疆内部数十个项目中都已投入使用（实践证明，升级也并没有多么痛苦）。趁着 2019 开年之际，HttpRunner 2.0 正式在 <a href="https://pypi.org/project/HttpRunner/" target="_blank" rel="noopener">PyPI</a> 上发布了。从版本号可以看出，这会是一个全新的版本，本文就围绕 HttpRunner 2.0 的功能实现和开源项目管理两方面进行下介绍。</p>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>在 2.0 版本中，功能实现方面变化最大的有两部分，测试用例的组织描述方式，以及 HttpRunner 本身的模块化拆分。当时也是为了完成这两部分的改造，基本上对 HttpRunner 80% 以上的代码进行了重构。除了这两大部分的改造，2.0 版本对于测试报告展现、性能测试支持、参数传参机制等一系列功能特性都进行了较大的优化和提升。</p>
<p>本文就只针对测试用例组织调整和模块化拆分的变化进行下介绍，其它功能特性后续会在使用说明文档中进行详细描述。</p>
<h3 id="测试用例组织调整"><a href="#测试用例组织调整" class="headerlink" title="测试用例组织调整"></a>测试用例组织调整</h3><p>之所以要对测试用例的组织描述方式进行改造，是因为 HttpRunner 在一开始并没有清晰准确的定义。对于 HttpRunner 的老用户应该会有印象，在之前的博客文章中会提到 <code>YAML/JSON</code> 文件中的上下文作用域包含了 <code>测试用例集（testset）</code> 和 <code>测试用例（test）</code> 两个层级；而在测试用例分层机制中，又存在 <code>模块存储目录（suite）</code>、<code>场景文件存储目录（testcases）</code> 这样的概念，实在是令人困惑和费解。</p>
<p>事实上，之前的概念本身就是有问题的，而这些概念又是自动化测试工具（框架）中最核心的内容，必须尽快纠正。这也是推动 HttpRunner 升级到 2.0 版本最根本的原因。</p>
<p>在此我也不再针对之前错误的概念进行过多阐述了，我们不妨回归测试用例的本质，多思考下测试用例的定义及其关键要素。</p>
<p>那么，测试用例（testcase）的准确定义是什么呢？我们不妨看下 <a href="https://en.wikipedia.org/wiki/Test_case" target="_blank" rel="noopener">wiki</a> 上的描述。</p>
<blockquote>
<p>A test case is a specification of the inputs, execution conditions, testing procedure, and expected results that define a single test to be executed to achieve a particular software testing objective, such as to exercise a particular program path or to verify compliance with a specific requirement.</p>
</blockquote>
<p>概括下来，一条测试用例（testcase）应该是为了测试某个特定的功能逻辑而精心设计的，并且至少包含如下几点：</p>
<ul>
<li>明确的测试目的（achieve a particular software testing objective）</li>
<li>明确的输入（inputs）</li>
<li>明确的运行环境（execution conditions）</li>
<li>明确的测试步骤描述（testing procedure）</li>
<li>明确的预期结果（expected results）</li>
</ul>
<p>对应地，我们就可以对 HttpRunner 的测试用例描述方式进行如下设计：</p>
<ul>
<li>测试用例应该是完整且独立的，每条测试用例应该是都可以独立运行的；在 HttpRunner 中，每个 <code>YAML/JSON</code> 文件对应一条测试用例。</li>
<li>测试用例包含<code>测试脚本</code>和<code>测试数据</code>两部分：<ul>
<li>测试用例 = 测试脚本 + 测试数据</li>
<li><code>测试脚本</code>重点是描述测试的<code>业务功能逻辑</code>，包括预置条件、测试步骤、预期结果等，并且可以结合辅助函数（debugtalk.py）实现复杂的运算逻辑；可以将<code>测试脚本</code>理解为编程语言中的<code>类（class）</code>；</li>
<li><code>测试数据</code>重点是对应测试的<code>业务数据逻辑</code>，可以理解为类的实例化数据；<code>测试数据</code>和<code>测试脚本</code>分离后，就可以比较方便地实现数据驱动测试，通过对测试脚本传入一组数据，实现同一业务功能在不同数据逻辑下的测试验证。</li>
</ul>
</li>
<li>测试用例是测试步骤的<code>有序</code>集合，而对于接口测试来说，每一个测试步骤应该就对应一个 API 的请求描述。</li>
<li>测试场景和测试用例集应该是同一概念，它们都是测试用例的<code>无序</code>集合，集合中的测试用例应该都是相互独立，不存在先后依赖关系的；如果确实存在先后依赖关系怎么办，例如登录功能和下单功能；正确的做法应该是，在下单测试用例的预置条件中执行登录操作。</li>
</ul>
<p>理清这些概念后，那么 <code>接口（API）</code>、<code>测试用例（testcase）</code>、<code>辅助函数（debugtalk.py）</code>、<code>YAML/JSON</code>、<code>hooks</code>、<code>validate</code>、<code>环境变量</code>、<code>数据驱动</code>、<code>测试场景</code>、<code>测试用例集</code> 这些概念及其相互之间的关系也就清晰了。关于更具体的内容本文不再展开，后续会单独写文档并结合示例进行详细的讲解。</p>
<h3 id="模块化拆分（Pipline）"><a href="#模块化拆分（Pipline）" class="headerlink" title="模块化拆分（Pipline）"></a>模块化拆分（Pipline）</h3><p>随着 HttpRunner 功能的逐步增长，如何避免代码出现臃肿，如何提升功能特性迭代开发效率，如何提高代码单元测试覆盖率，如何保证框架本身的灵活性，这些都是 HttpRunner 本身的架构设计需要重点考虑的。</p>
<p>具体怎么去做呢？我采用的方式是遵循 Unix 哲学，重点围绕如下两点原则：</p>
<ul>
<li>Write programs that do one thing and do it well.</li>
<li>Write programs to work together.</li>
</ul>
<p>简而言之，就是在 HttpRunner 内部将功能进行模块化拆分，每一个模块只单独负责一个具体的功能，并且对该功能定义好输入和输出，各个功能模块也是可以独立运行的；从总体层面，将这个功能模块组装起来，就形成了 HttpRunner 的核心功能，包括自动化测试和性能测试等。</p>
<p>具体地，HttpRunner 被主要拆分为 6 个模块。</p>
<ul>
<li><code>load_tests</code>: 加载测试项目文件，包括测试脚本（YAML/JSON）、辅助函数（debugtalk.py）、环境变量（.env）、数据文件（csv）等；该阶段主要负责文件加载，不会涉及解析和动态运算的操作。</li>
<li><code>parse_tests</code>: 对加载后的项目文件内容进行解析，包括 变量（variables）、base_url 的优先级替换和运算，辅助函数运算，引用 API 和 testcase 的查找和替换，参数化生成测试用例集等。</li>
<li>add tests to test suite: 将解析后的测试用例添加到 unittest，组装成 <code>unittest.TestSuite</code>。</li>
<li>run test suite: 使用 unittest 运行组装好的 <code>unittest.TestSuite</code>。</li>
<li>aggregate results: 对测试过程的结果数据进行汇总，得到汇总结果数据。</li>
<li>generate html report: 基于 Jinja2 测试报告模板，使用汇总结果数据生成 html 测试报告。</li>
</ul>
<p>为了更好地展现自动化测试的运行过程，提升出现问题时排查的效率，HttpRunner 在运行时还可以通过增加 <code>--save-tests</code> 参数，将各个阶段的数据保存为 JSON 文件。</p>
<ul>
<li>XXX.loaded.json: load_tests 运行后加载生成的数据结构</li>
<li>XXX.parsed.json: parse_tests 运行后解析生成的数据结构</li>
<li>XXX.summary.json: 最终汇总得到的测试结果数据结构</li>
</ul>
<p>可以看出，这 6 个模块组装在一起，就像一条流水线（Pipline）一样，各模块分工协作各司其职，最终完成了整个测试流程。</p>
<p>基于这样的模块化拆分，HttpRunner 极大地避免了代码臃肿的问题，每个模块都专注于解决具体的问题，不仅可测试性得到了保障，遇到问题时排查起来也方便了很多。同时，因为每个模块都可以独立运行，在基于 HttpRunner 做二次开发时也十分方便，减少了很多重复开发工作量。</p>
<h2 id="开源项目管理"><a href="#开源项目管理" class="headerlink" title="开源项目管理"></a>开源项目管理</h2><p>除了功能实现方面的调整，为了 HttpRunner 能有更长远的发展，我也开始思考如何借助社区的力量，吸引更多的人加入进来。特别地，近期在学习 ASF（Apache Software Foundation）如何运作开源项目时，也对 <code>Community Over Code</code> 理念颇为赞同。</p>
<p>当然，HttpRunner 现在仍然是一个很小的项目，不管是产品设计还是代码实现都还很稚嫩。但我也不希望它只是一个个人自嗨的项目，因此从 2.0 版本开始，我希望能尽可能地将项目管理规范化，并寻找更多志同道合的人加入进来共同完善它。</p>
<p>开源项目管理是一个很大的话题，当前我也还处于初学者的状态，因此本文就不再进行展开，只介绍下 HttpRunner 在 2.0 版本中将改进的几个方面。</p>
<h3 id="logo"><a href="#logo" class="headerlink" title="logo"></a>logo</h3><p>作为一个产品，不仅要有个好名字，也要有个好的 logo。这个“好”的评价标准可能因人而异，但它应该是唯一的，能与产品本身定位相吻合的。</p>
<p>之前 HttpRunner 也有个 logo，但说来惭愧，那个 logo 是在网上找的，可能存在侵权的问题是一方面，logo 展示的含义与产品本身也没有太多的关联。</p>
<p>因此，借着 2.0 版本发布之际，我自己用 Keynote 画了一个。</p>
<p><img src="/images/HttpRunner-logo.png" alt="HttpRunner-logo"></p>
<p>个人的美工水平实在有限，让大家见笑了。</p>
<p>对于 logo 设计的解释，主要有如下三点：</p>
<ul>
<li>中间是个拼图（puzzle pieces），形似 H 字母，恰好是 HttpRunner 的首字母</li>
<li>拼图的寓意，对应的也是 HttpRunner 的设计理念；HttpRunner 本身作为一个基础框架，可以组装形成各种类型的测试平台，而在 HttpRunner 内部，也是充分解耦的各个模块组装在一起形成的</li>
<li>最后从实际的展示效果来看，个人感觉看着还是比较舒服的，在 <code>HttpRunner 天使用户群</code> 里给大家看了下，普遍反馈也都不错</li>
</ul>
<h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>作为一个开源的基础框架，版本号是至关重要的。但在之前，HttpRunner 缺乏版本规划，也没有规范的版本号机制，版本号管理的确存在较大的问题。</p>
<p>因此，从 2.0 版本开始，HttpRunner 在版本号机制方面需要规范起来。经过一轮调研，最终确定使用 <a href="https://semver.org/" target="_blank" rel="noopener"><code>Semantic Versioning</code></a> 的机制。该机制由 GitHub 联合创始人 Tom Preston-Werner 编写，当前被广泛采用，遵循该机制也可以更好地与开源生态统一，避免出现 “dependency hell” 的情况。</p>
<p>具体地，HttpRunner 将采用 <code>MAJOR.MINOR.PATCH</code> 的版本号机制。</p>
<ul>
<li>MAJOR: 重大版本升级并出现前后版本不兼容时加 1</li>
<li>MINOR: 大版本内新增功能并且保持版本内兼容性时加 1</li>
<li>PATCH: 功能迭代过程中进行问题修复（bugfix）时加 1</li>
</ul>
<p>当然，在实际迭代开发过程中，肯定也不会每次提交（commit）都对 PATCH 加 1；在遵循如上主体原则的前提下，也会根据需要，在版本号后面添加先行版本号（-alpha/beta/rc）或版本编译元数据（+20190101）作为延伸。</p>
<h3 id="HREPs"><a href="#HREPs" class="headerlink" title="HREPs"></a>HREPs</h3><p>在今年的一些大会上，我分享 HttpRunner 的开发设计思路时提到了<code>博客驱动开发</code>，主要思路就是在开发重要的功能特性之前，不是直接开始写代码，而是先写一篇博客详细介绍该功能的需求背景、目标达成的效果、以及设计思路。通过这种方式，一方面可以帮助自己真正地想清楚要做的事情，同时也可以通过开源社区的反馈来从更全面的角度审视自己的想法，继而纠正可能存在的偏差，或弥补思考的不足。</p>
<p>直到我后来更深入地了解到了 <a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener"><code>PEPs</code></a>(Python Enhancement Proposals)，以及类似的 <a href="https://github.com/ipython/ipython/wiki/IPEPs:-IPython-Enhancement-Proposals" target="_blank" rel="noopener"><code>IPEPs</code></a>(IPython Enhancement Proposals)，我才知道原来我曾经使用过的<code>博客驱动开发</code>并不是一个新方法，而是已经被广泛使用且行之有效的开发方式。</p>
<p>因此，从 2.0 版本开始，在 HttpRunner 的开发方面我想继续沿用这种方式，并且将其固化为一种机制。形式方面，会借鉴 <a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener"><code>PEPs</code></a> 的方式，新增 <a href="https://github.com/HttpRunner/HREP" target="_blank" rel="noopener">HREPs</a>(HttpRunner Enhancement Proposals)；关于 HREPs 的分类和运作机制，后面我再具体进行梳理。</p>
<h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>最后再说下 License 方面。</p>
<p>HttpRunner 最开始选择的是 <a href="https://opensource.org/licenses/MIT" target="_blank" rel="noopener">MIT</a> 开源协议，从 2.0 版本开始，将切换为 <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache-2.0</a> 协议。</p>
<p>如果熟悉这两个 License 的具体含义，应该清楚这两个协议对于用户来说都是十分友好的，不管是个人或商业使用，还是基于 HttpRunner 的二次开发，开源或闭源，都是没有任何限制的，因此协议切换对于大家来说没有任何影响。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，便是 HttpRunner 2.0 发布将带来的主要变化。</p>
<p>截止当前，HttpRunner 在 <a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="noopener">GitHub</a> 上已经收获了近一千个star，在 TesterHome 的<a href="https://testerhome.com/opensource_projects" target="_blank" rel="noopener">开源项目列表</a>中也排到了第二名的位置，在此十分感谢大家的支持和认可。</p>
<p>希望 HttpRunner 2.0 会是一个新的开始，朝着更高的目标迈进。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 2017 年 6 月份的时候我写了一篇博客，&lt;a href=&quot;https://debugtalk.com/post/ApiTestEngine-api-test-best-practice/&quot;&gt;《接口自动化测试的最佳工程实践（ApiTestEngine）》&lt;/a&gt;，并同
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>PyCon China 2018 归来，感谢曾经没有怂的自己</title>
    <link href="http://debugtalk.com/post/pycon-china-2018/"/>
    <id>http://debugtalk.com/post/pycon-china-2018/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-10-15T13:13:08.359Z</updated>
    
    <content type="html"><![CDATA[<p>今天有幸作为 PyCon China 2018 的分享嘉宾，在主会场面向近千名 Python 开发工程师做了一场关于自动化测试框架方面的分享。虽然之前多少有些忐忑和不自信，但终究挺过来了，最终现场效果也还不错，总算松了口气，个人也算是完成了一次自我突破。这会儿在返回深圳的航班上，借着这段空闲时间进行下总结和记录。</p>
<p>本件事情的起源挺有意思的，下面重点说下。</p>
<p>大概在两三个月前，无意中在微信公众号中看到了 PyCon China 2018 的主题征集，在里面看到了测试的字眼。因为近些年来 Python 一直都是我的主要工作语言，也是我个人最喜欢的编程语言，因此我也产生了些许兴趣，加了文章中主办方联系人（辛庆姐）的微信，主要是想询问下大会中会有哪些跟测试相关的主题分享。</p>
<p>在简单聊了下后，得知当前还没有测试相关的主题，对方也向我咨询是否有啥好的建议，同时也欢迎我参加大会进行下测试方面的分享。当时我也表达了我的疑虑，毕竟大会的参会者基本都是 Python 开发者，感觉测试相关的 topic 不一定受欢迎。然后就没继续聊了，这事儿我也就忘了。结果大概过了近一个月后，辛庆姐又跟我联系，还是希望我能做一场测试方面的分享，毕竟 Python 的应用领域这么广泛，当前在测试领域也有较多的应用。我想了下，那就参加下深圳分场的大会吧，多认识些珠三角地区的 Python 大佬也好。当然，我也存在点私心，就是想借这个机会再推广下我的开源项目 HttpRunner，要是能得到些指点就更好了，毕竟参会者基本都是 Python 开发者。</p>
<p>结果令我万万没想到的是，几天后的一个早晨，我睡醒后看到辛庆姐的信息，说是希望我能到北京主会场千人峰会进行分享。我顿时懵逼了，觉得很不可思议。我又再次确认了下，大会总共就一天，主会场总共就 4 个主题，而其它三位嘉宾中一位是洪教授，另外两位是国外嘉宾，他们都是 Python 领域非常资深的前辈，编程年限都快跟我岁数差不多了。我还是觉得难以置信，测试主题居然也可以排进主会场（不是对测试不自信，毕竟是开发者大会）？而且在之前的主题征集中，基本都是围绕 Python 核心语言特性、当前火热的机器学习、大数据方面，测试只是放在其它类别中，所以在被告知安排后的确觉得非常诧异。再三询问才得知，今年大会也是在做改革，想做 Pythoneer 想听的大会，而且组委会中也有成员之前看过我的博客，所以比较支持我（非常感谢）。当然，面对这前所未有的自我挑战的机会，虽然心里没底儿，我也挺想尝试的，就当作一次突破自己的机会好了。不过我也跟组委会说希望他们能再考虑下，因为我还是担心最终不能达成好的效果。再后来，组委会又进行了一轮投票，最终超过一半的成员同意将我的 topic 安排在主会场，这件事就这么定下来了。在此我也非常感谢组委会的认可和信任。</p>
<p>后来的事情就没啥特别的了，无非就是鼓足勇气，尽量克服内心的忐忑和不自信，然后尽量做好准备硬上了。最终结果证明，面对近千名听众进行分享也没那么可怕，和上一次 MTSC2018 服务端专场中面对三四百名听众相比感觉也都差不多，主要的差异还是在上台前的自我暗示。很庆幸，当初我克服了自身的恐惧心理将这件事答应下来了，我才能借助这次机会完成了一次自我突破，后面等我儿子长大了也多了件向他吹牛逼的素材。</p>
<p>说到这里，可能有人希望我能分享下如何克服在大会进行主题分享的恐惧心理。</p>
<p>其实对于这一点，我觉得也没有太多的秘诀，主要还是要多讲。如果还没有过技术分享的经历，不妨从公司的组内分享开始，勇敢地跨出第一步，然后不断地逼迫自己迎接更大的挑战，在部门层面、公司层面、行业沙龙活动等等，机会是非常多的。在这个过程中，积极地收集听众反馈并进行改进，多做几次之后，肯定大不一样。</p>
<p>另外，在分享准备阶段，推荐给大家两个比较有可操作性的做法。</p>
<ul>
<li>首先是分享的主题思路一定要清晰和明确，各部分内容的内在衔接尽量做到自然和不生硬，做到这一点后，听众会更便于掌握主题的思路，分享人也能讲得更流畅，避免因为生硬的内容切换造成忘词儿的尴尬情况。同时，分享的内容一定要都是分享者充分理解的内容，避免在网上抄一些自己都不清楚真实含义的概念和解释。</li>
<li>另一个很重要的点就是要充分重视开场白，如果心里没底儿，建议将开场白逐字写出来并反复进行斟酌，最终修改形成一份让自己满意的开场白，并多次自我演练直至熟练。之所以这么强调开场白，除了是要跟听众尽量留下好的第一印象外，还因为在开场阶段是演讲者最容易紧张的阶段，如果开场讲得不流畅，很容易造成演讲者变得更加紧张，影响后续一连串的表现，甚至会出现大脑一片空白，完全讲不下去的尴尬场面（之前我就有过这样的经历）。而如果开场经过精心准备并且有了一个比较好的表现后，就可以很好地建立自信，并且在这个过程中也熟悉了面向听众的感觉，后续的演讲也就不会有什么问题了。</li>
</ul>
<p>当然，这里只是列举了我个人觉得比较重要的两个点，对于其他人不一定适用。提升演讲和分享能力是一个持久的过程，我当前也是在不断摸索和提升的过程中。希望大家也能在留言中分享下这方面的经验，大家互相学习，共同进步。</p>
<p>最后，再说件比较尴尬的事情。</p>
<p>在会后，有几家出版社（也包括 GitChat 这类在线知识付费平台）的编辑跟我联系，询问我是否有意向进行合作和出版。我当然是非常难为情啦，去年年初跟博文视点签的出版合同，本来还打算在小坚果出生前出版呢，现在儿子都快满一岁了，至今还没交稿呢（确切地说，是搁置好久了）。唉，时间是一方面，主要还是执行力不够啊。所以现在对于出书的作者我是格外佩服的，内容好坏暂且不说，能坚持下来就真的很不容易了。如今我也有幸认识了不少畅销书的作者了，向他们看齐，加油吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天有幸作为 PyCon China 2018 的分享嘉宾，在主会场面向近千名 Python 开发工程师做了一场关于自动化测试框架方面的分享。虽然之前多少有些忐忑和不自信，但终究挺过来了，最终现场效果也还不错，总算松了口气，个人也算是完成了一次自我突破。这会儿在返回深圳的航
    
    </summary>
    
    
      <category term="个人成长" scheme="http://debugtalk.com/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>【大疆招聘】招聘核心项目测试负责人，诚意十足（附文末福利）</title>
    <link href="http://debugtalk.com/post/dji-hire-test-leader/"/>
    <id>http://debugtalk.com/post/dji-hire-test-leader/</id>
    <published>2018-06-30T16:00:00.000Z</published>
    <updated>2018-07-01T04:38:28.159Z</updated>
    
    <content type="html"><![CDATA[<p>近期，大疆互联网事业部急招项目测试负责人，岗位很核心，诚意也很足。</p>
<h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>关于大疆这家公司的介绍，直接引用下大疆互联网 Ruby 团队的<a href="https://ruby-china.org/topics/36849" target="_blank" rel="noopener">招聘文案</a>。</p>
<blockquote>
<p>DJI 大疆创新是全球领先的无人机公司，以“The Future of Possible（未来无所不能）”为理念，不断在各领域开拓创新，目前在全球有11000名员工，2017 年销售额破 180 亿元，估值超 150 亿美元。DJI 近几年每年都实现接近翻倍的增长，业务领域也不断拓展，产品目前已经广泛应用在农业、测绘、消防、公共安全、动物保护、地产、能源等多个领域。 DJI 目前在控制、算法、通信、IOT等方向技术积累深厚，在国内可以说难有匹敌。未来大疆将不仅是一家无人机硬件公司，很可能会逐步转变为智能机器人的解决方案公司，通过可以影响三维空间的技术，深刻的改变人类的生活。很多人说大疆在这样一种转型中，互联网、物联网方向的人才可以说是不可或缺。如果你想要跳上一艘正在高速运行的火箭飞船，尝试机遇与挑战并存的职业机会，大疆应该是个很不错的选择。</p>
</blockquote>
<p><img src="/images/mavic-air.jpg" alt="mavic-air"></p>
<blockquote>
<p>图为大疆新品 Mavic Air，在收起四轴折叠起来的时候，长宽只比一台普通的手机稍大一点。</p>
</blockquote>
<p>而互联网质量部，则是大疆创新互联网事业部的质量保障团队，为智能制造的生产运营体系，电商、ERP、智能工厂、全球供应链、企业信息系统、RoboMaster、农机app等DJI产品提供全生命周期保驾护航。</p>
<p>之前我也写过多篇文章详细介绍了质量部的工作内容，有兴趣的话可以看下历史文章。</p>
<ul>
<li><a href="http://debugtalk.com/post/d-test-hire-info/">《【大疆内推】岗位描述我只想这么写》</a></li>
<li><a href="http://debugtalk.com/post/introduction-to-testing-engineer-daily-work/">《【科普】互联网测试岗位的工作日常》</a></li>
<li><a href="http://debugtalk.com/post/test-dev-in-dji/">《在大疆做测试开发是一种什么体验？》</a></li>
</ul>
<p>接下来我就重点介绍下当前急招的岗位吧。</p>
<h2 id="岗位职责及要求"><a href="#岗位职责及要求" class="headerlink" title="岗位职责及要求"></a>岗位职责及要求</h2><p>大疆作为一家全球化的智能硬件生产制造企业，生产运营体系、ERP、智能工厂、全球供应链等都是非常重要的环节，相关系统的质量保证工作自然也是极其重要。近期重点招聘的岗位，主要也是围绕这些业务方向，期望新加入的成员能成为<strong>项目测试负责人</strong>或<strong>核心测试骨干</strong>的角色。</p>
<p>对于岗位的工作职责和任职资格，已经在拉勾网的 <a href="https://www.lagou.com/jobs/4688215.html" target="_blank" rel="noopener">JD</a> 中进行了描述，在此我只强调如下几点：</p>
<ul>
<li>具有丰富的项目测试经验，具备独立负责项目整体测试工作的能力；</li>
<li>具备较强的自驱力和项目推动能力；</li>
<li>最好在<code>MES/CRM/LMS/APS/ERP</code>等业务领域具有较为丰富的经验积累；</li>
<li>本科及以上学历。</li>
</ul>
<p>对于其它条件，都可以视面试情况而定。</p>
<h2 id="薪资福利"><a href="#薪资福利" class="headerlink" title="薪资福利"></a>薪资福利</h2><p>大厂都有的零食区、健身房、幼儿园、免费人才房、定期团建、节假日礼品这些硬性和软性福利，大疆这边都有，我也就不再重复了。重点就说下大家普遍关注的薪资待遇问题。</p>
<p>在月薪方面，本次招聘的岗位分为高级和中级，高级的范围在<code>20K～35K</code>，中级的范围在<code>15K~25K</code>。</p>
<p>年终奖视个人绩效而定，普遍在 3～6 个月，优秀的更多，甚至可以领到奔驰宝马福利车，而且还不用担心车牌的问题。</p>
<p>工作满两年并且绩效还不错的，可以申请到公司的无息购房贷款，额度在<strong>100万～200万</strong>之间，这也是可以秒杀其它大厂的。</p>
<p>对于优秀的员工，公司也很是舍得发股票。现在大疆还没有上市，其内部股的未来价值也是非常值得期待的。</p>
<p>当然，除了单纯的薪资福利，相信公司业务迅猛发展带来的个人能力成长空间，也是你所期待的。在大疆，公司的口号是探索未来无限可能（The future of possible），这对员工个人来说也同样适用。</p>
<h2 id="其它岗位"><a href="#其它岗位" class="headerlink" title="其它岗位"></a>其它岗位</h2><p>除了上面提到的岗位，大疆其它各岗位也具有大量的招聘需求，尤其是前后端开发、iOS/Android、运维等方向，工作地点覆盖深圳、北京、上海等地，详情以官方招聘网站为准。这些岗位我也都可以帮忙内推到对应的负责人。</p>
<p>至于测试开发岗位，招聘长期有效，欢迎直接联系我，进行推荐或自荐。</p>
<h2 id="投递方式"><a href="#投递方式" class="headerlink" title="投递方式"></a>投递方式</h2><p>请将简历直接发到我的工作邮箱：<code>leo.lee#dji.com</code></p>
<p>如果对岗位还有所疑问，也欢迎与我联系，只要是在不违反公司信息安全和保密规定的前提下，我都可以为你答疑解惑。</p>
<h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>在即将到来的中国移动互联网测试开发大会（简称MTSC2018）中，我将代表公司分享一个题目，《大疆互联网的一站式自动化测试解决方案（基于HttpRunner）》，期待届时能跟各位同行进行更多的交流。</p>
<p>在大会开始（7.13）前，若成功完成推荐或自荐的（通过一面就算），则送出价值1600元的 <a href="https://www.bagevent.com/event/1193113" target="_blank" rel="noopener"><strong>MTSC2018</strong></a> 门票一张！数量有限，先到先得。</p>
<p>期待你的加入！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，大疆互联网事业部急招项目测试负责人，岗位很核心，诚意也很足。&lt;/p&gt;
&lt;h2 id=&quot;关于我们&quot;&gt;&lt;a href=&quot;#关于我们&quot; class=&quot;headerlink&quot; title=&quot;关于我们&quot;&gt;&lt;/a&gt;关于我们&lt;/h2&gt;&lt;p&gt;关于大疆这家公司的介绍，直接引用下大疆互联
    
    </summary>
    
    
      <category term="招聘" scheme="http://debugtalk.com/tags/%E6%8B%9B%E8%81%98/"/>
    
  </entry>
  
  <entry>
    <title>使用爬虫技术实现 Web 页面资源可用性检测</title>
    <link href="http://debugtalk.com/post/requests-crawler/"/>
    <id>http://debugtalk.com/post/requests-crawler/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2018-05-27T17:02:21.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于电商类型和内容服务类型的网站，经常会出现因为配置错误造成页面链接无法访问的情况（404）。</p>
<p>显然，要确保网站中的所有链接都具有可访问性，通过人工进行检测肯定是不现实的，常用的做法是使用爬虫技术定期对网站进行资源爬取，及时发现访问异常的链接。</p>
<p>对于网络爬虫，当前市面上已经存在大量的开源项目和技术讨论的文章。不过，感觉大家普遍都将焦点集中在爬取效率方面，例如当前就存在大量讨论不同并发机制哪个效率更高的文章，而在爬虫的其它特性方面探讨的不多。</p>
<p>个人认为，爬虫的核心特性除了<code>快</code>，还应该包括<code>全</code>和<code>稳</code>，并且从重要性的排序来看，<code>全</code>、<code>稳</code>、<code>快</code>应该是从高到低的。</p>
<p><code>全</code>排在第一位，是因为这是爬虫的基本功能，若爬取的页面不全，就会出现信息遗漏的情况，这种情况肯定是不允许的；而<code>稳</code>排在第二位，是因为爬虫通常都是需要长期稳定运行的，若因为策略处理不当造成爬虫运行过程中偶尔无法正常访问页面，肯定也是无法接受的；最后才是<code>快</code>，我们通常需要爬取的页面链接会非常多，因此效率就很关键，但这也必须建立在<code>全</code>和<code>稳</code>的基础上。</p>
<p>当然，爬虫本身是一个很深的技术领域，我接触的也只是皮毛。本文只针对使用爬虫技术实现 Web 页面资源可用性检测的实际场景，详细剖析下其中涉及到的几个技术点，重点解决如下几个问题：</p>
<ul>
<li>全：如何才能爬取网站所有的页面链接？特别是当前许多网站的页面内容都是要靠前端渲染生成的，爬虫要如何支持这种情况？</li>
<li>稳：很多网站都有访问频率限制，若爬虫策略处理不当，就常出现 403 和 503 的问题，该种问题要怎么解决？</li>
<li>快：如何在保障爬虫功能正常的前提下，尽可能地提升爬虫效率？</li>
</ul>
<h2 id="爬虫实现前端页面渲染"><a href="#爬虫实现前端页面渲染" class="headerlink" title="爬虫实现前端页面渲染"></a>爬虫实现前端页面渲染</h2><p>在早些年，基本上绝大多数网站都是通过后端渲染的，即在服务器端组装形成完整的 HTML 页面，然后再将完整页面返回给前端进行展现。而近年来，随着 AJAX 技术的不断普及，以及 AngularJS 这类 SPA 框架的广泛应用，前端渲染的页面越来越多。</p>
<p>不知大家有没有听说过，前端渲染相比于后端渲染，是不利于进行 SEO 的，因为对爬虫不友好。究其原因，就是因为前端渲染的页面是需要在浏览器端执行 JavaScript 代码（即 AJAX 请求）才能获取后端数据，然后才能拼装成完整的 HTML 页面。</p>
<p>针对这类情况，当前也已经有很多解决方案，最常用的就是借助 PhantomJS、<a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a> 这类 Headless 浏览器工具，相当于在爬虫中内置一个浏览器内核，对抓取的页面先渲染（执行 Javascript 脚本），然后再对页面内容进行抓取。</p>
<p>不过，要使用这类技术，通常都是需要使用 Javascript 来开发爬虫工具，对于我这种写惯了 Python 的人来说的确有些痛苦。</p>
<p>直到某一天，<a href="https://github.com/kennethreitz" target="_blank" rel="noopener">kennethreitz</a> 大神发布了开源项目 <a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">requests-html</a>，看到项目介绍中的那句 <code>Full JavaScript support!</code> 时不禁热泪盈眶，就是它了！该项目在 GitHub 上发布后不到三天，star 数就达到 5000 以上，足见其影响力。</p>
<p><a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">requests-html</a> 为啥会这么火？</p>
<p>写过 Python 的人，基本上都会使用 <a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a> 这么一个 HTTP 库，说它是最好的 HTTP 库一点也不夸张（不限编程语言），对于其介绍语 <code>HTTP Requests for Humans</code> 也当之无愧。也是因为这个原因，<a href="https://github.com/locustio/locust" target="_blank" rel="noopener">Locust</a> 和 <a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="noopener">HttpRunner</a> 都是基于 <a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a> 来进行开发的。</p>
<p>而 <a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">requests-html</a>，则是 <a href="https://github.com/kennethreitz" target="_blank" rel="noopener">kennethreitz</a> 在 <a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a> 的基础上开发的另一个开源项目，除了可以复用 <a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a> 的全部功能外，还实现了对 HTML 页面的解析，即支持对 Javascript 的执行，以及通过 CSS 和 XPath 对 HTML 页面元素进行提取的功能，这些都是编写爬虫工具非常需要的功能。</p>
<p>在实现 Javascript 执行方面，<a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">requests-html</a> 也并没有自己造轮子，而是借助了 <a href="https://github.com/miyakogi/pyppeteer" target="_blank" rel="noopener">pyppeteer</a> 这个开源项目。还记得前面提到的 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a> 项目么，这是 GoogleChrome 官方实现的 <code>Node API</code>；而 <a href="https://github.com/miyakogi/pyppeteer" target="_blank" rel="noopener">pyppeteer</a> 这个项目，则相当于是使用 Python 语言对 puppeteer 的非官方实现，基本具有 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">puppeteer</a> 的所有功能。</p>
<p>理清了以上关系后，相信大家对 <a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">requests-html</a> 也就有了更好的理解。</p>
<p>在使用方面，<a href="https://github.com/kennethreitz/requests-html" target="_blank" rel="noopener">requests-html</a> 也十分简单，用法与 <a href="https://github.com/requests/requests" target="_blank" rel="noopener">requests</a> 基本相同，只是多了 <code>render</code> 功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> requests_html <span class="keyword">import</span> HTMLSession</div><div class="line"></div><div class="line">session = HTMLSession()</div><div class="line">r = session.get(<span class="string">'http://python-requests.org'</span>)</div><div class="line">r.html.render()</div></pre></td></tr></table></figure>
<p>在执行 <code>render()</code> 之后，返回的就是经过渲染后的页面内容。</p>
<h2 id="爬虫实现访问频率控制"><a href="#爬虫实现访问频率控制" class="headerlink" title="爬虫实现访问频率控制"></a>爬虫实现访问频率控制</h2><p>为了防止流量攻击，很多网站都有访问频率限制，即限制单个 IP 在一定时间段内的访问次数。若超过这个设定的限制，服务器端就会拒绝访问请求，即响应状态码为 403（Forbidden）。</p>
<p>这用来应对外部的流量攻击或者爬虫是可以的，但在这个限定策略下，公司内部的爬虫测试工具同样也无法正常使用了。针对这个问题，常用的做法就是在应用系统中开设白名单，将公司内部的爬虫测试服务器 IP 加到白名单中，然后针对白名单中的 IP 不做限制，或者提升限额。但这同样可能会出现问题。因为应用服务器的性能不是无限的，假如爬虫的访问频率超过了应用服务器的处理极限，那么就会造成应用服务器不可用的情况，即响应状态码为 503（Service Unavailable Error）。</p>
<p>基于以上原因，爬虫的访问频率应该是要与项目组的开发和运维进行统一评估后确定的；而对于爬虫工具而言，实现对访问频率的控制也就很有必要了。</p>
<p>那要怎样实现访问频率的控制呢？</p>
<p>我们可以先回到爬虫本身的实现机制。对于爬虫来说，不管采用什么实现形式，应该都可以概括为生产者和消费者模型，即：</p>
<ul>
<li>消费者：爬取新的页面</li>
<li>生产者：对爬取的页面进行解析，得到需要爬取的页面链接</li>
</ul>
<p>对于这种模型，最简单的做法是使用一个 FIFO 的队列，用于存储未爬取的链接队列（unvisited_urls_queue）。不管是采用何种并发机制，这个队列都可以在各个 worker 中共享。对于每一个 worker 来说，都可以按照如下做法：</p>
<ul>
<li>从 unvisited_urls_queue 队首中取出一个链接进行访问；</li>
<li>解析出页面中的链接，遍历所有的链接，找出未访问过的链接；</li>
<li>将未访问过的链接加入到 unvisited_urls_queue 队尾</li>
<li>直到 unvisited_urls_queue 为空时终止任务</li>
</ul>
<p>然后回到我们的问题，要限制访问频率，即单位时间内请求的链接数目。显然，worker 之间相互独立，要在执行端层面协同实现整体的频率控制并不容易。但从上面的步骤中可以看出，unvisited_urls_queue 被所有 worker 共享，并且作为源头供给的角色。那么只要我们可以实现对 unvisited_urls_queue 补充的数量控制，就实现了爬虫整体的访问频率控制。</p>
<p>以上思路是正确的，但在具体实现的时候会存在几个问题：</p>
<ul>
<li>需要一个用于存储已经访问链接的集合（visited_urls_set），该集合需要在各个 worker 中实现共享；</li>
<li>需要一个全局的计数器，统计到达设定时间间隔（rps即1秒，rpm即1分钟）时已访问的总链接数；</li>
</ul>
<p>并且在当前的实际场景中，最佳的并发机制是选择多进程（下文会详细说明原因），每个 worker 在不同的进程中，那要实现对集合的共享就不大容易了。同时，如果每个 worker 都要负责对总请求数进行判断，即将访问频率的控制逻辑放到 worker 中实现，那对于 worker 来说会是一个负担，逻辑上也会比较复杂。</p>
<p>因此比较好的方式是，除了未访问链接队列（unvisited_urls_queue），另外再新增一个爬取结果的存储队列（fetched_urls_queue），这两个队列都在各个 worker 中共享。那么，接下来逻辑就变得简单了：</p>
<ul>
<li>在各个 worker 中，只需要从 unvisited_urls_queue 中取数据，解析出结果后统统存储到 fetched_urls_queue，无需关注访问频率的问题；</li>
<li>在主进程中，不断地从 fetched_urls_queue 取数据，将未访问过的链接添加到 unvisited_urls_queue，在添加之前进行访问频率控制。</li>
</ul>
<p>具体的控制方法也很简单，假设我们是要实现 RPS 的控制，那么就可以使用如下方式（只截取关键片段）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">start_timer = time.time()</div><div class="line">requests_queued = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        url = self.fetched_urls_queue.get(timeout=<span class="number">5</span>)</div><div class="line">    <span class="keyword">except</span> queue.Empty:</div><div class="line">        <span class="keyword">break</span></div><div class="line"></div><div class="line">    <span class="comment"># visited url will not be crawled twice</span></div><div class="line">    <span class="keyword">if</span> url <span class="keyword">in</span> self.visited_urls_set:</div><div class="line">        <span class="keyword">continue</span></div><div class="line"></div><div class="line">    <span class="comment"># limit rps or rpm</span></div><div class="line">    <span class="keyword">if</span> requests_queued &gt;= self.requests_limit:</div><div class="line">        runtime_secs = time.time() - start_timer</div><div class="line">        <span class="keyword">if</span> runtime_secs &lt; self.interval_limit:</div><div class="line">            sleep_secs = self.interval_limit - runtime_secs</div><div class="line">            <span class="comment"># exceed rps limit, sleep</span></div><div class="line">            time.sleep(sleep_secs)</div><div class="line"></div><div class="line">        start_timer = time.time()</div><div class="line">        requests_queued = <span class="number">0</span></div><div class="line"></div><div class="line">    self.unvisited_urls_queue.put(url)</div><div class="line">    self.visited_urls_set.add(url)</div><div class="line">    requests_queued += <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="提升爬虫效率"><a href="#提升爬虫效率" class="headerlink" title="提升爬虫效率"></a>提升爬虫效率</h2><p>对于提升爬虫效率这部分，当前已经有大量的讨论了，重点都是集中在不同的并发机制上面，包括多进程、多线程、asyncio等。</p>
<p>不过，他们的并发测试结果对于本文中讨论的爬虫场景并不适用。因为在本文的爬虫场景中，实现前端页面渲染是最核心的一项功能特性，而要实现前端页面渲染，底层都是需要使用浏览器内核的，相当于每个 worker 在运行时都会跑一个 Chromium 实例。</p>
<p>众所周知，Chromium 对于 CPU 和内存的开销都是比较大的，因此为了避免机器资源出现瓶颈，使用多进程机制（multiprocessing）充分调用多处理器的硬件资源无疑是最佳的选择。</p>
<p>另一个需要注意也是比较被大家忽略的点，就是在页面链接的请求方法上。</p>
<p>请求页面链接，不都是使用 GET 方法么？</p>
<p>的确，使用 GET 请求肯定是可行的，但问题在于，GET 请求时会加载页面中的所有资源信息，这本身会是比较耗时的，特别是遇到链接为比较大的图片或者附件的时候。这无疑会耗费很多无谓的时间，毕竟我们的目的只是为了检测链接资源是否可访问而已。</p>
<p>比较好的的做法是对网站的链接进行分类：</p>
<ul>
<li>资源型链接，包括图片、CSS、JS、文件、视频、附件等，这类链接只需检测可访问性；</li>
<li>外站链接，这类链接只需检测该链接本身的可访问性，无需进一步检测该链接加载后页面中包含的链接；</li>
<li>本站页面链接，这类链接除了需要检测该链接本身的可访问性，还需要进一步检测该链接加载后页面中包含的链接的可访问性；</li>
</ul>
<p>在如上分类中，除了第三类是必须要使用 GET 方法获取页面并加载完整内容（render），前两类完全可以使用 HEAD 方法进行代替。一方面，HEAD 方法只会获取状态码和 headers 而不获取 body，比 GET 方法高效很多；另一方面，前两类链接也无需进行页面渲染，省去了调用 Chromium 进行解析的步骤，执行效率的提高也会非常明显。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文针对如何使用爬虫技术实现 Web 页面资源可用性检测进行了讲解，重点围绕爬虫如何实现 <code>全</code>、<code>稳</code>、<code>快</code> 三个核心特性进行了展开。对于爬虫技术的更多内容，后续有机会我们再进一步进行探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;对于电商类型和内容服务类型的网站，经常会出现因为配置错误造成页面链接无法访问的情况（404）。&lt;/p&gt;
&lt;p&gt;显然，要确保网站中的所有链接都
    
    </summary>
    
    
      <category term="requests-crawler" scheme="http://debugtalk.com/tags/requests-crawler/"/>
    
      <category term="requests-html" scheme="http://debugtalk.com/tags/requests-html/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 实现 hook 机制</title>
    <link href="http://debugtalk.com/post/httprunner-hook/"/>
    <id>http://debugtalk.com/post/httprunner-hook/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-05-12T09:47:40.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在自动化测试中，通常在测试开始前需要做一些预处理操作，以及在测试结束后做一些清理性的工作。</p>
<p>例如，测试使用手机号注册账号的接口：</p>
<ul>
<li>测试开始前需要确保该手机号未进行过注册，常用的做法是先在数据库中删除该手机号相关的账号数据（若存在）；</li>
<li>测试结束后，为了减少对测试环境的影响，常用的做法是在数据库中将本次测试产生的相关数据删除掉。</li>
</ul>
<p>显然，在自动化测试中的这类预处理操作和清理性工作，由人工来做肯定是不合适的，我们最好的方式还是在测试脚本中进行实现，也就是我们常说的 hook 机制。</p>
<p>hook 机制的概念很简单，在各个主流的测试工具和测试框架中也很常见。</p>
<p>例如 Python 的 unittest 框架，常用的就有如下几种 hook 函数。</p>
<ul>
<li>setUp：在每个 test 运行前执行</li>
<li>tearDown：在每个 test 运行后执行</li>
<li>setUpClass：在整个用例集运行前执行</li>
<li>tearDownClass：在整个用例集运行后执行</li>
</ul>
<p>概括地讲，就是针对自动化测试用例，要在单个测试用例和整个测试用例集的前后实现 hook 函数。</p>
<h2 id="描述方式设想"><a href="#描述方式设想" class="headerlink" title="描述方式设想"></a>描述方式设想</h2><p>在 HttpRunner 的 YAML/JSON 测试用例文件中，本身就具有分层的思想，用例集层面的配置在 config 中，用例层面的配置在 test 中；同时，在 YAML/JSON 中也实现了比较方便的函数调用机制，<code>$func($a, $b)</code>。</p>
<p>因此，我们可以新增两个关键字：<code>setup_hooks</code> 和 <code>teardown_hooks</code>。类似于 variables 和 parameters 关键字，根据关键字放置的位置来决定是用例集层面还是单个用例层面。</p>
<p>根据设想，我们就可以采用如下形式来描述 hook 机制。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> basic test with httpbin</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3458</span>/</div><div class="line"><span class="attr">    setup_hooks:</span></div><div class="line"><span class="bullet">        -</span> $&#123;hook_print(setup_testset)&#125;</div><div class="line"><span class="attr">    teardown_hooks:</span></div><div class="line"><span class="bullet">        -</span> $&#123;hook_print(teardown_testset)&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get headers</div><div class="line"><span class="attr">    times:</span> <span class="number">2</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /headers</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    setup_hooks:</span></div><div class="line"><span class="bullet">        -</span> $&#123;hook_print(---setup-testcase)&#125;</div><div class="line"><span class="attr">    teardown_hooks:</span></div><div class="line"><span class="bullet">        -</span> $&#123;hook_print(---teardown-testcase)&#125;</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [content.headers.Host, <span class="string">"127.0.0.1:3458"</span>]</div></pre></td></tr></table></figure>
<p>同时，hook 函数需要定义在项目的 debugtalk.py 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_print</span><span class="params">(msg)</span>:</span></div><div class="line">    print(msg)</div></pre></td></tr></table></figure>
<h2 id="基本实现方式"><a href="#基本实现方式" class="headerlink" title="基本实现方式"></a>基本实现方式</h2><p>基于 hook 机制的简单概念，要在 HttpRunner 中实现类似功能也就很容易了。</p>
<p>在 HttpRunner 中，负责测试执行的类为 <code>httprunner/runner.py</code> 中的 Runner。因此，要实现用例集层面的 hook 机制，只需要将用例集的 setup_hooks 放置到 <code>__init__</code> 中，将 teardown_hooks 放置到 <code>__del__</code> 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config_dict=None, http_client_session=None)</span>:</span></div><div class="line">        <span class="comment"># 省略</span></div><div class="line"></div><div class="line">        <span class="comment"># testset setup hooks</span></div><div class="line">        testset_setup_hooks = config_dict.pop(<span class="string">"setup_hooks"</span>, [])</div><div class="line">        <span class="keyword">if</span> testset_setup_hooks:</div><div class="line">            self.do_hook_actions(testset_setup_hooks)</div><div class="line"></div><div class="line">        <span class="comment"># testset teardown hooks</span></div><div class="line">        self.testset_teardown_hooks = config_dict.pop(<span class="string">"teardown_hooks"</span>, [])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.testset_teardown_hooks:</div><div class="line">            self.do_hook_actions(self.testset_teardown_hooks)</div></pre></td></tr></table></figure>
<p>类似地，要实现单个用例层面的 hook 机制，只需要将单个用例的 setup_hooks 放置到 request 之前，将 teardown_hooks 放置到 request 之后。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_test</span><span class="params">(self, testcase_dict)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 省略</span></div><div class="line"></div><div class="line">        <span class="comment"># setup hooks</span></div><div class="line">        setup_hooks = testcase_dict.get(<span class="string">"setup_hooks"</span>, [])</div><div class="line">        self.do_hook_actions(setup_hooks)</div><div class="line"></div><div class="line">        <span class="comment"># request</span></div><div class="line">        resp = self.http_client_session.request(method, url, name=group_name, **parsed_request)</div><div class="line"></div><div class="line">        <span class="comment"># teardown hooks</span></div><div class="line">        teardown_hooks = testcase_dict.get(<span class="string">"teardown_hooks"</span>, [])</div><div class="line">        <span class="keyword">if</span> teardown_hooks:</div><div class="line">            self.do_hook_actions(teardown_hooks)</div><div class="line"></div><div class="line">        <span class="comment"># 省略</span></div></pre></td></tr></table></figure>
<p>至于具体执行 hook 函数的 do_hook_actions，因为之前我们已经实现了文本格式函数描述的解析器 <code>context.eval_content</code>，因此直接调用就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_hook_actions</span><span class="params">(self, actions)</span>:</span></div><div class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> actions:</div><div class="line">        logger.log_debug(<span class="string">"call hook: &#123;&#125;"</span>.format(action))</div><div class="line">        self.context.eval_content(action)</div></pre></td></tr></table></figure>
<p>通过以上方式，我们就在 HttpRunner 中实现了用例集和单个用例层面的 hook 机制。</p>
<p>还是上面的测试用例，我们执行的效果如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ hrun tests/httpbin/hooks.yml</div><div class="line">setup_testset</div><div class="line">get headers</div><div class="line">INFO     GET /headers</div><div class="line">---setup-testcase</div><div class="line">INFO     status_code: 200, response_time(ms): 10.29 ms, response_length: 151 bytes</div><div class="line">---teardown-testcase</div><div class="line">.</div><div class="line">get headers</div><div class="line">INFO     GET /headers</div><div class="line">---setup-testcase</div><div class="line">INFO     status_code: 200, response_time(ms): 4.46 ms, response_length: 151 bytes</div><div class="line">---teardown-testcase</div><div class="line">.</div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 2 tests in 0.028s</div><div class="line"></div><div class="line">OK</div><div class="line">teardown_testset</div></pre></td></tr></table></figure>
<p>可以看出，这的确已经满足了我们在用例集和单个用例层面的 hook 需求。</p>
<h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>以上实现已经可以满足大多数场景的测试需求了，不过还有两种场景无法满足：</p>
<ul>
<li>需要对请求的 request 内容进行预处理，例如，根据请求方法和请求的 Content-Type 来对请求的 data 进行加工处理；</li>
<li>需要根据响应结果来进行不同的后续处理，例如，根据接口响应的状态码来进行不同时间的延迟等待。</li>
</ul>
<p>在之前的实现方式中，我们无法实现上述两个场景，是因为我们无法将请求的 request 内容和响应的结果传给 hook 函数。</p>
<p>问题明确了，要进行进一步优化也就容易了。</p>
<p>因为我们在 hook 函数（类似于<code>$func($a, $b)</code>）中，是可以传入变量的，而变量都是存在于当前测试用例的上下文（context）中的，那么我们只要将 request 内容和请求响应分别作为变量绑定到当前测试用例的上下文即可。</p>
<p>具体地，我们可以约定两个变量，<code>$request</code>和<code>$response</code>，分别对应测试用例的请求内容（request）和响应实例（requests.Response）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_test</span><span class="params">(self, testcase_dict)</span>:</span></div><div class="line"></div><div class="line">        self.context.bind_variables(&#123;<span class="string">"request"</span>: parsed_request&#125;, level=<span class="string">"testcase"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 省略</span></div><div class="line"></div><div class="line">        <span class="comment"># setup hooks</span></div><div class="line">        setup_hooks = testcase_dict.get(<span class="string">"setup_hooks"</span>, [])</div><div class="line">        self.do_hook_actions(setup_hooks)</div><div class="line"></div><div class="line">        <span class="comment"># request</span></div><div class="line">        resp = self.http_client_session.request(method, url, name=group_name, **parsed_request)</div><div class="line"></div><div class="line">        <span class="comment"># teardown hooks</span></div><div class="line">        teardown_hooks = testcase_dict.get(<span class="string">"teardown_hooks"</span>, [])</div><div class="line">        <span class="keyword">if</span> teardown_hooks:</div><div class="line">            self.context.bind_variables(&#123;<span class="string">"response"</span>: resp&#125;, level=<span class="string">"testcase"</span>)</div><div class="line">            self.do_hook_actions(teardown_hooks)</div><div class="line"></div><div class="line">        <span class="comment"># 省略</span></div></pre></td></tr></table></figure>
<p>在优化后的实现中，新增了两次调用，<code>self.context.bind_variables</code>，作用就是将解析后的 request 内容和请求的响应实例绑定到当前测试用例的上下文中。</p>
<p>然后，我们在 YAML/JSON 测试用例中就可以在需要的时候调用<code>$request</code>和<code>$response</code>了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> headers</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /headers</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    setup_hooks:</span></div><div class="line"><span class="bullet">        -</span> $&#123;setup_hook_prepare_kwargs($request)&#125;</div><div class="line"><span class="attr">    teardown_hooks:</span></div><div class="line"><span class="bullet">        -</span> $&#123;teardown_hook_sleep_N_secs($response, <span class="number">1</span>)&#125;</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [content.headers.Host, <span class="string">"127.0.0.1:3458"</span>]</div></pre></td></tr></table></figure>
<p>对应的 hook 函数如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_hook_prepare_kwargs</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">if</span> request[<span class="string">"method"</span>] == <span class="string">"POST"</span>:</div><div class="line">        content_type = request.get(<span class="string">"headers"</span>, &#123;&#125;).get(<span class="string">"content-type"</span>)</div><div class="line">        <span class="keyword">if</span> content_type <span class="keyword">and</span> <span class="string">"data"</span> <span class="keyword">in</span> request:</div><div class="line">            <span class="comment"># if request content-type is application/json, request data should be dumped</span></div><div class="line">            <span class="keyword">if</span> content_type.startswith(<span class="string">"application/json"</span>) <span class="keyword">and</span> isinstance(request[<span class="string">"data"</span>], (dict, list)):</div><div class="line">                request[<span class="string">"data"</span>] = json.dumps(request[<span class="string">"data"</span>])</div><div class="line"></div><div class="line">            <span class="keyword">if</span> isinstance(request[<span class="string">"data"</span>], str):</div><div class="line">                request[<span class="string">"data"</span>] = request[<span class="string">"data"</span>].encode(<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_hook_sleep_N_secs</span><span class="params">(response, n_secs)</span>:</span></div><div class="line">    <span class="string">""" sleep n seconds after request</span></div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        time.sleep(n_secs)</div></pre></td></tr></table></figure>
<p>值得特别说明的是，因为 request 是可变参数类型（dict），因此该函数参数为引用传递，我们在 hook 函数里面对 request 进行修改后，后续在实际请求时也同样会发生改变，这对于我们需要对请求参数进行预处理时尤其有用。</p>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul>
<li>中文使用说明文档：<a href="http://cn.httprunner.org/advanced/request-hook/" target="_blank" rel="noopener">http://cn.httprunner.org/advanced/request-hook/</a></li>
<li>代码实现：<a href="https://github.com/HttpRunner/HttpRunner/commit/2bb84b38745d004d336ed9867df5e63534b596bc" target="_blank" rel="noopener">GitHub commit</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在自动化测试中，通常在测试开始前需要做一些预处理操作，以及在测试结束后做一些清理性的工作。&lt;/p&gt;
&lt;p&gt;例如，测试使用手机号注册账号的接口
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="hook" scheme="http://debugtalk.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 再议参数化数据驱动机制</title>
    <link href="http://debugtalk.com/post/httprunner-data-driven-refactor/"/>
    <id>http://debugtalk.com/post/httprunner-data-driven-refactor/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-03-25T08:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/httprunner-data-driven/">《HttpRunner 实现参数化数据驱动机制》</a>一文中，我们实现了参数化数据驱动的需求，并阐述了其设计思路的演变历程和开发实现涉及的核心要素。</p>
<h2 id="问题及思考"><a href="#问题及思考" class="headerlink" title="问题及思考"></a>问题及思考</h2><p>经过一段时间的实际应用后，虽然参数化数据驱动的功能可以正常使用，但终究感觉不够优雅。</p>
<p>概括下来，主要有如下 4 个方面。</p>
<p>1、调用方式不够自然，描述方式比较繁琐。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"user management testset."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - user_agent:</span> Random</div><div class="line"><span class="attr">        - app_version:</span> Sequential</div></pre></td></tr></table></figure>
<p>描述参数取值方式的时候，需要采用<code>Sequential</code>和<code>Random</code>来进行指定是要顺序取值还是随机乱序取值。暂且不说<code>Sequential</code>这个单词大家能否总是保证拼写正确，绝大多数情况下都是顺序取值，却也总是需要指定<code>Sequential</code>，的确会比较繁琐。</p>
<p>2、即使是简单的数据驱动场景，也同样需要准备 CSV 文件，问题复杂化。</p>
<p>指定数据驱动的数据源时，必须创建一个 CSV 文件，并将参数化数据放置在其中。对于大数据量的情况可能没啥问题，但是假如是非常简单的场景，例如上面的例子中，我们只需要对<code>app_version</code>设定参数列表 <code>[&#39;2.8.5&#39;, &#39;2.8.6&#39;]</code>，虽然只有两个参数值，也同样需要去单独创建一个 CSV 文件，就会显得比较繁琐了。</p>
<p>试想，假如对于简单的参数化数据驱动场景，我们可以直接在 YAML/JSON 测试用例中描述参数列表，如下所示，那就简单得多了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"user management testset."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - user_agent:</span> [<span class="string">'iOS/10.1'</span>, <span class="string">'iOS/10.2'</span>, <span class="string">'iOS/10.3'</span>]</div><div class="line"><span class="attr">        - app_version:</span> [<span class="string">'2.8.5'</span>, <span class="string">'2.8.6'</span>]</div></pre></td></tr></table></figure>
<p>3、无法兼顾没有现成参数列表，或者需要更灵活的方式动态生成参数列表的情况。</p>
<p>例如，假如我们期望每次执行测试用例的时候，里面的参数列表都是按照特定规则动态生成的。那在之前的模式下，我们就只能写一个动态生成参数的函数，然后在每次运行测试用例之前，先执行函数生成参数列表，然后将这些参数值导入到 CSV 文件中。想想都感觉好复杂。</p>
<p>既然 HttpRunner 已经实现了在 YAML/JSON 测试用例中调用函数的功能，那为啥不将函数调用与获取参数化列表的功能实现和描述语法统一起来呢？</p>
<p>试想，假如我们需要动态地生成 10 个账号，包含用户名和密码，那我们就可以将动态生成参数的函数放置到 <code>debugtalk.py</code> 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_account</span><span class="params">(num)</span>:</span></div><div class="line">    accounts = []</div><div class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, num+<span class="number">1</span>):</div><div class="line">        accounts.append(</div><div class="line">            &#123;<span class="string">"username"</span>: <span class="string">"user%s"</span> % index, <span class="string">"password"</span>: str(index) * <span class="number">6</span>&#125;,</div><div class="line">        )</div><div class="line"></div><div class="line">    <span class="keyword">return</span> accounts</div></pre></td></tr></table></figure>
<p>然后，在 YAML/JSON 测试用例中，再使用 <code>${}</code> 的语法来调用函数，并将函数返回的参数列表传给需要参数化的变量。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - username-password:</span> $&#123;get_account(<span class="number">10</span>)&#125;</div></pre></td></tr></table></figure>
<p>实现了这一特性后，要再兼容从 CSV 文件数据源中读取参数列表的方式也很简单了。我们只需要在 HttpRunner 中内置一个解析 CSV 文件的 <code>parameterize</code> 函数（也可以简写为 <code>P</code> 函数），然后就可以在 YAML/JSON 中通过函数调用的方式引用 CSV 文件了。如下例中的 user_id 所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"demo"</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - user_agent:</span> [<span class="string">"iOS/10.1"</span>, <span class="string">"iOS/10.2"</span>, <span class="string">"iOS/10.3"</span>]</div><div class="line"><span class="attr">        - user_id:</span> $&#123;P(user_id.csv)&#125;</div><div class="line"><span class="attr">        - username-password:</span> $&#123;get_account(<span class="number">10</span>)&#125;</div></pre></td></tr></table></figure>
<p>这样一来，我们就可以优雅地实现参数列表数据源的指定了，并且从概念理解和框架实现的角度也能完成统一，即对于 <code>parameters</code> 中的参数变量而言，传入的都是一个参数列表，这个列表可以是直接指定的，可以是从 CSV 文件中加载的，也可以是通过调用自定义函数动态生成的。</p>
<p>4、数据驱动只能在测试用例集（testset）层面，不能针对单个测试用例（testcse）进行数据驱动。</p>
<p>例如，用例集里面有两个接口，第一个接口是获取 token，第二个接口是创建用户（参考 <a href="http://cn.httprunner.org/quickstart/#_12" target="_blank" rel="noopener">QuickStart</a> 中的 <a href="http://cn.httprunner.org/data/demo-quickstart-6.json" target="_blank" rel="noopener">demo-quickstart-6.json</a>）。那么按照之前的设计，在 config 中配置了参数化之后，就是针对整个测试用例集（testset）层面的数据驱动，使用每一组参数运行的时候都要先执行第一个接口，再执行第二个接口。</p>
<p>这可能就跟我们预期的情况不一样了。假如我们期望的是只针对第二个接口做数据驱动，即第一个接口只需要调用一次获取到 token，然后使用参数列表中的数值分别调用第二个接口创建用户，那么之前的方法就行不通了。</p>
<p>既然有这类需求，因此数据驱动也应该具有作用域的概念。</p>
<p>类似于定义的 <code>variables</code>，定义在 config 中是全局有效的，定义在 test 中就只对当前测试用例有效。同样地，我们也可以针对 parameters 增加作用域的概念，若只需实现对当前用例（testcase）的参数化数据驱动，就可以将 parameters 配置放置到当前 test 中。</p>
<h2 id="新的实现"><a href="#新的实现" class="headerlink" title="新的实现"></a>新的实现</h2><p>想法明确了，改造实现也就比较简单了。</p>
<p>从版本 <code>1.1.0</code> 开始，HttpRunner 便支持了上述新的数据驱动方式。详细的使用方法，可参考如下使用说明文档：</p>
<p><a href="http://cn.httprunner.org/advanced/data-driven/" target="_blank" rel="noopener">http://cn.httprunner.org/advanced/data-driven/</a></p>
<p>至此，HttpRunner 的数据驱动机制就比较完善和稳定了，应该可以解决绝大多数数据驱动场景的需求。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>不过，还有一类场景暂时没有实现支持，即需要根据先前接口返回结果来对后续接口进行数据驱动的情况。</p>
<p>以如下场景为例：</p>
<ul>
<li>加载用户列表，获取当前用户列表中的所有用户；</li>
<li>依次对每一个用户进行点赞或者发送消息的操作。</li>
</ul>
<p>这和前面的第三条有点类似，都需要先动态获取参数列表，然后再使用获取得到的参数列表进行数据驱动。但也存在较大的差异，即获取用户列表的操作也是测试场景的一部分，并且通常因为需要共享 session 和 cookies，因此不能将第一步的请求放置到 debugtalk.py 中。</p>
<p>之前的一个想法是，在第一个接口中，将结果返回的用户列表提取（extract）出来保存至变量（user_list），然后在后续需要做数据驱动的接口中，在 parameters 中引用前面提取出的用户列表（$user_list）；若有需要，还可以自定义函数（parse_users），将前面提取出来的用户列表转换至框架支持的格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> load user list</div><div class="line"><span class="attr">    request:</span> &#123;...&#125;</div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - user_list:</span> content.users</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> send message to user</div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - user:</span> $&#123;parse_users($user_list)&#125;</div><div class="line"><span class="attr">    request:</span> &#123;...&#125;</div></pre></td></tr></table></figure>
<p>这个方式乍一看是可行的，但实际却是行不通的。</p>
<p>问题在于，在 HttpRunner 的数据驱动机制中，采用参数列表构造测试用例是在初始化阶段，做的工作主要是根据参数列表中的数据生成测试用例并添加至 unittest 的 TestSuite 中，此时测试用例还没有进入执行环节，因此也没法从接口的响应结果中提取参数列表。</p>
<p>若非要解决这个问题，针对 test 的数据驱动，可以将解析 parameters 的实现放置到 request 中；这的确可以实现上述场景中的功能，但在测试用例执行统计方面就会出现问题。以该场景为例，假如获取到的用户列表有100个用户，那么整个用例集将执行101次测试用例，但最终生成的测试报告中却只会展示运行了2条测试用例。</p>
<p>针对该场景，我还没有想到很好的解决方案，暂且将其作为一个遗留问题吧。若你有比较好的实现方案，欢迎反馈给我，或者直接提交 <a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="noopener">PR</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/httprunner-data-driven/&quot;&gt;《HttpRunner 实现参数化数据驱动机制》&lt;/a&gt;一文中，我们实现了参数化数据驱动的需求，并阐述了其设计思路的演变历程和开发实现涉及的核心要素。&lt;
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="Parameter" scheme="http://debugtalk.com/tags/Parameter/"/>
    
      <category term="Data-Driven" scheme="http://debugtalk.com/tags/Data-Driven/"/>
    
  </entry>
  
  <entry>
    <title>在大疆做测试开发是一种什么体验？</title>
    <link href="http://debugtalk.com/post/test-dev-in-dji/"/>
    <id>http://debugtalk.com/post/test-dev-in-dji/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-03-04T16:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>提到测试开发这个岗位，可能有的人会有些陌生，都听说过软件测试和软件开发，但测试开发又是干什么的呢？</p>
<p>说到这里，我又想起之前在阿里移动事业群的一件趣事儿。当时也是做测试开发岗位，我所在的组在公司内部有一个响当当的名号，“牲畜组”，生产力促进组嘛。有的同事更直接，亲切地叫我们组为”畜牲组“，促进生产力组的简称。</p>
<p>可以看到，不管是”牲畜“还是”畜牲“，测试开发这个岗位的核心都是提升团队生产力，也就是工作效率。更具体地，在大多数公司内部，测试开发岗位的职责就是提升业务测试人员的测试效率。</p>
<p>接触过软件测试的同学都知道，在项目版本迭代的过程中，业务测试人员需要进行大量的回归测试，重复工作量较大，在短暂的时间内也很难保证较大的测试覆盖率。这就需要测试开发人员来辅助开发相应的工具和平台，常见的包括实现接口测试自动化、UI自动化、性能专项、持续集成、线上监控等，将测试人员从重复性的工作解放出来，从而能有更多的时间精力投入到探索性测试当中去。</p>
<p>从这个层面上来讲，当前各个互联网公司的做法都差不多，只是不同公司可能会因为业务类型差异而有所侧重而已。</p>
<p>但回归生产力的本质，我们会发现，测试效率只能算是团队生产力的一部分。这就好比一个木桶，测试效率只是其中的一块木板，而研发效率、运维效率、项目管理等木板，同样制约着项目团队的整体工作效率。</p>
<p>可能有人会说，这些都不是测试开发的工作范畴啊！</p>
<p>事实上，很多公司的测试开发的确是没法触及到测试以外的工作内容的。甚至很多时候，整个测试团队都是直接向研发团队进行工作汇报，即使在提升测试效率的本职工作中话语权也是少之又少，更别谈测试以外的了。</p>
<p><strong>那么，在大疆互联网事业部做测试开发又有什么不同呢？</strong></p>
<p>得益于大疆“<em>激极尽致，求真品诚</em>”的企业文化，岗位并没有那么严格的界限划分。如果你发现一件事确实有价值，但当前却没有人去做，那么即使这不在你的工作范畴之内，你也可以主动站出来挑起这块儿的担子。</p>
<p>对于大疆的测试开发岗位同样如此，岗位性质决定了我们会比其它任何岗位都更关注团队的生产力和工作效率，那么不管是研发、运维、测试、运营还是项目管理，假如其中任何一个环节存在效率低下的问题，我们都可以申请立项，通过开发工具或平台来解决团队的痛点。当然，可能某些事情并不是测试开发岗位的同学就能独自完成的，那也没有关系，只要提出的问题确实具有业务价值，那么我们也可以申请到其它岗位的同学来协作一起完成。可能对于某些公司来说不可想象，但这在大疆确实就是切实可行的。</p>
<p>另一方面，大疆发展极其迅速，触及的领域也越来越广。这对我们测试开发来说，既是机遇，也是挑战。在这种环境下，我们有机会充分发挥主观能动性，去挖掘并解决团队中实际存在的痛点。分析需求、设计方案、技术选型、编码实现、收集反馈、迭代优化，这么一个流程下来，产出的工具或平台就如同自己精心打造的产品，成就感和按部就班地搬砖是完全不一样的。也许，我们测试开发岗位才是最接近”全栈“的工程师？</p>
<p>除此之外，在大疆的测试开发工程师还兼具着更多的职责。例如，整个互联网事业部的所有系统，遇到新品发布、技术升级改造、系统架构重构等重大事件时，压力测试都是由我们测试开发组来主导完成的。在质量部内部，我们测试开发组还会兼顾对业务测试同学进行测试技术和编程语言的培训，以及协助业务测试同学解决一些技术难题等。在这个过程中，我们测试开发本身的技术视野和解决问题的能力也得到了极大的增强。</p>
<p>最后，如果你对我们的岗位感兴趣，欢迎加入我们！</p>
<h2 id="广告时间"><a href="#广告时间" class="headerlink" title="广告时间"></a>广告时间</h2><p>近期，大疆创新开启新的一轮招聘啦，深圳总部、北京研发中心、上海分公司均有大量岗位招聘需求。</p>
<p>详细的招聘需求和日程安排请见：<a href="https://mp.weixin.qq.com/s/vlhAWho2hMOiWIVwkfIf0A" target="_blank" rel="noopener">【内推】大疆创新春季招聘开启啦（深圳+北京）</a></p>
<p>如需找我内推，请发送简历至我的个人邮箱: <strong>mail@debugtalk.com</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到测试开发这个岗位，可能有的人会有些陌生，都听说过软件测试和软件开发，但测试开发又是干什么的呢？&lt;/p&gt;
&lt;p&gt;说到这里，我又想起之前在阿里移动事业群的一件趣事儿。当时也是做测试开发岗位，我所在的组在公司内部有一个响当当的名号，“牲畜组”，生产力促进组嘛。有的同事更直接，
    
    </summary>
    
    
      <category term="招聘" scheme="http://debugtalk.com/tags/%E6%8B%9B%E8%81%98/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 实现参数化数据驱动机制</title>
    <link href="http://debugtalk.com/post/httprunner-data-driven/"/>
    <id>http://debugtalk.com/post/httprunner-data-driven/</id>
    <published>2018-02-15T16:00:00.000Z</published>
    <updated>2018-03-25T08:29:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>从 1.1.0 版本开始，数据驱动机制进行了较大的优化和调整。<br>请参考：<a href="http://debugtalk.com/post/httprunner-data-driven/">《HttpRunner 再议参数化数据驱动机制》</a></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在自动化测试中，经常会遇到如下场景：</p>
<blockquote>
<p>1、测试搜索功能，只有一个搜索输入框，但有10种不同类型的搜索关键字；<br>2、测试账号登录功能，需要输入用户名和密码，按照等价类划分后有20种组合情况。</p>
</blockquote>
<p>这里只是随意找了两个典型的例子，相信大家都有遇到过很多类似的场景。总结下来，就是在我们的自动化测试脚本中存在参数，并且我们需要采用不同的参数去运行。</p>
<p>经过概括，参数基本上分为两种类型：</p>
<ul>
<li>单个独立参数：例如前面的第一种场景，我们只需要变换搜索关键字这一个参数</li>
<li>多个具有关联性的参数：例如前面的第二种场景，我们需要变换用户名和密码两个参数，并且这两个参数需要关联组合</li>
</ul>
<p>然后，对于参数而言，我们可能具有一个参数列表，在脚本运行时需要按照不同的规则去取值，例如顺序取值、随机取值、循环取值等等。</p>
<p>对于这一块儿，没有太多新的概念，这就是典型的参数化和数据驱动。遗憾的是，当前<code>HttpRunner</code>并未支持该功能特性。</p>
<p>考虑到该需求的普遍性，并且近期提到该需求的的人也越来越多（<a href="https://github.com/HttpRunner/HttpRunner/issues/74" target="_blank" rel="noopener">issue #74</a>, <a href="https://github.com/HttpRunner/HttpRunner/issues/87" target="_blank" rel="noopener">issue #87</a>, <a href="https://github.com/HttpRunner/HttpRunner/issues/88" target="_blank" rel="noopener">issue #88</a>, <a href="https://github.com/HttpRunner/HttpRunner/issues/97" target="_blank" rel="noopener">issue #97</a>），因此趁着春节假期的空闲时间，决定优先实现下。</p>
<p>经过前面的场景分析，我们的目标已经很明确了，接下来就是如何实现的问题了。</p>
<h2 id="借鉴-LoadRunner-的数据参数化"><a href="#借鉴-LoadRunner-的数据参数化" class="headerlink" title="借鉴 LoadRunner 的数据参数化"></a>借鉴 LoadRunner 的数据参数化</h2><p>要造一个轮子，最好是先看下现有知名轮子的实现机制。之前有用过一段时间的 LoadRunner，对其参数化机制印象蛮深的，虽然它是性能测试工具，但在脚本参数化方面是通用的。</p>
<p>我们先看下在 LoadRunner 中是如何实现参数化的。</p>
<p>在 LoadRunner 中，可以在脚本中创建一个参数，然后参数会保存到一个<code>.dat</code>的文件中，例如下图中的<code>psd.dat</code>。</p>
<p><img src="/images/loadrunner-parameterize.jpg" alt=""></p>
<p>在<code>.dat</code>文件中，是采用表格的形式来存储参数值，结构与<code>CSV</code>基本一致。</p>
<p>对于单个独立参数，可以将参数列表保存在一个单独的<code>.dat</code>文件中，第一行为参数名称，后续每一行为一个参数值。例如本文背景介绍中的第一类场景，数据存储形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Keyword</div><div class="line">hello</div><div class="line">world</div><div class="line">debugtalk</div></pre></td></tr></table></figure>
<p>然后对于参数的取值方式，可以通过<code>Select next row</code>和<code>Update value on</code>进行配置。</p>
<p><code>Select next row</code>的可选方式有：</p>
<ul>
<li>Sequential：顺序取值</li>
<li>Random：随机取值</li>
<li>Unique：为每个虚拟用户分配一条唯一的数据</li>
</ul>
<p><code>Update value on</code>的可选方式有：</p>
<ul>
<li>Each iteration：每次脚本迭代时更新参数值</li>
<li>Each occurrence：每次出现参数引用时更新参数值</li>
<li>Once：每条数据只能使用一次</li>
</ul>
<p>而且，可以通过对这两种方式进行组合，配制出9种参数化方式。</p>
<p>另外，因为 LoadRunner 本身是性能测试工具，具有长时间运行的需求，假如<code>Select next row</code>选择为<code>Unique</code>，同时<code>Update value on</code>设置为<code>Each iteration</code>，那么就会涉及到参数用完的情况。在该种情况下，可通过<code>When out of value</code>配置项实现如下选择：</p>
<ul>
<li>Abort vuser：当超出时终止脚本</li>
<li>Continue in a cyclic manner：当超出时回到列表头再次取值</li>
<li>Continue with last value：使用参数表中的最后一个值</li>
</ul>
<p>对于多个具有关联性的参数，可以将关联参数列表保存在一个<code>.dat</code>文件中，第一行为参数名称，后续每一行为一个参数值，参数之间采用逗号进行分隔。例如本文背景介绍中的第二类场景，数据存储形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UserName,Password</div><div class="line">test1,111111</div><div class="line">test2,222222</div><div class="line">test3,333333</div></pre></td></tr></table></figure>
<p>对于参数的取值方式，与上面单个独立参数的取值方式基本相同。差异在于，我们可以只配置一个参数（例如<code>UserName</code>）的取值方式，然后其它参数（例如<code>Password</code>）的取值方式选择为<code>same line as UserName</code>。如此一来，我们就可以保证参数化时的数据关联性。</p>
<p>LoadRunner 的参数化机制就回顾到这里，可以看出，其功能还是很强大的，使用也十分灵活。</p>
<h2 id="设计思路演变历程"><a href="#设计思路演变历程" class="headerlink" title="设计思路演变历程"></a>设计思路演变历程</h2><p>现在再回到我们的 HttpRunner，要如何来实现参数化机制呢？</p>
<p>因为 LoadRunner 的参数化机制比较完善，用户群体也很大，因此我在脑海里最先冒出的想法就是照抄 LoadRunner，将 LoadRunner 在 GUI 中配置的内容在 HttpRunner 中通过<code>YAML/JSON</code>来进行配置。</p>
<p>按照这个思路，在 HttpRunner 的 config 中，就要有一块儿地方用来进行参数化配置，暂且设定为<code>parameters</code>吧。然后，对于每一个参数，其参数列表要单独存放在文件中，考虑到LoadRunner中的<code>.dat</code>文件基本就是<code>CSV</code>格式，因此可以约定采用大众更熟悉的<code>.csv</code>文件来存储参数；在脚本中，要指定参数变量从哪个文件中取值，那么就需要设定一个<code>parameter_file</code>，用于指定对应的参数文件路径。接下来，要实现取值规则的配置，例如是顺序取值还是随机取值，那么就需要设定<code>select_next_row</code>和<code>update_value_on</code>。</p>
<p>根据该设想，在<code>YAML</code>测试用例文件中，数据参数化将描述为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"demo for data driven."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - Keyword:</span></div><div class="line"><span class="attr">            parameter_file:</span> keywords.csv</div><div class="line"><span class="attr">            select_next_row:</span> Random</div><div class="line"><span class="attr">            update_value_on:</span> EachIteration</div><div class="line"><span class="attr">        - UserName:</span></div><div class="line"><span class="attr">            parameter_file:</span> account.csv</div><div class="line"><span class="attr">            select_next_row:</span> Sequential</div><div class="line"><span class="attr">            update_value_on:</span> EachIteration</div><div class="line"><span class="attr">        - Password:</span></div><div class="line"><span class="attr">            parameter_file:</span> account.csv</div><div class="line"><span class="attr">            select_next_row:</span> same line as UserName</div></pre></td></tr></table></figure>
<p>这个想法基本可行，但就是感觉配置项有些繁琐，我们可以尝试再对其进行简化。</p>
<p>首先，比较明显的，针对每个参数都要配置<code>select_next_row</code>和<code>update_value_on</code>，虽然从功能上来说比较丰富，但是对于用户来说，这些功能并不都是必须的。特别是<code>update_value_on</code>这个参数，绝大多数情况下我们的需求应该都是采用<code>Each iteration</code>，即每次脚本再次运行时更新参数值。因此，我们可以去除<code>update_value_on</code>这个配置项，默认都是采用<code>Each iteration</code>的方式。</p>
<p>经过第一轮简化，配置描述方式变为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"demo for data driven."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - Keyword:</span></div><div class="line"><span class="attr">            parameter_file:</span> keywords.csv</div><div class="line"><span class="attr">            select_next_row:</span> Random</div><div class="line"><span class="attr">        - UserName:</span></div><div class="line"><span class="attr">            parameter_file:</span> account.csv</div><div class="line"><span class="attr">            select_next_row:</span> Sequential</div><div class="line"><span class="attr">        - Password:</span></div><div class="line"><span class="attr">            parameter_file:</span> account.csv</div><div class="line"><span class="attr">            select_next_row:</span> same line as UserName</div></pre></td></tr></table></figure>
<p>然后，我们可以看到<code>UserName</code>和<code>Password</code>这两个参数，它们有关联性，但却各自单独进行了配置；而且对于有关联性的参数，除了需要对第一个参数配置取值方式外，其它参数的<code>select_next_row</code>应该总是为<code>same line as XXX</code>，这样描述就显得比较累赘了。</p>
<p>既然是有关联性的参数，那就放在一起吧，参数名称可以采用约定的符号进行分离。考虑到参数变量名称通常包含字母、数字和下划线，同时要兼顾<code>YAML/JSON</code>中对字符的限制，因此选择短横线（<code>-</code>）作为分隔符吧。</p>
<p>经过第二轮简化，配置描述方式变为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"demo for data driven."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - Keyword:</span></div><div class="line"><span class="attr">            parameter_file:</span> keywords.csv</div><div class="line"><span class="attr">            select_next_row:</span> Random</div><div class="line"><span class="attr">        - UserName-Password:</span></div><div class="line"><span class="attr">            parameter_file:</span> account.csv</div><div class="line"><span class="attr">            select_next_row:</span> Sequential</div></pre></td></tr></table></figure>
<p>接着，我们再看下<code>parameter_file</code>参数。因为我们测试用例中的参数名称必须与数据源进行绑定，因此这一项信息是不可少的。但是在描述形式上，还是会感觉有些繁琐。再一想，既然我们本来就要指定参数名称，那何必不将参数名称约定为文件名称呢？</p>
<p>例如，对于参数<code>Keyword</code>，我们可以将其数据源文件名称约定为<code>Keyword.csv</code>；对于参数<code>UserName</code>和<code>Password</code>，我们可以将其数据源文件名称约定为<code>UserName-Password.csv</code>；然后，再约定数据源文件需要与当前<code>YAML/JSON</code>测试用例文件放置在同一个目录。</p>
<p>经过第三轮简化，配置描述方式变为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"demo for data driven."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - Keyword:</span></div><div class="line"><span class="attr">            select_next_row:</span> Random</div><div class="line"><span class="attr">        - UserName-Password:</span></div><div class="line"><span class="attr">            select_next_row:</span> Sequential</div></pre></td></tr></table></figure>
<p>同时该用例文件同级目录下的数据源文件名称为<code>Keyword.csv</code>和<code>UserName-Password.csv</code>。</p>
<p>现在，我们就只剩下<code>select_next_row</code>一个配置项了。既然是只剩一项，那就也省略配置项名称吧。</p>
<p>最终，我们的配置描述方式变为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"demo for data driven."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - Keyword:</span> Random</div><div class="line"><span class="attr">        - UserName-Password:</span> Sequential</div></pre></td></tr></table></figure>
<p>不过，我们还忽略了一个信息，那就是脚本的运行次数。假如参数取值都是采用<code>Sequential</code>的方式，那么我们可以将不同组参数进行笛卡尔积的组合，这是一个有限次数，可以作为自动化测试运行终止的条件；但如果参数取值采用<code>Random</code>的方式，即每次都是在参数列表里面随机取值，那么就不好界定自动化测试运行终止的条件了，我们只能手动进行终止，或者事先指定运行的总次数，不管是采用哪种方式，都会比较麻烦。</p>
<p>针对参数取值采用<code>Random</code>方式的这个问题，我们不妨换个思路。从数据驱动的角度来看，我们期望在自动化测试时能遍历数据源文件中的所有数据，那么重复采用相同参数进行测试的意义就不大了。因此，在选择<code>Random</code>的取值方式时，我们可以先将参数列表进行乱序排序，然后采用顺序的方式进行遍历；对于存在多组参数的情况，也可以实现乱序排序后再进行笛卡尔积的组合方式了。</p>
<p>到此为止，我们的参数化配置方式应该算是十分简洁了，而且在功能上也能满足常规参数化的配置需求。</p>
<p>最后，我们再回过头来看脚本参数化设计思路的演变历程，基本上都可以概括为<code>约定大于配置</code>，这的确也是<code>HttpRunner</code>崇尚和遵循的准则。</p>
<h2 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h2><p>设计思路理顺了，实现起来就比较简单了，点击此处查看<a href="https://github.com/HttpRunner/HttpRunner/commit/f8569aad914d4fe47ec24ac2e2e472b7b93c310d" target="_blank" rel="noopener">相关代码</a>，就会发现实际的代码量并不多。</p>
<p>在这里我就只挑几个典型的点讲下。</p>
<h3 id="数据源格式约定"><a href="#数据源格式约定" class="headerlink" title="数据源格式约定"></a>数据源格式约定</h3><p>既然是参数化，那么肯定会存在数据源的问题，我们约定采用<code>.csv</code>文件格式来存储参数列表。同时，在同一个测试场景中可能会存在多个参数的情况，为了降低问题的复杂度，我们可以约定独立参数存放在独立的<code>.csv</code>文件中，多个具有关联性的参数存放在一个<code>.csv</code>文件中。另外，我们同时约定在<code>.csv</code>文件中的第一行必须为参数名称，并且要与文件名保持一致；从第二行开始为参数值，每个值占一行。</p>
<p>例如，<code>keyword</code>这种独立的参数就可以存放在<code>keyword.csv</code>中，内容形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">keyword</div><div class="line">hello</div><div class="line">world</div><div class="line">debugtalk</div></pre></td></tr></table></figure>
<p><code>username</code>和<code>password</code>这种具有关联性的参数就可以存放在<code>username-password.csv</code>中，内容形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">username,password</div><div class="line">test1,111111</div><div class="line">test2,222222</div><div class="line">test3,333333</div></pre></td></tr></table></figure>
<h3 id="csv-解析器"><a href="#csv-解析器" class="headerlink" title="csv 解析器"></a>csv 解析器</h3><p>数据源的格式约定好了，我们要想进行读取，那么就得有一个对应的解析器。因为我们后续想要遍历每一行数据，并且还会涉及到多个参数进行组合的情况，因此我们希望解析出来的每一行数据应该同时包含参数名称和参数值。</p>
<p>于是，我们的数据结构就约定采用<code>list of dict</code>的形式。即每一个<code>.csv</code>文件解析后会得到一个列表（list），而列表中的每一个元素为一个字典结构（dict），对应着一行数据的参数名称和参数值。具体实现的代码函数为<a href="https://github.com/HttpRunner/HttpRunner/commit/f8569aad914d4fe47ec24ac2e2e472b7b93c310d#diff-1ef6376047562e36a304745bca9ade9aR47" target="_blank" rel="noopener"><code>_load_csv_file</code></a>。</p>
<p>例如，上面的<code>username-password.csv</code>经过解析，会生成如下形式的数据结构。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;'username': 'test1', 'password': '111111'&#125;,</div><div class="line">    &#123;'username': 'test2', 'password': '222222'&#125;,</div><div class="line">    &#123;'username': 'test3', 'password': '333333'&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这里还会涉及到一个问题，就是参数取值顺序。</p>
<p>在<code>YAML/JSON</code>测试用例中，我们会配置参数的取值顺序，是要顺序取值（<code>Sequential</code>）还是乱序随机取值（<code>Random</code>）。对于顺序的情况没啥好说的，默认从<code>.csv</code>文件中读取出的内容就是顺序的；对于随机取值，更确切地说，应该是乱序取值，我们需要进行一次乱序排序，实现起来也很简单，使用<code>random.shuffle</code>函数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> fetch_method.lower() == <span class="string">"random"</span>:</div><div class="line">    random.shuffle(csv_content_list)</div></pre></td></tr></table></figure>
<h3 id="多个参数的组合"><a href="#多个参数的组合" class="headerlink" title="多个参数的组合"></a>多个参数的组合</h3><p>然后，对于多个参数的情况，为了组合出所有可能的情况，我们就需要用到笛卡尔积的概念。直接看例子可能会更好理解些。</p>
<p>例如我们在用例场景中具有三个参数，<code>a</code>为独立参数，参数列表为[1, 2]；<code>x</code>和<code>y</code>为关联参数，参数列表为[[111,112], [121,122]]；经过解析后，得到的数据分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a:</div><div class="line">[&#123;&quot;a&quot;: 1&#125;, &#123;&quot;a&quot;: 2&#125;]</div><div class="line"></div><div class="line">x &amp; y:</div><div class="line">[</div><div class="line">    &#123;&quot;x&quot;: 111, &quot;y&quot;: 112&#125;,</div><div class="line">    &#123;&quot;x&quot;: 121, &quot;y&quot;: 122&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>那么经过笛卡尔积，就可以组合出4种情况，组合后的结果应该为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;'a': 1, 'x': 111, 'y': 112&#125;,</div><div class="line">    &#123;'a': 1, 'x': 121, 'y': 122&#125;,</div><div class="line">    &#123;'a': 2, 'x': 111, 'y': 112&#125;,</div><div class="line">    &#123;'a': 2, 'x': 121, 'y': 122&#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这里需要强调的是，多个参数经过笛卡尔积运算转换后，仍然是<code>list of dict</code>的数据结构，列表中的每一个字典（dict）代表着参数的一种组合情况。</p>
<h3 id="参数化数据驱动"><a href="#参数化数据驱动" class="headerlink" title="参数化数据驱动"></a>参数化数据驱动</h3><p>现在，我们已经实现了在<code>YAML/JSON</code>测试用例文件中对参数进行配置，从<code>.csv</code>数据源文件中解析出参数列表，并且生成所有可能的组合情况。最后还差一步，就是如何使用参数值来驱动测试用例的执行。</p>
<p>听上去很高大上，但实际却异常简单，直接对照着<a href="https://github.com/HttpRunner/HttpRunner/commit/f8569aad914d4fe47ec24ac2e2e472b7b93c310d#diff-fe4aef5754006b3e9100eb41eb3ca28cR57" target="_blank" rel="noopener">代码</a>来说吧。</p>
<p><img src="/images/httprunner-parameterize.jpg" alt=""></p>
<p>对于每一组参数组合情况来说，我们完全可以将其视为当前用例集运行时定义的变量值。而在 HttpRunner 中每一次运行测试用例集的时候都需要对<code>runner.Runner</code>做一次初始化，里面会用到定义的变量（即<code>config_dict[&quot;variables&quot;]</code>），那么，我们完全可以在每次初始化的时候将组合好的参数作为变量传进去，假如存在同名的变量，就进行覆盖。</p>
<p>这样一来，我们就可以使用所有的参数组合情况来依次驱动测试用例的执行，并且每次执行时都采用了不同的参数，从而也就实现了参数化数据驱动的目的。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>最后我们再来看下实际的运行效果吧。</p>
<p>假设我们有一个获取token的接口，我们需要使用 user_agent 和 app_version 这两个参数来进行参数化数据驱动。</p>
<p>YAML 测试用例的描述形式如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"user management testset."</span></div><div class="line"><span class="attr">    parameters:</span></div><div class="line"><span class="attr">        - user_agent:</span> Random</div><div class="line"><span class="attr">        - app_version:</span> Sequential</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></div><div class="line"><span class="attr">        - device_sn:</span> $&#123;gen_random_string(<span class="number">15</span>)&#125;</div><div class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></div><div class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> $BASE_URL</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token with $user_agent and $app_version</div><div class="line"><span class="attr">    api:</span> get_token($user_agent, $device_sn, $os_platform, $app_version)</div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="attr">        - "eq":</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - "len_eq":</span> [<span class="string">"content.token"</span>, <span class="number">16</span>]</div></pre></td></tr></table></figure>
<p>其中，user_agent 和 app_version 的数据源列表分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">user_agent</div><div class="line">iOS/10.1</div><div class="line">iOS/10.2</div><div class="line">iOS/10.3</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app_version</div><div class="line">2.8.5</div><div class="line">2.8.6</div></pre></td></tr></table></figure>
<p>那么，经过笛卡尔积组合，应该总共有6种参数组合情况，并且 user_agent 为乱序取值，app_version 为顺序取值。</p>
<p>最终的测试结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ hrun tests/data/demo_parameters.yml</div><div class="line"></div><div class="line">Running tests...</div><div class="line">----------------------------------------------------------------------</div><div class="line"> get token with iOS/10.2 and 2.8.5 ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 13 ms, response_length: 46 bytes</div><div class="line">OK (0.014845)s</div><div class="line"> get token with iOS/10.2 and 2.8.6 ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 2 ms, response_length: 46 bytes</div><div class="line">OK (0.003909)s</div><div class="line"> get token with iOS/10.1 and 2.8.5 ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 3 ms, response_length: 46 bytes</div><div class="line">OK (0.004090)s</div><div class="line"> get token with iOS/10.1 and 2.8.6 ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 5 ms, response_length: 46 bytes</div><div class="line">OK (0.006673)s</div><div class="line"> get token with iOS/10.3 and 2.8.5 ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 3 ms, response_length: 46 bytes</div><div class="line">OK (0.004775)s</div><div class="line"> get token with iOS/10.3 and 2.8.6 ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 3 ms, response_length: 46 bytes</div><div class="line">OK (0.004846)s</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 6 tests in 0.046s</div></pre></td></tr></table></figure>
<p>至此，我们就已经实现了参数化数据驱动的需求。对于测试用例中参数的描述形式，大家要是发现还有更加简洁优雅的方式，欢迎反馈给我。</p>
<p>最后，本文发表于 2018 年大年初一，祝大家新年快乐，狗年旺旺旺！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从 1.1.0 版本开始，数据驱动机制进行了较大的优化和调整。&lt;br&gt;请参考：&lt;a href=&quot;http://debugtalk.com/post/httprunner-data-driven/&quot;&gt;《HttpRunner 再议参数化数据驱动机制》&lt;
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="Parameter" scheme="http://debugtalk.com/tags/Parameter/"/>
    
      <category term="Data-Driven" scheme="http://debugtalk.com/tags/Data-Driven/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 通过 skip 机制实现对测试用例的分组执行控制</title>
    <link href="http://debugtalk.com/post/HttpRunner-skip-feature/"/>
    <id>http://debugtalk.com/post/HttpRunner-skip-feature/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2018-02-08T16:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>近期，某位同学对<code>HttpRunner</code>提了一个<a href="https://github.com/HttpRunner/HttpRunner/issues/96" target="_blank" rel="external">需求点</a>：</p>
<blockquote>
<p>能否支持类似unittest中的skip注解，方便灵活剔除某些用例，不执行。<br>目前在接口测试日常构建中，会遇到一些接口开发暂时屏蔽了或者降级，导致用例执行失败；所以想当遇到这些情况的时候，能够临时剔除掉某些用例不执行；等后续恢复后，再去掉，然后恢复执行。</p>
</blockquote>
<p>针对这种情况，<code>HttpRunner</code>的确没有直接支持。之所以说是没有<code>直接</code>支持，是因为在<code>HttpRunner</code>中存在<code>times</code>关键字，可以指定某个<code>test</code>的运行次数。</p>
<p>例如，如下<code>test</code>中指定了<code>times</code>为3，那么该<code>test</code>就会运行3次。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> demo</div><div class="line"><span class="attr">    times:</span> <span class="number">3</span></div><div class="line"><span class="attr">    request:</span> &#123;...&#125;</div><div class="line"><span class="attr">    validate:</span> [...]</div></pre></td></tr></table></figure>
<p>假如要实现临时屏蔽掉某些<code>test</code>，那么就可以将对应<code>test</code>的<code>times</code>设置为0。</p>
<p>这虽然也能勉强实现需求，但是这跟直接将临时不运行的<code>test</code>注释掉没什么区别，都需要对测试用例内容进行改动，使用上很是不方便。</p>
<p>考虑到该需求的普遍性，<code>HttpRunner</code>的确应该增加对该种情况的支持。</p>
<p>在这方面，<code>unittest</code>已经有了清晰的定义，有三种常用的装饰器可以控制单元测试用例是否被执行：</p>
<ul>
<li>@unittest.skip(reason)：无条件跳过当前测试用例</li>
<li>@unittest.skipIf(condition, reason)：当条件表达式的值为true时跳过当前测试用例</li>
<li>@unittest.skipUnless(condition, reason)：当条件表达式的值为false时跳过当前测试用例</li>
</ul>
<p>该功能完全满足我们的需求，因此，我们可以直接复用其概念，尝试实现同样的功能。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>目标明确了，那需要怎么实现呢？</p>
<p>首先，我们先看下<code>unittest</code>中这三个函数是怎么实现的；这三个函数定义在<code>unittest/case.py</code>中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipTest</span><span class="params">(Exception)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Raise this exception in a test to skip it.</div><div class="line"></div><div class="line">    Usually you can use TestCase.skipTest() or one of the skipping decorators</div><div class="line">    instead of raising this directly.</div><div class="line">    """</div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip</span><span class="params">(reason)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Unconditionally skip a test.</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(test_item)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(test_item, (type, types.ClassType)):</div><div class="line"><span class="meta">            @functools.wraps(test_item)</span></div><div class="line">            <span class="function"><span class="keyword">def</span> <span class="title">skip_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">                <span class="keyword">raise</span> SkipTest(reason)</div><div class="line">            test_item = skip_wrapper</div><div class="line"></div><div class="line">        test_item.__unittest_skip__ = <span class="keyword">True</span></div><div class="line">        test_item.__unittest_skip_why__ = reason</div><div class="line">        <span class="keyword">return</span> test_item</div><div class="line">    <span class="keyword">return</span> decorator</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">skipIf</span><span class="params">(condition, reason)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Skip a test if the condition is true.</div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> condition:</div><div class="line">        <span class="keyword">return</span> skip(reason)</div><div class="line">    <span class="keyword">return</span> _id</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">skipUnless</span><span class="params">(condition, reason)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Skip a test unless the condition is true.</div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> condition:</div><div class="line">        <span class="keyword">return</span> skip(reason)</div><div class="line">    <span class="keyword">return</span> _id</div></pre></td></tr></table></figure>
<p>不难看出，核心有两点：</p>
<ul>
<li>对于<code>skip</code>，只需要在该测试用例中<code>raise SkipTest(reason)</code>，而<code>SkipTest</code>是<code>unittest/case.py</code>中定义的一个异常类；</li>
<li>对于<code>skipIf</code>和<code>skipUnless</code>，相比于<code>skip</code>，主要是需要指定一个条件表达式（condition），然后根据该表达式的实际值来决定是否<code>skip</code>当前测试用例。</li>
</ul>
<p>明确了这两点之后，我们要如何在<code>HttpRunner</code>中实现同样的功能，思路应该就比较清晰了。</p>
<p>因为<code>HttpRunner</code>同样也是采用<code>unittest</code>来组织和驱动测试用例执行的，而具体的执行控制部分都是在<code>httprunner/runner.py</code>的<code>_run_test</code>方法中；同时，在<code>_run_test</code>方法中会传入<code>testcase_dict</code>，也就是具体测试用例的全部信息。</p>
<p>那么，最简单的做法，就是在<code>YAML/JSON</code>测试用例中，新增<code>skip/skipIf/skipUnless</code>参数，然后在<code>_run_test</code>方法中根据参数内容来决定是否执行<code>raise SkipTest(reason)</code>。</p>
<p>例如，在<code>YAML</code>测试用例中，我们可以按照如下形式新增<code>skip</code>字段，其中对应的值部分就是我们需要的<code>reason</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> demo</div><div class="line"><span class="attr">    skip:</span> <span class="string">"skip this test unconditionally"</span></div><div class="line"><span class="attr">    request:</span> &#123;...&#125;</div><div class="line"><span class="attr">    validate:</span> [...]</div></pre></td></tr></table></figure>
<p>接下来在<code>_run_test</code>方法，要处理就十分简单，只需要判断<code>testcase_dict</code>中是否包含<code>skip</code>字段，假如包含，则执行<code>raise SkipTest(reason)</code>即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_test</span><span class="params">(self, testcase_dict)</span>:</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="string">"skip"</span> <span class="keyword">in</span> testcase_dict:</div><div class="line">        skip_reason = testcase_dict[<span class="string">"skip"</span>]</div><div class="line">        <span class="keyword">raise</span> SkipTest(skip_reason)</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>这对于<code>skip</code>机制来做，完全满足需求；但对于<code>skipIf/skipUnless</code>，可能就会麻烦些，因为我们的用例是在<code>YAML/JSON</code>文本格式的文件中，没法像在<code>unittest</code>中执行<code>condition</code>那样的Python表达式。</p>
<p>嗯？谁说在<code>YAML/JSON</code>中就不能执行函数表达式的？在<code>HttpRunner</code>中，我们已经实现了该功能，即：</p>
<ul>
<li>在<code>debugtalk.py</code>中定义函数，例如<code>func(a, b)</code></li>
<li>在<code>YAML/JSON</code>中通过<code>${func(a,b)}</code>对函数进行调用</li>
</ul>
<p>在此基础上，我们要实现<code>skipIf/skipUnless</code>就很简单了；很自然地，我们可以想到采用如下形式来进行描述。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which existed (skip if condition)</div><div class="line"><span class="attr">    skipIf:</span> $&#123;skip_test_in_production_env()&#125;</div><div class="line"><span class="attr">    request:</span> &#123;...&#125;</div><div class="line"><span class="attr">    validate:</span> [...]</div></pre></td></tr></table></figure>
<p>其中，<code>skip_test_in_production_env</code>定义在<code>debugtalk.py</code>文件中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">skip_test_in_production_env</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">""" skip this test in production environment</span></div><div class="line">    """</div><div class="line">    <span class="keyword">return</span> os.environ[<span class="string">"TEST_ENV"</span>] == <span class="string">"PRODUCTION"</span></div></pre></td></tr></table></figure>
<p>然后，在<code>_run_test</code>方法中，我们只需要判断<code>testcase_dict</code>中是否包含<code>skipIf</code>字段，假如包含，则将其对应的函数表达式取出，运行得到其结果，最后再根据运算结果来判断是否执行<code>raise SkipTest(reason)</code>。对函数表达式进行解析的方法在<code>httprunner/context.py</code>的<code>exec_content_functions</code>函数中，具体实现方式可阅读之前的文章。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_test</span><span class="params">(self, testcase_dict)</span>:</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="string">"skip"</span> <span class="keyword">in</span> testcase_dict:</div><div class="line">        skip_reason = testcase_dict[<span class="string">"skip"</span>]</div><div class="line">        <span class="keyword">raise</span> SkipTest(skip_reason)</div><div class="line">    <span class="keyword">elif</span> <span class="string">"skipIf"</span> <span class="keyword">in</span> testcase_dict:</div><div class="line">        skip_if_condition = testcase_dict[<span class="string">"skipIf"</span>]</div><div class="line">        <span class="keyword">if</span> self.context.exec_content_functions(skip_if_condition):</div><div class="line">            skip_reason = <span class="string">"&#123;&#125; evaluate to True"</span>.format(skip_if_condition)</div><div class="line">            <span class="keyword">raise</span> SkipTest(skip_reason)</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p><code>skipUnless</code>与<code>skipIf</code>类似，不再重复。</p>
<p>通过该种方式，我们就可以实现在不对测试用例文件做任何修改的情况下，通过外部方式（例如设定环境变量的值）就可以控制是否执行某些测试用例。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><code>skip/skipIf/skipUnless</code>机制实现后，我们对测试用例的执行控制就更加灵活方便了。</p>
<p>例如，我们可以很容易地实现如下常见的测试场景：</p>
<ul>
<li>对测试用例进行分组，P0/P1/P2等，然后根据实际需求选择执行哪些用例</li>
<li>通过环境变量来控制是否执行某些用例</li>
</ul>
<p>更重要的是，我们无需对测试用例文件进行任何修改。</p>
<p>在<code>HttpRunner</code>项目中存在一个示例文件，<a href="https://github.com/HttpRunner/HttpRunner/blob/master/tests/data/demo_testset_cli.yml" target="_blank" rel="external"><code>httprunner/tests/data/demo_testset_cli.yml</code></a>，大家可以此作为参考。</p>
<p>在运行该测试集后，生成的测试报告如下所示。</p>
<p><img src="/images/httprunner-skip.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;近期，某位同学对&lt;code&gt;HttpRunner&lt;/code&gt;提了一个&lt;a href=&quot;https://github.com
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="testcase" scheme="http://debugtalk.com/tags/testcase/"/>
    
  </entry>
  
  <entry>
    <title>我的 2017 年终总结</title>
    <link href="http://debugtalk.com/post/my-2017-summary/"/>
    <id>http://debugtalk.com/post/my-2017-summary/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2018-01-02T02:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年已经结束了，为了给以后的自己留点回忆，还是写篇博客记录下吧。</p>
<p>先从工作说起吧。这一年，我依然在大疆的互联网事业部做测试开发岗位。有点变化的是，年初是自己一个人做，然后逐步有新的伙伴加入，成立了测试开发小组，并担任了小组负责人。简单地说，就是除了纯技术，也开始兼具了一点技术管理的角色，这对于我个人也是一个挺大的转变。看过我个人博客自我介绍的同学都知道，“在墙角安静地写代码才是我的最爱”，所以我对于做管理是一直都挺抗拒的。不过，后来通过阅读一些互联网前辈的文章（主要有池建强老师、左耳朵耗子皓叔、硅谷女神安姐等），再加上leader的循序善诱，我的想法也发生了一些转变。我渐渐地也开始认同，技术管理与做好技术并不冲突，但发挥团队的力量，却可以做更大的事情，产生更大的价值。同时，担任技术管理也意味着多了一份责任，自己不能再由着个人喜好去摸索一些看似酷炫实则无用的“黑科技”，而应时刻关注技术转化的业务价值，这不管是对于公司还是个人，都是至关重要的。</p>
<p>在大疆除了测试开发工作，我还负责一些重要节点的性能压测工作。今年最大的一次压测应该就是准备5月24日的<a href="https://www.dji.com/products/spark?site=brandsite&amp;from=nav" target="_blank" rel="external"><code>Spark</code></a>新品发布了。在这个项目中，我担任性能测试总负责人，负责PC商城、手机商城、官网、直播系统、支付中心等相关电商系统的整体性能测试工作。当然，那段时间加班也挺多的，以至于我后面出差到达纽约发布会现场都不用倒时差了。说到出差，感谢领导和同事的信任，让我去发布会现场做直播系统的技术支持，我也有机会第一次去到美国，这个我一直特别想去体验的国家。现在回想起来，当时也真是人品爆发，在办美国商务签证的时候很顺利地就通过了（可怜我的另两位同事，他们虽然都准备得非常充分，但后来去办签证的时候都进了审核）；另外，当时自己因为疏忽，忘了<code>eVUS</code>这么一个东西，结果去登机时才被告知必须要提前完成<code>eVUS</code>的登记审核，搞得我一脸懵逼，所幸当时立即提交申请后居然很快就审批通过了，不然差点就真错过了。</p>
<p>当时到纽约完成了新品发布会的工作后，考虑到机会难得，我也申请了两天的假期，在纽约市区（主要就是曼哈顿区）转了下，因为时间有限，去的也都是闻名已久的地标，例如时代广场、世贸中心、帝国大厦、中央公园、自然历史博物馆等，以及远距离看了下自由女神像的侧面。对于纽约，印象是极其深刻的，如果让我用一个词来概括，那就是“大城市”，虽然在国内去的地方也不少，意大利法国的首都也去旅游过，但到纽约后真的有种进城了的感觉。当时在返程的飞机上趁着兴奋劲，还写了篇记录文章，《纽约出差之城市印象》，写了近两千字还没有收尾，结果后来拖延证一犯就一直没发出来。除了逛纽约，当时也跟多年未见的同学聚了下。一个是高中同学，在纽约大学任教，在他的带领下我也逛了下纽约大学，可惜当时天气不是特别好，没能见到草地上满是穿着比基尼晒太阳的妹子，甚是遗憾。另一个是大学室友，本来是在波士顿工作的，结果也带着媳妇儿（同是大学校友）开车五六个小时到纽约聚了下。哦对，我们聚会都是吃的中餐厅。在异国他乡与多年未见的同学相聚，叙叙旧聊聊人生，感觉还是蛮不错的。</p>
<p>今年除了到美国纽约，我还到了其它几个国家地区。还是纽约出差那次，因为国内直达的航班机票价格太高，所以我选择了中转的方式；当时就从香港机场乘机，先飞到了韩国的首尔机场，然后再转机到纽约的肯尼迪机场。当时在韩国首尔机场停歇了四五个小时，虽然没有出机场，但是在机场里面逛的地方也挺多的，除了尝下韩国本土特色小吃外，还碰到了换班的空姐，一大波韩国空姐陆陆续续从眼前走过，场景甚是壮观。除了那次出差，在年初春节的时候，跟媳妇儿和朋友媳妇一起到意大利、法国旅行度蜜月，大概12天的自由行，游玩的城市有罗马、梵蒂冈、佛罗伦萨、米兰和巴黎。当时也是第一次出国，新鲜感蛮大的，还写了一篇游记，<a href="http://debugtalk.com/post/my-impression-on-italy-and-france/">《春节旅行之意法印象》</a>。</p>
<p>再说回技术方面。今年做了一个自己还算比较满意的开源项目，<a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="external"><code>HttpRunner</code></a>（起初叫做<code>ApiTestEngine</code>），核心特色就是基于现有成熟的Python开源项目<a href="https://github.com/requests/requests" target="_blank" rel="external"><code>requests</code></a>和<a href="https://github.com/locustio/locust" target="_blank" rel="external"><code>Locust</code></a>，打造了一套<code>HTTP</code>测试框架，可以实现只需采用<code>YAML/JSON</code>格式维护一套脚本，就可同时实现自动化测试和性能测试。回顾今年的技术博客，有16篇文章都是围绕<code>HttpRunner</code>写的，<a href="http://debugtalk.com/tags/HttpRunner/">《HttpRunner 开发博客》</a>，可见自己在这上面投入的精力还是非常大的。值得欣慰的是，该框架产生的收效还不错，除了在大疆内部的多个项目中投入了使用，当前已知的有好几个其它公司的测试同学也都在使用这个框架。也源于开源，我在开发该框架的时候收到了非常多的反馈和建议，这对<code>HttpRunner</code>的持续优化迭代产生了非常巨大的帮助。从情感上讲，<code>HttpRunner</code>就如同自己的亲骨肉，里面融入了我自身非常多的对测试的思考，后续我也将继续不断优化<code>HttpRunner</code>，期望它能有朝一日在测试届大放异彩。</p>
<p>今年，我也在公司内外做过一些分享。一个是六月份的时候，当时公司新进了一批实习生，当时分配给我的任务是对我们质量部的岗位进行介绍，给实习生们讲解下我们测试工程师的工作日常情况。由于面向的都是新人，而且各种岗位的都有，因此也只能是科普介绍了。讲完后，我又整理下内容写了篇博客文章，<a href="http://debugtalk.com/post/introduction-to-testing-engineer-daily-work/">《【科普】互联网测试岗位的工作日常》</a>，阅读量居然还挺高。另一次分享是大疆与TesterHome合办的<a href="https://testerhome.com/topics/9755" target="_blank" rel="external">测试沙龙</a>，我作为其中一位分享者，演讲的主题也是围绕着<code>HttpRunner</code>，题目是《低成本实现系统接口测试 – 自动化、性能、持续集成&amp;线上监控》，从现场互动上来看，还是挺不错的。沙龙活动之后，<code>TOP100</code>的某位主编联系到我，希望我能在2017年第6届全球软件案例研究峰会上做了分享，当时想着也是个锻炼的机会，也就提交了案例，并且入了<a href="http://www.top100summit.com/think/12686" target="_blank" rel="external">榜单</a>；不过后来主办方的做法有些让人呵呵，在此我也不想多提了，总之最后我没去现场（虽然赠送给我一张全程票），后续应该也不会考虑与他们合作了。关于分享这块儿，比较遗憾的是错过了<code>TesterHome</code>的测试开发大会，五月份的时候思寒问我topic的时候，当时忙于公司的新品发布会没时间准备，就此错过了与诸多大佬见面的机会，只能看2018年是否还有机会了。</p>
<p>今年另一件比较有意思的事情，签订了一份图书出版合同。六月份的时候，电子工业出版社博文视点的一位编辑跟我联系，说看到我博客上的文章还不错，问我是否有兴趣出版图书。当时我既惊讶又惊喜，因为写书这事儿我之前从来没敢想过，所以一时心里也没底儿。好在陈编也给了我很多肯定和鼓励，同时我也想挑战一下自己，最后就答应了出版的事儿，并最终与博文视点签订了合同，书名暂定为《互联网系统测试精要：自动化、性能、持续集成》。合同签订后，我开始后悔自己太过乐观了，写书比我想象中难得多。因为写书只能是业余时间，有时工作太忙就完全顾不上了，等过一段时间再想提笔的时候发现手感灵感全没了。是的，别说是写书了，就是写博客，隔段时间不写再想捡起来也是异常痛苦。有过这段经历，我对书籍更多了一分敬畏，先不说书的内容质量，光是作者坚持下去的这份毅力，也是难能可贵的。还好出版社也没有给我压力，在这个过程中也给了我不少鼓励。当时签约的交稿日期是2017年12月中旬，但实际完成率嘛，嗯，希望我能在2018年尽早完成吧。</p>
<p>再说点生活上的事儿吧。今年我买了人生中的第一辆车，从此也算是有房有车了，虽然房子远在广州山区，车也不是啥好车。在买车之前，我基本对车完全不懂，可能除了奔驰宝马奥迪的车标能认出来外，其它一概不知。当时要去4S店看车之前，担心被销售看出啥也不懂的尴尬，还在汽车之家上好生科普了一番，总算对汽车有了点了解。然后就是一番小纠结，先是犹豫买SUV还是轿车，听闻20万以下的城市SUV也就那样后就决定买轿车；然后考虑轿车买A级还是B级，想到近几年也不会换车，还是一次性买个宽敞点的吧，就决定买B级车；然后就在几个品牌的B级车里选了，丰田凯美瑞、本田雅阁、雪佛兰迈锐宝、马自达阿特兹、别克君威都有看过，最后被马自达的信仰洗脑了，再加上阿特兹的颜值，从而就选定了阿特兹这款车，而且选的是骚气的魂动红，应该比较符合我闷骚的气质吧。另外，由于深圳和广州的车牌都需要摇号，拍卖价格又太高，所以就选择了在老家上牌，幸运的是选中的车牌还比较满意，<code>DBG256</code>，跟我个人的职业也比较搭。在车技这块儿，虽然我的驾照满六年都换过一次证了，但这些年摸车的确比较少，当时为了找手感，还提前在58同城上约了一个陪驾服务，师傅是一位号称有18年驾龄的资深美女。所幸经过一段时间的熟悉，现在车技已经好多了，至少刚开始时那些停车就不小心剐蹭到旁边的奔驰、上高速就手心冒汗这些心理障碍已经差不多没了。</p>
<p>2017年，一不小心就写了这么多。最后的压轴戏，当然是我刚出生的小坚果宝宝啦。刚当上爸爸，咋说呢，心情有些复杂，既兴奋又紧张。虽然是足月，而且还晚了两天才出生，但当第一次看到小家伙的时候，还是会感觉有些惊慌失措，从此我便多了一层父亲的身份，需要肩负更多的责任。还记得多年前曾和一位领导兼前辈聊人生，他跟我说工作并不是生活的全部，下班回家逗逗儿子也是挺有意思的。当时我还不能完全理解，现在我终于有了切身的体会，看着孩子的喜怒哀乐，陪伴的孩子的成长，本身就是一件非常幸福的事情。而我自身，也需要做好爸爸的榜样，言传身教还是很重要的。对于宝宝的未来，我也并没有太多期待，健康快乐地成长就好了，过两年再大点的时候，顺便再把Python学会了，嗯，徒手反转二叉树啥的技能也得学下。</p>
<p>最后按照惯例，再展望下即将来临的2018年吧。</p>
<p>1、坚持写作。博客公众号文章的更新频率得提升下，平均每月3~5篇还是要保证的。另外就是尽快把签约的书稿结了，不然就算出版社不催，我也不好意思了。</p>
<p>2、在工作上有更多的成长和产出。新的一年就迈入而立之年了，离“中年危机”也更近了一分，焦虑是没用的，踏踏实实快速成长吧。</p>
<p>3、学会生活，锻炼身体，陪伴家人，工作是长跑，讲究的是可持续发展。去年的展望也写了这句，但做的并不好，希望2018年能有所改善。</p>
<p>4、再借用下习主席的新年寄语，逢山开路，遇水搭桥，不管有啥困难，终将可以克服的。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://debugtalk.com/post/my-2016-summary/">《我的2016年终总结》</a></li>
<li>《我的2015年终总结》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年已经结束了，为了给以后的自己留点回忆，还是写篇博客记录下吧。&lt;/p&gt;
&lt;p&gt;先从工作说起吧。这一年，我依然在大疆的互联网事业部做测试开发岗位。有点变化的是，年初是自己一个人做，然后逐步有新的伙伴加入，成立了测试开发小组，并担任了小组负责人。简单地说，就是除了纯技术
    
    </summary>
    
    
      <category term="年终总结" scheme="http://debugtalk.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
      <category term="个人成长" scheme="http://debugtalk.com/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 的测试用例分层机制</title>
    <link href="http://debugtalk.com/post/HttpRunner-testcase-layer/"/>
    <id>http://debugtalk.com/post/HttpRunner-testcase-layer/</id>
    <published>2017-12-22T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在<code>HttpRunner</code>中，测试用例引擎最大的特色就是支持<code>YAML/JSON</code>格式的用例描述形式。</p>
<p>采用<code>YAML/JSON</code>格式编写维护测试用例，优势还是很明显的：</p>
<ul>
<li>相比于表格形式，具有更加强大的灵活性和更丰富的信息承载能力；</li>
<li>相比于代码形式，减少了不必要的编程语言语法重复，并最大化地统一了用例描述形式，提高了用例的可维护性。</li>
</ul>
<p>以最常见的登录注销为例，我们的测试用例通常会描述为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> demo-login-logoff</div><div class="line"><span class="attr">    variable_binds:</span></div><div class="line"><span class="attr">        - UserName:</span> test001</div><div class="line"><span class="attr">        - Password:</span> <span class="number">123456</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://xxx.debugtalk.com</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Accept:</span> application/json</div><div class="line"><span class="attr">            User-Agent:</span> iOS/<span class="number">10.3</span></div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Login</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/Login</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            UserName:</span> $UserName</div><div class="line"><span class="attr">            Pwd:</span> $Password</div><div class="line"><span class="attr">            VerCode:</span> <span class="string">""</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Logoff</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/LoginOff</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div></pre></td></tr></table></figure>
<p>相信大家已经对该种用例描述形式十分熟悉了。不过，该种描述形式的问题在于，接口通常会出现在多个测试场景中，而每次都需要对接口进行定义描述，包括请求的URL、Header、Body、以及预期响应值等，这就会产生大量的重复。</p>
<p>例如，在某个项目中存在三个测试场景：</p>
<ul>
<li>场景A：注册新账号（<code>API_1/2</code>）、登录新注册的账号（<code>API_3/4/5</code>）、查看登录状态（<code>API_6</code>）；</li>
<li>场景B：登录已有账号（<code>API_3/4/5</code>）、注销登录（<code>API_7/8</code>）；</li>
<li>场景C：注销登录（<code>API_7/8</code>）、查看登录状态（<code>API_6</code>）、注册新账号（<code>API_1/2</code>）。</li>
</ul>
<p>按照常规的接口测试用例编写方式，我们需要创建3个场景文件，然后在各个文件中分别描述三个测试场景相关的接口信息。示意图如下所示。</p>
<p><img src="/images/httprunner-testcase-layer-1.jpeg" alt=""></p>
<p>在本例中，接口（<code>API_1/2/6</code>）在场景A和场景C中都进行了定义；接口（<code>API_3/4/5</code>）在场景A和场景B中都进行了定义；接口（<code>API_7/8</code>）在场景B和场景C中都进行了定义。可以预见，当测试场景增多以后，接口定义描述的维护就会变得非常困难和繁琐。</p>
<h2 id="接口的分层定义描述"><a href="#接口的分层定义描述" class="headerlink" title="接口的分层定义描述"></a>接口的分层定义描述</h2><p>那要如何进行优化呢？</p>
<p>其实也很简单，在编程语言中，如果出现重复代码块，我们通常会将其封装为类或方法，然后在需要时进行调用，以此来消除重复。同样地，我们也可以将项目的API进行统一定义，里面包含API的请求和预期响应描述，然后在测试场景中进行引用即可。</p>
<p>示意图如下所示。</p>
<p><img src="/images/httprunner-testcase-layer-2.jpeg" alt=""></p>
<p>具体地，我们可以约定将项目的所有API接口定义放置在<code>api</code>目录下，并在<code>api</code>目录中按照项目的系统模块来组织接口的定义；同时，将测试场景放置到<code>testcases</code>目录中。</p>
<p>此时测试用例文件的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">✗ tree tests</div><div class="line">tests</div><div class="line">├── api</div><div class="line">│   └── v1</div><div class="line">│       ├── Account.yml</div><div class="line">│       ├── BusinessTrip.yml</div><div class="line">│       ├── Common.yml</div><div class="line">│       └── Leave.yml</div><div class="line">├── debugtalk.py</div><div class="line">└── testcases</div><div class="line">    ├── scenario_A.yml</div><div class="line">    ├── scenario_B.yml</div><div class="line">    └── scenario_C.yml</div></pre></td></tr></table></figure>
<p>而对于API接口的定义，与之前的描述方式基本一致，只做了两点调整：</p>
<ul>
<li>接口定义块（<code>block</code>）的标识为<code>api</code>；</li>
<li>接口定义块中包含<code>def</code>字段，形式为<code>api_name(*args)</code>，作为接口的唯一标识ID；需要注意的是，即使<code>api</code>没有参数，也需要带上括号，<code>api_name()</code>；这和编程语言中定义函数是一样的。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- api:</span></div><div class="line"><span class="attr">    def:</span> api_v1_Account_Login_POST($UserName, $Password)</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/Login</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            UserName:</span> $UserName</div><div class="line"><span class="attr">            Pwd:</span> $Password</div><div class="line"><span class="attr">            VerCode:</span> <span class="string">""</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div><div class="line"></div><div class="line"><span class="attr">- api:</span></div><div class="line"><span class="attr">    def:</span> api_v1_Account_LoginOff_GET()</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/LoginOff</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div></pre></td></tr></table></figure>
<p>有了接口的定义描述后，我们编写测试场景时就可以直接引用接口定义了。</p>
<p>同样是背景描述中的登录注销场景，测试用例就描述为变为如下形式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> demo</div><div class="line"><span class="attr">    variable_binds:</span></div><div class="line"><span class="attr">        - UserName:</span> test001</div><div class="line"><span class="attr">        - Password:</span> <span class="number">123456</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://xxx.debugtalk.com</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Accept:</span> application/json</div><div class="line"><span class="attr">            User-Agent:</span> iOS/<span class="number">10.3</span></div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Login</div><div class="line"><span class="attr">    api:</span> api_v1_Account_Login_POST($UserName, $Password)</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Logoff</div><div class="line"><span class="attr">    api:</span> api_v1_Account_LoginOff_GET()</div></pre></td></tr></table></figure>
<p>不难看出，对API接口进行分层定义后，我们在测试用例场景中引用接口定义时，与编程语言里面调用函数的形式基本完全一样，只需要指定接口的名称，以及所需传递的参数值；同样的，即使没有参数，也需要带上括号。</p>
<p>实现接口的分层定义描述后，我们就可以避免接口的重复定义。但是，我们回过头来看之前的案例，发现仍然会存在一定的重复。</p>
<p><img src="/images/httprunner-testcase-layer-3.jpeg" alt=""></p>
<p>如上图所示，场景A和场景C都包含了注册新账号（<code>API_1/2</code>）和查看登录状态（<code>API_6</code>），场景A和场景B都包含了登录已有账号（<code>API_3/4/5</code>），场景B和场景C都包含了注销登录（<code>API_7/8</code>）。</p>
<p>虽然我们已经将接口的定义描述抽离出来，避免了重复的定义；但是在实际业务场景中，某些功能（例如登录、注销）会在多个场景中重复出现，而该功能又涉及到多个接口的组合调用，这同样也会出现大量的重复。</p>
<h2 id="接口的模块化封装"><a href="#接口的模块化封装" class="headerlink" title="接口的模块化封装"></a>接口的模块化封装</h2><p>玩过积木的同学可能就会想到，我们也可以将系统的常用功能封装为模块（suite），只需要在模块中定义一次，然后就可以在测试场景中重复进行引用，从而避免了模块功能的重复描述。</p>
<p><img src="/images/httprunner-testcase-layer-4.jpeg" alt=""></p>
<p>具体地，我们可以约定将项目的所有模块定义放置在<code>suite</code>目录下，并在<code>suite</code>目录中按照项目的功能来组织模块的定义。</p>
<p>后续，我们在<code>testcases</code>目录中描述测试场景时，就可同时引用接口定义和模块定义了；模块和接口的混合调用，必将为我们编写测试场景带来极大的灵活性。</p>
<p>此时测试用例文件的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">✗ tree tests</div><div class="line">tests</div><div class="line">├── api</div><div class="line">│   └── v1</div><div class="line">│       ├── Account.yml</div><div class="line">│       ├── BusinessTrip.yml</div><div class="line">│       ├── Common.yml</div><div class="line">│       └── Leave.yml</div><div class="line">├── debugtalk.py</div><div class="line">├── suite</div><div class="line">│   ├── BusinessTravelApplication</div><div class="line">│   │   ├── approve-application.yml</div><div class="line">│   │   ├── executive-application.yml</div><div class="line">│   │   ├── reject-application.yml</div><div class="line">│   │   └── submit-application.yml</div><div class="line">│   └── LeaveApplication</div><div class="line">│       ├── approve.yml</div><div class="line">│       ├── cancel.yml</div><div class="line">│       └── submit-application.yml</div><div class="line">└── testcases</div><div class="line">    ├── scenario_A.yml</div><div class="line">    ├── scenario_B.yml</div><div class="line">    └── scenario_C.yml</div></pre></td></tr></table></figure>
<p>需要注意的是，我们在组织测试用例描述的文件目录结构时，遵循约定大于配置的原则：</p>
<ul>
<li>API接口定义必须放置在<code>api</code>目录下</li>
<li>模块定义必须放置在<code>suite</code>目录下</li>
<li>测试场景文件必须放置在<code>testcases</code>目录下</li>
<li>相关的函数定义放置在<code>debugtalk.py</code>中</li>
</ul>
<p>至此，我们实现了测试用例的<code>接口-模块-场景</code>分层，从而彻底避免了重复定义描述。</p>
<h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><p>得益于约定大于配置的原则，在<code>HttpRunner</code>中实现了一个脚手架工具，可以快速创建项目的目录结构。该想法来源于<code>Django</code>的<code>django-admin.py startproject project_name</code>。</p>
<p>使用方式也与<code>Django</code>类似，只需要通过<code>--startproject</code>指定新项目的名称即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ hrun --startproject helloworld</div><div class="line">INFO:root: Start to create new project: /Users/Leo/MyProjects/helloworld</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/api</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/suite</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/testcases</div><div class="line">INFO:root:      created file: /Users/Leo/MyProjects/helloworld/tests/debugtalk.py</div></pre></td></tr></table></figure>
<p>运行之后，就会在指定的目录中生成新项目的目录结构，接下来，我们就可以按照测试用例的<code>接口-模块-场景</code>分层原则往里面添加用例描述信息了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果看到这里你还不明白测试用例分层的必要性，那也没关系，测试用例分层不是必须的，你还是可以按照之前的方式组织测试用例。不过当你某一天发现需要进行分层管理时，你会发现它就在那里，很实用。</p>
<p>最后，在<code>HttpRunner</code>项目的<a href="https://github.com/HttpRunner/HttpRunner/tree/master/examples/HelloWorld" target="_blank" rel="external"><code>examples/HelloWorld</code></a>目录中，包含了一份完整的分层测试用例示例，相信会对大家有所帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;HttpRunner&lt;/code&gt;中，测试用例引擎最大的特色就是支持&lt;code&gt;YAML/JSON&lt;/code
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="testcase" scheme="http://debugtalk.com/tags/testcase/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 的结果校验器优化</title>
    <link href="http://debugtalk.com/post/HttpRunner-validator-optimization/"/>
    <id>http://debugtalk.com/post/HttpRunner-validator-optimization/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在测试用例中，包含预期结果这么一项，用于辅助测试人员执行测试用例时判断系统的功能是否正常。而在自动化测试中，我们的目标是让测试用例自动执行，因此自动化测试用例中同样需要包含预期结果一项，只不过系统响应结果不再由人工来进行判断，而是交由测试工具或框架来实现。</p>
<p>这部分功能对应的就是测试结果校验器（validator），基本上能称得上自动化测试工具或框架的都包含该功能特性。</p>
<h2 id="设计之初"><a href="#设计之初" class="headerlink" title="设计之初"></a>设计之初</h2><p><code>HttpRunner</code>在设计之初，结果校验器（validator）的实现比较简单。</p>
<p>对于每一个<code>test</code>，可以指定0个或多个校验项，放置在<code>validate</code>中。在自动化测试执行的时候，会在发起HTTP请求、解析结果响应之后，逐个检查各个校验项，若存在任意校验项不通过的情况，则该<code>test</code>将终止并被标记为失败。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expect"</span>: <span class="number">16</span>&#125;</div></pre></td></tr></table></figure>
<p>如上例所示，每一个校验项均为一个<code>json</code>结构，里面包含<code>check</code>、<code>expect</code>、<code>comparator</code>三个属性字段。其中，<code>check</code>对应着要检查的字段，<code>expect</code>对应着检查字段预期的值，这两项是必须指定的；<code>comparator</code>字段对应着比较方法，若不指定，则默认采用<code>eq</code>，即检查字段与预期值相等。</p>
<p>为了实现尽可能强大的检查功能，<code>check</code>属性值可通过链式操作精确指定具体的字段，<code>comparator</code>也内置实现了大量的检查功能。</p>
<p>举个例子可能会更清晰些。假如某结构的响应结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// status code: 200</div><div class="line"></div><div class="line">// response headers</div><div class="line">&#123;</div><div class="line">   "Content-Type": "application/json"</div><div class="line">&#125;</div><div class="line"></div><div class="line">// response body content</div><div class="line">&#123;</div><div class="line">   "success": False,</div><div class="line">   "person": &#123;</div><div class="line">       "name": &#123;</div><div class="line">           "first_name": "Leo",</div><div class="line">           "last_name": "Lee",</div><div class="line">       &#125;,</div><div class="line">       "age": 29,</div><div class="line">       "cities": ["Guangzhou", "Shenzhen"]</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么假如我们要检查<code>status code</code>，<code>check</code>就可以指定为<code>status_code</code>；假如要检查<code>response headers</code>中的<code>Content-Type</code>，<code>check</code>就可以指定为<code>headers.content-type</code>；假如要检查<code>response body</code>中的<code>first_name</code>，<code>check</code>就可以指定为<code>content.person.name.first_name</code>。可以看出，假如下一层级为字典结构，那么就可以通过<code>.</code>运算符指定下一层级的<code>key</code>，依次类推。</p>
<p>对于字段内容为列表<code>list</code>的情况略有不同，我们需要通过序号来指定具体检查哪一项内容。例如，<code>Guangzhou</code>对应的检查项为<code>content.person.cities.0</code>，<code>Shenzhen</code>对应的检查项为<code>content.person.cities.1</code>。</p>
<p>在比较方式（<code>comparator</code>）方面，<code>HttpRunner</code>除了<code>eq</code>，还内置了大量的检查方法。例如，我们可以通过<code>gt</code>、<code>ge</code>、<code>lt</code>、<code>le</code>等比较数值大小，通过<code>len_eq</code>、<code>len_gt</code>、<code>len_lt</code>等比较长度是否相等（列表、字典、字符串均适用），通过<code>contains</code>、<code>contained_by</code>来判断包含关系，通过<code>startswith</code>、<code>endswith</code>判断字符串的开头结尾，甚至通过<code>regex_match</code>来判断是否满足正则匹配等。详细的比较方式还有许多，需要时可查看<a href="http://httprunner.readthedocs.io/en/latest/write-testcases.html#comparator" target="_blank" rel="external">comparator</a>表格。</p>
<h2 id="存在的局限性"><a href="#存在的局限性" class="headerlink" title="存在的局限性"></a>存在的局限性</h2><p>在大多数情况下，<code>HttpRunner</code>的结果校验器（validator）是够用的。不过问题在于，框架不可能为用户实现所有的检查方法，假如用户需要某些特殊的检查方法时，<code>HttpRunner</code>就没法实现了。</p>
<p>这的确是一个问题，之前<code>Junho2010</code>提的issue <a href="https://github.com/HttpRunner/HttpRunner/issues/29" target="_blank" rel="external">#29</a>中举了一个例子，应该也算是比较有代表性。</p>
<blockquote>
<p>发送请求时的数据使用了随机生成，然后需要比较结果中的数据是否是和这个相关（通过某个算法转换）。比如我输入的是321，我的结果是<code>(3+2+1) * avg(3+2+1)</code>这种转化，目前的comparator是比较难于实现的。</p>
</blockquote>
<p>要解决这个问题，最好的方式应该是在<code>HttpRunner</code>中实现自定义结果校验器的机制；用户在有需要的时候，可以自己编写校验函数，然后在<code>validate</code>中引用校验函数。之前也介绍过<code>HttpRunner</code>的热加载机制，<a href="http://debugtalk.com/post/apitestengine-hot-plugin/">《约定大于配置：ApiTestEngine实现热加载机制》</a>，自定义结果校验器应该也是可以采用这种方式来实现的。</p>
<p>第二个需要优化的点，<code>HttpRunner</code>的结果校验器还不支持变量引用，会造成某些场景下的局限性。例如，<code>testwangchao</code>曾提过一个issue <a href="https://github.com/HttpRunner/HttpRunner/issues/52" target="_blank" rel="external">#52</a>：</p>
<blockquote>
<p>接口response内，会返回数据库内的自增ID。ID校验的时候，希望<code>expected</code>为参数化的值。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">validate:</span></div><div class="line"><span class="bullet">    -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.data.table_list.0.id"</span>, <span class="string">"expected"</span>: <span class="string">"$id"</span>&#125;</div></pre></td></tr></table></figure>
<p>另外，在<a href="http://debugtalk.com/post/apitestengine-not-only-about-json-api/">《ApiTestEngine，不再局限于API的测试》</a>一文中有介绍过，结果提取器（<code>extract</code>）新增实现了通过正则表达式对任意文本响应内容的字段提取。考虑到结果校验器（<code>validate</code>）也需要先从结果响应中提取出特定字段才能与预期值进行比较，在具体实现上完全可以复用同一部分代码，因此在<code>validate</code>的<code>check</code>部分也可以进行统一化处理。</p>
<p>经过前面的局限性问题描述，我们的改造目标也明确了，主要有三个方面：</p>
<ul>
<li>新增支持自定义结果校验器</li>
<li>结果校验器中实现变量引用</li>
<li>结果校验内容新增支持正则表达式提取</li>
</ul>
<h2 id="改造结果"><a href="#改造结果" class="headerlink" title="改造结果"></a>改造结果</h2><p>具体的改造过程就不写了，有兴趣的同学可以直接阅读源码，重点查看<a href="https://github.com/HttpRunner/HttpRunner/blob/master/httprunner/context.py" target="_blank" rel="external"><code>httprunner/context.py</code></a>中的<code>parse_validator</code>、<code>do_validation</code>和<code>validate</code>三个函数。</p>
<p>经过优化后，改造目标中的三项功能都实现了。为了更好地展现改造后的结果校验器，此处将结合实例进行演示。</p>
<h3 id="新增支持自定义结果校验器"><a href="#新增支持自定义结果校验器" class="headerlink" title="新增支持自定义结果校验器"></a>新增支持自定义结果校验器</h3><p>先来看第一个优化项，新增支持自定义结果校验器。</p>
<p>假设我们需要使用HTTP响应状态码各个数字的和来进行校验，例如，<code>201</code>状态码对应的数字和为3，<code>503</code>状态码对应的数字和为8。该实例只是为了演示用，实际上并不会用到这样的校验方式。</p>
<p>首先，该种校验方式在<code>HttpRunner</code>中并没有内置，因此需要我们自己来实现。实现方式与热加载机制相同，只需要将自定义的校验函数放置到当前<code>YAML/JSON</code>文件同级或者父级目录的<code>debugtalk.py</code>中。</p>
<p>对于自定义的校验函数，需要遵循三个规则：</p>
<ul>
<li>自定义校验函数需放置到<code>debugtalk.py</code>中</li>
<li>参数有两个：第一个为原始数据，第二个为原始数据经过运算后得到的预期结果值</li>
<li>在校验函数中通过<code>assert</code>将实际运算结果与预期结果值进行比较</li>
</ul>
<p>对于前面提到的演示案例，我们就可以在<code>debugtalk.py</code>中编写如下校验函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_status_code</span><span class="params">(status_code, expect_sum)</span>:</span></div><div class="line">    <span class="string">""" sum status code digits</span></div><div class="line">        e.g. 400 =&gt; 4, 201 =&gt; 3</div><div class="line">    """</div><div class="line">    sum_value = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> str(status_code):</div><div class="line">        sum_value += int(digit)</div><div class="line"></div><div class="line">    <span class="keyword">assert</span> sum_value == expect_sum</div></pre></td></tr></table></figure>
<p>然后，在<code>YAML/JSON</code>格式测试用例的<code>validate</code>中，我们就可以将校验函数名称<code>sum_status_code</code>作为<code>comparator</code>进行使用了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"sum_status_code"</span>, <span class="string">"expect"</span>: <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>由此可见，自定义的校验函数<code>sum_status_code</code>与<code>HttpRunner</code>内置的校验方法<code>eq</code>在使用方式上完全相同，应该没有理解上的难度。</p>
<h3 id="结果校验器中实现变量引用"><a href="#结果校验器中实现变量引用" class="headerlink" title="结果校验器中实现变量引用"></a>结果校验器中实现变量引用</h3><p>对于第二个优化项，结果校验器中实现变量引用。在使用方式上我们应该与<code>request</code>中的变量引用一致，即通过<code>$var</code>的方式来引用变量<code>var</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - expect_status_code:</span> <span class="number">200</span></div><div class="line"><span class="attr">        - token_len:</span> <span class="number">16</span></div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="string">"$expect_status_code"</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expect"</span>: <span class="string">"$token_len"</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"$token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expect"</span>: <span class="string">"$token_len"</span>&#125;</div></pre></td></tr></table></figure>
<p>通过以上示例可以看出，在结果校验器<code>validate</code>中，<code>check</code>和<code>expect</code>均可实现实现变量的引用；而引用的变量，可以来自四种类型：</p>
<ul>
<li>当前<code>test</code>中定义的<code>variables</code>，例如<code>expect_status_code</code></li>
<li>当前<code>test</code>中提取（<code>extract</code>）的结果变量，例如<code>token</code></li>
<li>当前测试用例集<code>testset</code>中，先前<code>test</code>中提取（<code>extract</code>）的结果变量</li>
<li>当前测试用例集<code>testset</code>中，全局配置<code>config</code>中定义的变量</li>
</ul>
<p>而<code>check</code>字段除了可以引用变量，以及保留了之前的链式操作定位字段（例如上例中的<code>content.token</code>）外，还新增了采用正则表达式提取内容的方式，也就是第三个优化项。</p>
<h3 id="结果校验内容新增支持正则表达式提取"><a href="#结果校验内容新增支持正则表达式提取" class="headerlink" title="结果校验内容新增支持正则表达式提取"></a>结果校验内容新增支持正则表达式提取</h3><p>假设如下接口的响应结果内容为<code>LB123abcRB789</code>，那么要提取出<code>abc</code>部分进行校验，就可以采用如下描述方式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"LB123(.*)RB789"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="string">"abc"</span>&#125;</div></pre></td></tr></table></figure>
<p>可见在使用方式上与在结果提取器（<code>extract</code>）中完全相同。</p>
<h3 id="结果校验器的进一步简化"><a href="#结果校验器的进一步简化" class="headerlink" title="结果校验器的进一步简化"></a>结果校验器的进一步简化</h3><p>最后，为了进一步简化结果校验的描述，我在<code>validate</code>中新增实现了一种描述方式。</p>
<p>简化后的描述方式与原始方式对比如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">validate:</span></div><div class="line"><span class="attr">    - comparator_name:</span> [check_item, expect_value]</div><div class="line"><span class="bullet">    -</span> &#123;<span class="string">"check"</span>: check_item, <span class="string">"comparator"</span>: comparator_name, <span class="string">"expect"</span>: expect_value&#125;</div></pre></td></tr></table></figure>
<p>同样是前面的例子，采用新的描述方式后会更加简洁。而两种方式表达的含义是完全等价的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, $expect_status_code]</div><div class="line"><span class="attr">        - sum_status_code:</span> [<span class="string">"status_code"</span>, <span class="number">2</span>]</div><div class="line"><span class="attr">        - len_eq:</span> [<span class="string">"$token"</span>, $token_len]</div><div class="line"><span class="attr">        - len_eq:</span> [<span class="string">"content.token"</span>, <span class="number">16</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"LB123(.*)RB789"</span>, <span class="string">"abc"</span>]</div></pre></td></tr></table></figure>
<p>当然，此次优化保证了与历史版本的兼容，之前编写的测试用例脚本的运行是完全不会受到任何影响的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在测试用例中，包含预期结果这么一项，用于辅助测试人员执行测试用例时判断系统的功能是否正常。而在自动化测试中，我们的目标是让测试用例自动执行，因此自动化测试用例中同样需要包含预期结果一项，只不过系统响应结果不再由人工来进行判断，而是交由测试工具或框架来实现。&lt;/p&gt;
&lt;p&gt;这
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="validator" scheme="http://debugtalk.com/tags/validator/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 支持 HAR 意味着什么？</title>
    <link href="http://debugtalk.com/post/HttpRunner-supports-HAR/"/>
    <id>http://debugtalk.com/post/HttpRunner-supports-HAR/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-12-13T15:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HttpRunner</code>开始支持<code>HAR</code>啦！！！</p>
<p>如果你还没有体会到这三个感叹号的含义，那们你可能对<code>HAR</code>还不了解。</p>
<h2 id="HAR-是什么？"><a href="#HAR-是什么？" class="headerlink" title="HAR 是什么？"></a>HAR 是什么？</h2><p><code>HAR</code>的全称为<code>HTTP Archive</code>，是<a href="https://www.w3.org/" target="_blank" rel="external"><code>W3C(World Wide Web Consortium)</code></a>发布的一个通用标准。简单地说，<code>HAR</code>是一个约定的<code>JSON</code>文件格式，用于记录<code>HTTP</code>请求交互的所有内容，包括请求响应的详细记录和性能度量数据。</p>
<p>虽然当前<code>HAR</code>标准还处于<code>Draft</code>状态，但它已经被业界广泛地采用了，许多我们日常使用的工具都已支持<code>HAR</code>。在下面罗列的工具中，相信大家都已经比较熟悉了。</p>
<ul>
<li>Fiddler</li>
<li>Charles Web Proxy</li>
<li>Google Chrome</li>
<li>Firebug</li>
<li>HttpWatch</li>
<li>Firefox</li>
<li>Internet Explorer 9</li>
<li>Microsoft Edge</li>
<li>Paw</li>
<li>Restlet Client</li>
</ul>
<p>可以看出，工具覆盖了主流的抓包工具、浏览器和接口测试工具。这些工具都支持<code>HAR</code>标准，可以将录制得到的数据包导出为<code>.har</code>的文件。</p>
<p>假如我们可以将<code>HAR</code>格式转换为<code>HttpRunner</code>的自动化测试用例，这就相当于<code>HttpRunner</code>可以和非常多的工具结合使用，并获得了接口录制和用例生成功能，灵活性和易用性都将得到极大的提升。</p>
<p>那么，将<code>HAR</code>格式转换为<code>HttpRunner</code>的自动化测试用例是否可行呢？</p>
<p>我们不妨先研究下<code>HAR</code>的格式。</p>
<h2 id="HAR-格式详解"><a href="#HAR-格式详解" class="headerlink" title="HAR 格式详解"></a>HAR 格式详解</h2><p>通过如上列出的任意一款工具，都可以将录制得到的数据包导出为<code>.har</code>的文件。我们采用文本编辑器打开<code>.har</code>文件后，会发现是一个<code>JSON</code>的数据结构。</p>
<p>默认情况下，<code>.har</code>文件的<code>JSON</code>数据结构是经过压缩的，直接看可能不够直观。推荐大家可以在文本编辑器中安装<code>Prettify JSON</code>的插件，然后就可以将压缩后的<code>JSON</code>数据一键转换为美观的格式。</p>
<p>更好的方式是，我们可以直接查看<code>W3C</code>编写的<a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HAR/Overview.html" target="_blank" rel="external"><code>HAR</code>格式标准</a>。</p>
<p>通过文档可知，<code>HAR</code>是只有一个key的<code>JSON</code>数据结构，并且key值只能为<code>log</code>；而<code>log</code>的值也为一个<code>JSON</code>结构，里面的key包括：<code>version</code>、<code>creator</code>、<code>browser</code>、<code>pages</code>、<code>entries</code>、<code>comment</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"log"</span>: &#123;</div><div class="line">        <span class="attr">"version"</span>: <span class="string">""</span>,</div><div class="line">        <span class="attr">"creator"</span>: &#123;&#125;,</div><div class="line">        <span class="attr">"browser"</span>: &#123;&#125;,</div><div class="line">        <span class="attr">"pages"</span>: [],</div><div class="line">        <span class="attr">"entries"</span>: [],</div><div class="line">        <span class="attr">"comment"</span>: <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>version</code>、<code>creator</code>和<code>entries</code>是必有字段，不管是哪款工具导出的<code>.har</code>文件，肯定都会包含这三个字段。而我们在转换生成自动化测试用例时，只需获取HTTP请求和响应的内容，这些全都包含在<code>entries</code>里面，因此我们只需要关注<code>entries</code>的内容即可。</p>
<p><code>entries</code>字段对应的值为一个列表型数据结构，里面的值按照请求时间进行排序，罗列出各个HTTP请求的详细内容。具体地，HTTP请求记录的信息如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">"entries": [</div><div class="line">    &#123;</div><div class="line">        "pageref": "page_0",</div><div class="line">        "startedDateTime": "2009-04-16T12:07:23.596Z",</div><div class="line">        "time": 50,</div><div class="line">        "request": &#123;...&#125;,</div><div class="line">        "response": &#123;...&#125;,</div><div class="line">        "cache": &#123;...&#125;,</div><div class="line">        "timings": &#123;&#125;,</div><div class="line">        "serverIPAddress": "10.0.0.1",</div><div class="line">        "connection": "52492",</div><div class="line">        "comment": ""</div><div class="line">    &#125;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>由此可见，记录的HTTP信息非常全面，包含了HTTP请求交互过程中的所有内容。</p>
<p>而从生成自动化测试用例的角度来看，我们并不需要那么多信息，我们只需从中提取关键信息即可。</p>
<p>编写自动化测试用例，最关键的信息是要知道接口的请求URL、请求方法、请求headers、请求数据等，这些都包含在<code>request</code>字段对应的字典中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">"request": &#123;</div><div class="line">    "method": "GET",</div><div class="line">    "url": "http://www.example.com/path/?param=value",</div><div class="line">    "httpVersion": "HTTP/1.1",</div><div class="line">    "cookies": [],</div><div class="line">    "headers": [],</div><div class="line">    "queryString" : [],</div><div class="line">    "postData" : &#123;&#125;,</div><div class="line">    "headersSize" : 150,</div><div class="line">    "bodySize" : 0,</div><div class="line">    "comment" : ""</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据这些信息，我们就可以完成HTTP请求的构造。</p>
<p>当请求发送出去后，我们要想实现自动化地判断接口响应是否正确，我们还需要设置一些断言。而与HTTP响应相关的所有信息全都包含在<code>response</code>字段对应的字典中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">"response": &#123;</div><div class="line">    "status": 200,</div><div class="line">    "statusText": "OK",</div><div class="line">    "httpVersion": "HTTP/1.1",</div><div class="line">    "cookies": [],</div><div class="line">    "headers": [],</div><div class="line">    "content": &#123;&#125;,</div><div class="line">    "redirectURL": "",</div><div class="line">    "headersSize" : 160,</div><div class="line">    "bodySize" : 850,</div><div class="line">    "comment" : ""</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从通用性的角度考虑，我们会判断HTTP响应的状态码是否正确，这对应着<code>status</code>字段；如果我们还想在接口业务层面具有更多的判断，我们还会判断响应内容中的一些关键字段是否符合预期，这对应着<code>content</code>字段。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"content": &#123;</div><div class="line">    "size": 33,</div><div class="line">    "compression": 0,</div><div class="line">    "mimeType": "text/html; charset=utf-8",</div><div class="line">    "text": "\n",</div><div class="line">    "comment": ""</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>content</code>字段，可能会稍微复杂一些，因为接口响应内容的格式可能多种多样。</p>
<p>例如，响应内容可能<code>text/html</code>页面的形式，也可能是<code>application/json</code>的形式，具体类型可以查看<code>mimeType</code>得到，而具体的内容存储在<code>text</code>字段中。</p>
<p>另外，有时候响应数据还可能是经过编码的，用的最多的编码方式为<code>base64</code>。我们可以根据<code>encoding</code>字段获取得到具体的编码形式，然后采用对应的解码方式对<code>text</code>进行解码，最终获得原始的响应内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"content": &#123;</div><div class="line">    "size": 63,</div><div class="line">    "mimeType": "application/json; charset=utf-8",</div><div class="line">    "text": "eyJJc1N1Y2Nlc3MiOnRydWUsIkNvZGUiOjIwMCwiVmFsdWUiOnsiQmxuUmVzdWx0Ijp0cnVlfX0=",</div><div class="line">    "encoding": "base64"</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>以上面的<code>content</code>为例，我们通过<code>encoding</code>查看到编码形式为<code>base64</code>，并通过<code>text</code>字段获取到编码后的内容；那么我们就可以采用<code>base64</code>的解码函数，转换得到原始的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import base64</div><div class="line">&gt;&gt;&gt; base64.b64decode(text)</div><div class="line">b<span class="string">'&#123;"IsSuccess":true,"Code":200,"Value":&#123;"BlnResult":true&#125;&#125;'</span></div></pre></td></tr></table></figure>
<p>同时，我们根据<code>mimeType</code>可以得到响应内容<code>application/json</code>数据类型，那么就可以对其再进行<code>json.loads</code>操作，最终得到可供程序处理的<code>JSON</code>数据结构。</p>
<p>通过上述对<code>HAR</code>格式的详细介绍，可以看出<code>HAR</code>格式十分清晰，在对其充分了解的基础上，再编写测试用例转换工具就很简单了。</p>
<h2 id="har2case"><a href="#har2case" class="headerlink" title="har2case"></a>har2case</h2><p>编码过程没有太多值得说的，直接看最终成品吧。</p>
<p>最终产出的工具就是<a href="https://github.com/HttpRunner/har2case" target="_blank" rel="external"><code>har2case</code></a>，是一个命令行工具，可以直接将<code>.har</code>文件转换为<code>YAML</code>或<code>JSON</code>格式的自动化测试用例。</p>
<p>当前<code>har2case</code>已经上传到<code>PYPI</code>上了，通过<code>pip</code>或<code>easy_install</code>即可安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ pip install har2<span class="keyword">case</span></div><div class="line"><span class="comment"># or</span></div><div class="line">$ easy_install har2<span class="keyword">case</span></div></pre></td></tr></table></figure>
<p>使用方式很简单，只需在<code>har2case</code>命令后分别带上<code>HAR</code>源文件路径和目标生成的<code>YAML/JSON</code>路径即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ har2<span class="keyword">case</span> tests/data/demo.har demo.yml</div><div class="line">INFO:root:Generate YAML testset successfully: demo.yml</div><div class="line"></div><div class="line">$ har2<span class="keyword">case</span> tests/data/demo.har demo.json</div><div class="line">INFO:root:Generate JSON testset successfully: demo.json</div></pre></td></tr></table></figure>
<p>可以看出，具体是生成<code>YAML</code>还是<code>JSON</code>格式的问题，取决于指定目标文件的后缀：后缀为<code>.yml</code>或<code>.yaml</code>则生成<code>YAML</code>文件，后缀为<code>.json</code>则生成<code>JSON</code>文件。</p>
<p>如果不指定目标文件也行，则会默认生成<code>JSON</code>文件，文件名称和路径与<code>.har</code>源文件相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ har2<span class="keyword">case</span> tests/data/demo.har</div><div class="line">INFO:root:Generate JSON testset successfully: tests/data/demo.json</div></pre></td></tr></table></figure>
<p>具体的使用方式可以通过执行<code>har2case -h</code>查看。</p>
<p>在大多数情况下，生成的用例可直接在<code>HttpRunner</code>中使用，当然，是做接口自动化测试、接口性能测试，还是持续集成线上监控，这都取决于你。</p>
<p>不过，假如录制的场景中包含动态关联的情况，即后续接口请求参数依赖于前面接口的响应，并且每次调用接口时参数都会动态变化，那么就需要人工再对生成的脚本进行关联处理，甚至包括编写一些自定义函数等。</p>
<h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>读到这里，相信大家应该能体会到文章开头那三个感叹号的含义了，我也的确是带着难以言表的兴奋之情发布这个新功能的。</p>
<p>经过小范围的实际使用，效果很是不错，接口自动化测试用例的编写效率得到了极大的提升。而且，由于<code>HAR</code>本身的开放性，留给用户的选择非常多。</p>
<p>即便如此，我觉得<code>HttpRunner</code>的易用性还可以得到更大的提升。</p>
<p>当前，我规划了两项新特性将在近期完成：</p>
<ul>
<li>支持<code>PostMan</code>：将<code>Postman Collection Format</code>格式转换为<code>HttpRunner</code>支持的<code>YAML/JSON</code>测试用例；</li>
<li>支持<code>Swagger</code>：将<code>Swagger</code>定义的API转换为<code>HttpRunner</code>支持的<code>YAML/JSON</code>测试用例。</li>
</ul>
<p>等这两个新特性完成之后，相信<code>HttpRunner</code>会更上一个台阶。</p>
<p>如果你们有什么更好的想法，欢迎联系我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HttpRunner&lt;/code&gt;开始支持&lt;code&gt;HAR&lt;/code&gt;啦！！！&lt;/p&gt;
&lt;p&gt;如果你还没有体会到这三个感叹号的含义，那们你可能对&lt;code&gt;HAR&lt;/code&gt;还不了解。&lt;/p&gt;
&lt;h2 id=&quot;HAR-是什么？&quot;&gt;&lt;a href=&quot;#HAR
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="HAR" scheme="http://debugtalk.com/tags/HAR/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 正式更名为 HttpRunner</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-rename-to-HttpRunner/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-rename-to-HttpRunner/</id>
    <published>2017-11-07T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/apitestengine-not-only-about-json-api/">《ApiTestEngine，不再局限于API的测试》</a>一文的末尾，我提到随着<code>ApiTestEngine</code>的发展，它的实际功能特性和名字已经不大匹配，需要考虑改名了。</p>
<p>经过慎重考虑，最终决定将<code>ApiTestEngine</code>正式更名为<code>HttpRunner</code>。</p>
<h2 id="名字的由来"><a href="#名字的由来" class="headerlink" title="名字的由来"></a>名字的由来</h2><p>为什么选择<code>HttpRunner</code>这个名字呢？</p>
<p>在改名之前，我的想法很明确，就是要在新名字中体现该工具最核心的两个特点：</p>
<ul>
<li>该工具可实现任意基于HTTP协议接口的测试（自动化测试、持续集成、线上监控都是以此作为基础）</li>
<li>该工具可同时实现性能测试（这是区别于其它工具的最大卖点）</li>
</ul>
<p>围绕着这两点，我开始踏上了纠结的取名之路。</p>
<p>首先想到的，<code>ApiTestEngine</code>实现<code>HTTP</code>请求是依赖于<a href="http://python-requests.org" target="_blank" rel="external"><code>Python Requests</code></a>，实现性能测试是依赖于<a href="http://locust.io" target="_blank" rel="external"><code>Locust</code></a>，而<code>Locust</code>同样依赖于<code>Python Requests</code>。可以说，<code>ApiTestEngine</code>完全是构建在<code>Python Requests</code>之上的，后续无论怎么进化，这一层关系应该都不会变。</p>
<p>考虑到<code>Python Requests</code>的<code>slogan</code>是：</p>
<blockquote>
<p>Python HTTP Requests for Humans™</p>
</blockquote>
<p>因此，我想在<code>ApiTestEngine</code>的新名字中应该包含<code>HTTP</code>。</p>
<p>那如何体现性能测试呢？</p>
<p>想到的关键词就<code>load</code>、<code>perf</code>、<code>meter</code>这些（来源于LoadRunner，NeoLoad，JMeter），但又不能直接用，因为名字中带有这些词让人感觉就只是性能测试工具。而且，还要考虑跟<code>HTTP</code>这个词进行搭配。</p>
<p>最终，感觉<code>runner</code>这个词比较合适，一方面这来源于<code>LoadRunner</code>，大众的认可度可能会比较高；同时，这个词用在自动化测试和性能测试上都不会太牵强。</p>
<p>更重要的是，<code>HttpRunner</code>这个组合词当前还没有人用过，不管是<code>PyPI</code>还是<code>GitHub</code>，甚至域名都是可注册状态。</p>
<p>所以，就认定<code>HttpRunner</code>这个名字了。</p>
<h2 id="相关影响"><a href="#相关影响" class="headerlink" title="相关影响"></a>相关影响</h2><p><code>ApiTestEngine</code>更名为<code>HttpRunner</code>之后，会对用户产生哪些影响呢？</p>
<p>先说结论，没有任何不好的影响！</p>
<p>在链接访问方面，受益于GitHub仓库链接的自动重定向机制，仓库在改名或者过户（Transfer ownership）之后，访问原有链接会自动实现重定向，因此之前博客中的链接也都不会受到影响。</p>
<p>新的仓库地址：<a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="external">https://github.com/HttpRunner/HttpRunner</a></p>
<p>在使用的命令方面，<code>HttpRunner</code>采用<code>httprunner</code>作为新的命令代替原有的<code>ate</code>命令；当然，为了考虑兼容性，<code>HttpRunner</code>对<code>ate</code>命令也进行了保留，因此<code>httprunner</code>和<code>ate</code>命令同时可用，并完全等价。在性能测试方面，<code>locusts</code>命令保持不变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ httprunner -V</div><div class="line">HttpRunner version: 0.8.1b</div><div class="line">PyUnitReport version: 0.1.3b</div></pre></td></tr></table></figure>
<p>既然是全新的名字，新的篇章必然也得有一些新的东西。</p>
<p>为了方面用户安装，<code>HttpRunner</code>已托管至<a href="https://pypi.python.org/pypi/HttpRunner" target="_blank" rel="external"><code>PyPI</code></a>；后续大家可以方便的采用<code>pip</code>命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install HttpRunner</div></pre></td></tr></table></figure>
<p>同时，<code>HttpRunner</code>新增了大量使用说明文档（之前的博客主要都是开发过程记录），并托管到专业的<code>readthedocs</code>上面。在文档语言方面，英文优先，中文相对滞后。</p>
<p>访问网址：</p>
<ul>
<li>英文：<a href="http://httprunner.readthedocs.io/" target="_blank" rel="external">http://httprunner.readthedocs.io/</a></li>
<li>中文（滞后）：<a href="http://httprunner-cn.readthedocs.io/" target="_blank" rel="external">http://httprunner-cn.readthedocs.io/</a></li>
</ul>
<p>另外，为了具有更高的逼格，同时购入域名<code>httprunner.top</code>，后续将作为项目的主页地址。当前还处于实名认证中，预计2~3个工作日后就可以访问了。</p>
<p>关于项目改名这事儿，就说到这儿吧，希望你们也喜欢。</p>
<blockquote>
<p>Hello World, HttpRunner.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/apitestengine-not-only-about-json-api/&quot;&gt;《ApiTestEngine，不再局限于API的测试》&lt;/a&gt;一文的末尾，我提到随着&lt;code&gt;ApiTestEngine
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine，不再局限于API的测试</title>
    <link href="http://debugtalk.com/post/apitestengine-not-only-about-json-api/"/>
    <id>http://debugtalk.com/post/apitestengine-not-only-about-json-api/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从编写<a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>至今，已经快半年了。在这一段时间内，<code>ApiTestEngine</code>经过持续迭代，也已完全实现了当初预设的目标。</p>
<p>然而，在设计<code>ApiTestEngine</code>之初只考虑了面向最常规的API接口类型，即<code>HTTP</code>响应内容为<code>JSON</code>数据结构的类型。那么，如果<code>HTTP</code>接口响应内容不是<code>JSON</code>，而是<code>XML</code>或<code>SOAP</code>，甚至为<code>HTML</code>呢？</p>
<p>答案是，不支持！</p>
<p>不支持的原因是什么呢？</p>
<p>其实，不管是何种业务类型或者技术架构的系统接口，我们在对其进行测试时都可以拆分为三步：</p>
<ul>
<li>发起接口请求（Request）</li>
<li>解析接口响应（Parse Response）</li>
<li>校验测试结果（Validation）</li>
</ul>
<p>而<code>ApiTestEngine</code>不支持<code>XML/HTML</code>类型的接口，问题恰恰是出现在<code>解析接口响应</code>和<code>校验测试结果</code>这两个环节。考虑到<code>校验测试结果</code>环节是依赖于<code>解析接口响应</code>，即需要先从接口响应结果中解析出具体的字段，才能实现与预期结果的校验检测，因此，制约<code>ApiTestEngine</code>无法支持<code>XML/HTML</code>类型接口的根本原因在于无法支持对<code>XML/HTML</code>的解析。</p>
<p>也因为这个原因，<code>ApiTestEngine</code>存在局限性，没法推广到公司内部的所有项目组。遇到<code>JSON</code>类型以外的接口时，只能再使用别的测试工具，体验上很是不爽。</p>
<p>在经历了一段时间的不爽后，我开始重新思考<code>ApiTestEngine</code>的设计，希望使其具有更大的适用范围。通过前面的分析我们也不难看出，解决问题的关键在于实现针对<code>XML/HTML</code>的解析器。</p>
<h2 id="JSON接口的解析"><a href="#JSON接口的解析" class="headerlink" title="JSON接口的解析"></a>JSON接口的解析</h2><p>在实现<code>XML/HTML</code>的解析器之前，我们不妨先看下<code>ApiTestEngine</code>的<code>JSON</code>解析器是怎么工作的。</p>
<p>在<code>JSON</code>类型的数据结构中，无论结构有多么复杂，数据字段都只可能为如下三种数据类型之一：</p>
<ul>
<li>值（value）类型，包括数字、字符串等；该种数据类型的特点是不会再有下一层极的数据；</li>
<li>字典（dict）类型；该种数据类型的特点是包含无序的下一层极的数据；</li>
<li>列表（list）类型：该种数据类型的特点是包含有序的下一层极的数据。</li>
</ul>
<p>基于这一背景，<code>ApiTestEngine</code>在实现<code>JSON</code>的字段提取器（<code>extractor</code>）时，就采用了点（<code>.</code>）的运算符。</p>
<p>例如，假如<code>HTTP</code>接口响应的<code>headers</code>和<code>body</code>为如下内容：</p>
<p>response headers:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span>,</div><div class="line">    <span class="attr">"Content-Length"</span>: <span class="number">69</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>response body:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"success"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"person"</span>: &#123;</div><div class="line">        <span class="attr">"name"</span>: &#123;</div><div class="line">            <span class="attr">"first_name"</span>: <span class="string">"Leo"</span>,</div><div class="line">            <span class="attr">"last_name"</span>: <span class="string">"Lee"</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">"age"</span>: <span class="number">29</span>,</div><div class="line">        <span class="attr">"cities"</span>: [<span class="string">"Guangzhou"</span>, <span class="string">"Shenzhen"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么对应的字段提取方式就为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;headers.content-type&quot; =&gt; &quot;application/json&quot;</div><div class="line">&quot;headers.content-length&quot; =&gt; 69</div><div class="line">&quot;body.success&quot;/&quot;content.success&quot;/&quot;text.success&quot; =&gt; false</div><div class="line"></div><div class="line">&quot;content.person.name.first_name&quot; =&gt; &quot;Leo&quot;</div><div class="line">&quot;content.person.age&quot; =&gt; 29</div><div class="line">&quot;content.person.cities&quot; =&gt; [&quot;Guangzhou&quot;, &quot;Shenzhen&quot;]</div><div class="line">&quot;content.person.cities.0&quot; =&gt; &quot;Guangzhou&quot;</div><div class="line">&quot;content.person.cities.1&quot; =&gt; &quot;Shenzhen&quot;</div></pre></td></tr></table></figure>
<p>可以看出，通过点（<code>.</code>）运算符，我们可以从上往下逐级定位到具体的字段：</p>
<ul>
<li>当下一级为字典时，通过<code>.key</code>来指定下一级的节点，例如<code>.person</code>，指定了<code>content</code>下的<code>person</code>节点；</li>
<li>当下一级为列表时，通过<code>.index</code>来指定下一级的节点，例如<code>.0</code>，指定了<code>cities</code>下的第一个元素。</li>
</ul>
<p>定位到具体字段后，我们也就可以方便地提取字段值供后续使用了，作为参数或者进行结果校验均可。</p>
<h2 id="实现XML-HTML的解析器"><a href="#实现XML-HTML的解析器" class="headerlink" title="实现XML/HTML的解析器"></a>实现XML/HTML的解析器</h2><p>从点（<code>.</code>）运算符的描述形式上来看，它和<code>XML/HTML</code>的<code>xpath</code>十分类似。既然如此，那我们针对<code>XML/HTML</code>类型的接口，是否可以基于<code>xpath</code>来实现解析器呢？</p>
<p>在大多数情况下的确可以。例如，针对如下HTML页面，当我们要获取标题信息时，我们就可以通过<code>xpath</code>来指定提取字段：<code>body/h1</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>订单页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>订单号：SA89193<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然而，如果我们想获取订单号（SA89193）时，使用<code>xpath</code>就没有办法了（通过<code>body/div/p</code>获取到的是<code>订单号：SA89193</code>，还需进一步地进行处理）。</p>
<p>那除了<code>xpath</code>，我们还能使用什么其它方法从<code>XML/HTML</code>中提取特定字段呢？</p>
<p>由于早些年对<code>LoadRunner</code>比较熟悉，因此我首先想到了<code>LoadRunner</code>的<code>web_reg_save_param</code>函数；在该函数中，我们可以通过指定左右边界（LB &amp; RB）来查找字段，将其提取出来并保存到变量中供后续使用。借鉴这种方式虽然可行，但在描述方式上还是比较复杂，特别是在<code>YAML</code>测试用例的<code>extract</code>中描述的时候。</p>
<p>再一想，这种方式的底层实现不就是正则表达式么。而且我们通过Python脚本解析网页时，采用正则表达式来对目标字段进行匹配和提取，的确也是通用性非常强的方式。</p>
<p>例如，假设我们现在想从<code>http://debugtalk.com</code>首页中提取出座右铭，通过查看网页源代码，我们可以看到座右铭对应的位置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"blog-motto"</span>&gt;</span>探索一个软件工程师的无限可能<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么，要提取“探索一个软件工程师的无限可能”字符串时，我们就可以使用正则表达式<code>r&quot;blog-motto\&quot;&gt;(.*)&lt;/h2&gt;&quot;</code>进行匹配，然后使用<code>regex</code>的<code>group</code>将匹配内容提取出来。</p>
<p>对应的Python脚本实现如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re, requests</div><div class="line">&gt;&gt;&gt; resp = requests.get(<span class="string">"http://debugtalk.com"</span>)</div><div class="line">&gt;&gt;&gt; content = resp.text</div><div class="line">&gt;&gt;&gt; matched = re.search(r<span class="string">"blog-motto\"&gt;(.*)&lt;/h2&gt;"</span>, content)</div><div class="line">&gt;&gt;&gt; matched.group(1)</div><div class="line"><span class="string">'探索一个软件工程师的无限可能'</span></div></pre></td></tr></table></figure>
<p>思路确定后，实现起来就很快了。</p>
<p>此处省略256字。。。</p>
<p>最终，我在<code>ApiTestEngine</code>中新增实现了一个基于正则表达式的提取器。使用形式与JSON解析保持一致，只需要将之前的点（<code>.</code>）运算符更改为正则表达式即可。</p>
<p>还是前面提取座右铭的例子，我们就可以通过<code>YAML</code>格式来编写测试用例。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> demo</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://debugtalk.com/</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - motto:</span> <span class="string">'blog-motto\"&gt;(.*)&lt;/h2&gt;'</span></div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div></pre></td></tr></table></figure>
<p>需要说明的是，指定的正则表达式必须满足<code>r&quot;.*\(.*\).*&quot;</code>的格式要求，必须并且只能有一个分组（即一对括号）。如果在同一段内容中需要提取多个字段，那就分多次匹配即可。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>实现了基于正则表达式的提取器后，我们就彻底实现了对任意格式<code>HTTP</code>响应内容的解析，不仅限于<code>XML/HTML</code>类型，对于任意基于<code>HTTP</code>协议的的接口，<code>ApiTestEngine</code>都可以适用了。当然，如果接口响应是<code>JSON</code>类型，我们虽然可以也使用正则表达式提取，但更建议采用原有的点（<code>.</code>）运算符形式，因为描述更清晰。</p>
<p>至此，<code>ApiTestEngine</code>可以说是真正意义上实现了，面向任意类型的<code>HTTP</code>协议接口，只需要编写维护一份<code>YAML</code>用例，即可同时实现接口自动化测试、性能测试、持续集成、线上监控的全测试类型覆盖！</p>
<p>现在看来，<code>ApiTestEngine</code>的名字与其实际功能有些不大匹配了，是该考虑改名了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从编写&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-api-test-best-prac
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="JSON API" scheme="http://debugtalk.com/tags/JSON-API/"/>
    
      <category term="正则表达式" scheme="http://debugtalk.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>约定大于配置：ApiTestEngine实现热加载机制</title>
    <link href="http://debugtalk.com/post/apitestengine-hot-plugin/"/>
    <id>http://debugtalk.com/post/apitestengine-hot-plugin/</id>
    <published>2017-09-08T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>中编写测试用例时，我们有时需要定义全局的变量，或者引用外部函数实现一些动态的计算逻辑。当前采用的方式是：</p>
<ul>
<li>若需定义全局的参数变量，则要在<code>YAML/JSON</code>的<code>config</code>中，使用<code>variables</code>定义变量；</li>
<li>若需引用外部函数，则要在<code>YAML/JSON</code>的<code>config</code>中，使用<code>import_module_items</code>导入指定的<code>Python</code>模块。</li>
</ul>
<p>虽然这种方式提供了极大的灵活性，但是对于用户来说可能会显得比较复杂。另外一方面，这种方式也会造成大量重复的情况。</p>
<p>例如，对于变量来说，假如我们的项目中存在100个测试场景，而每个场景中都需要将用户账号（<code>test@ijd</code>）作为全局变量来使用，那么在现有模式下，我们只能在这100个<code>YAML/JSON</code>文件的<code>config</code>中都采用如下方式定义一遍：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"smoketest for scenario A."</span></div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - username:</span> test@ijd</div></pre></td></tr></table></figure>
<p>同样的，对于外部函数来说，假如我们项目的100个测试场景都需要用到生成随机字符串的函数（<code>gen_random_string</code>），那么我们也不得不在这100个<code>YAML/JSON</code>文件的<code>config</code>中都导入一次该函数所在的<code>Python</code>模块（假设相对于工作目录的路径为<code>extra/utils.py</code>）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"smoketest for scenario A."</span></div><div class="line"><span class="attr">    import_module_items:</span></div><div class="line"><span class="bullet">        -</span> extra.utils</div></pre></td></tr></table></figure>
<p>由此可见，当测试场景越来越多以后，要维护好全局变量和外部函数，必定会是一个很大的工作量。</p>
<p>那么，如果既要能引用公共的变量和函数，又要减少重复的定义和导入，那要怎么做呢？</p>
<h2 id="pytest-的-conftest-py"><a href="#pytest-的-conftest-py" class="headerlink" title="pytest 的 conftest.py"></a>pytest 的 conftest.py</h2><p>前段时间在接触<code>pytest</code>时，看到<code>pytest</code>支持<code>conftest.py</code>的插件机制，这是一种在测试文件中可以实现模块自动发现和热加载的机制。具体地，只要是在文件目录存在命名为<code>conftest.py</code>的文件，里面定义的<code>hook</code>函数都会在<code>pytest</code>运行过程中被导入，并可被测试用例进行调用。同时，<code>conftest.py</code>存在优先级策略，从测试用例所在目录到系统根目录的整个路径中，越靠近测试用例的<code>conftest.py</code>优先级越高。</p>
<p>其实这也是采用了<code>约定大于配置</code>（<code>convention over configuration</code>）的思想。<code>约定大于配置</code>是一种软件设计范式，旨在减少软件开发人员需做决定的数量，在遵从约定的过程中就不自觉地沿用了最佳工程实践。我个人也是比较喜欢这种方式的，所以在设计<code>ApiTestEngine</code>的时候，也借鉴了一些类似的思想。</p>
<p>受到该启发，我想也可以采用类似的思想，采用自动热加载的机制，解决背景描述中存在的重复定义和引用的问题。</p>
<p>既然是<code>约定大于配置</code>，那么我们首先就得定一个默认的<code>Python</code>模块名，类似于<code>pytest</code>的<code>conftest.py</code>。</p>
<p>这就是<code>debugtalk.py</code>。</p>
<h2 id="debugtalk-py-的命名由来"><a href="#debugtalk-py-的命名由来" class="headerlink" title="debugtalk.py 的命名由来"></a>debugtalk.py 的命名由来</h2><p>为啥会采用<code>debugtalk.py</code>这个命名呢？</p>
<p>其实当时在想这个名字的时候也是耗费了很多心思，毕竟是要遵从<code>约定大于配置</code>的思想，因此在设计这个约定的命名时就格外谨慎，但始终没有想到一个既合适又满意的。</p>
<p>在我看来，这个命名应该至少满足如下两个条件：</p>
<ul>
<li>唯一性强</li>
<li>简单易记</li>
</ul>
<p>首先，约定的模块名应该具有较强的唯一性和较高的区分度，是用户通常都不会采用的命名；否则，可能就会出现测试用例在运行过程中，热加载时导入预期之外的<code>Python</code>模块。</p>
<p>但也不能仅仅为了具有区分度，就使用一个很长或者毫无意义的字符串作为模块名；毕竟还是要给用户使用的，总不能每次写用例时还要去查看下文档吧；所以命名简单易记便于用户使用也很重要。</p>
<p>也是因为这两个有点互相矛盾的原则，让我在设计命名时很是纠结。最终在拉同事讨论良久而无果的时候，同事说，不如就命名为<code>debugtalk.py</code>得了。</p>
<p>仔细一想，这命名还真符合要求。在唯一性方面，采用<code>debugtalk.py</code>在<code>Google</code>、<code>Bing</code>、<code>Baidu</code>等搜索引擎中采用精确匹配，基本没有无关信息，这样在后续遇到问题时，也容易搜索到已有的解决方案；而在简单易记方面，相信这个命名也不会太复杂。</p>
<p>当然，<code>debugtalk.py</code>只是作为框架默认加载的<code>Python</code>模块名，如果你不喜欢，也可以进行配置修改。</p>
<h2 id="热加载机制实现原理"><a href="#热加载机制实现原理" class="headerlink" title="热加载机制实现原理"></a>热加载机制实现原理</h2><p>然后，再来讲解下热加载机制的实现。</p>
<p>其实原理也不复杂，从背景描述可以看出，我们期望实现的需求主要有两点：</p>
<ul>
<li>自动发现<code>debugtalk.py</code>函数模块，并且具有优先级策略；</li>
<li>将<code>debugtalk.py</code>函数模块中的变量和函数导入到当前框架运行的内存空间。</li>
</ul>
<p>将这两点与测试用例引擎的实现机制结合起来，<code>ApiTestEngine</code>在运行过程中的热加载机制应该就如下图所示。</p>
<p><img src="/images/ate-hot-plugin.png" alt=""></p>
<p>这个流程图对热加载机制描述得已经足够清晰了，我再针对其中的几个点进行说明：</p>
<p>1、在初始化测试用例集（testset）的时候，除了将<code>config</code>中<code>variables</code>和<code>import_module_items</code>指定的变量和函数导入外，还会默认导入<code>ate/built_in.py</code>模块。之所以这么做，是因为对于大多数系统可能都会用到一些通用的函数，例如获取当前时间戳（<code>get_timestamp</code>）、生成随机字符串（<code>gen_random_string</code>）等。与其在每个项目中都单独去实现这些函数，不如就将其添加到框架中作为默认支持的函数（相当于框架层面的<code>debugtalk.py</code>），这样大家在项目中就不需要再重复做这些基础性工作了。</p>
<p>2、在<code>ApiTestEngine</code>框架中，存在测试用例（<code>testcase</code>）和测试用例集（<code>testset</code>）两个层面的作用域，两者的界限十分明确。这样设计的目的在于，我们既可以实现用例集层面的变量和函数的定义和导入，也可以保障各个用例之间的独立性，不至于出现作用域相互污染的情况。具体地，作用域在用例集初始化时定义或导入的变量和函数，会存储在用例集层面的作用域；而在运行每条测试用例时，会先继承（<code>deepcopy</code>）用例集层面的作用域，如果存在同名的变量或函数定义，则会对用例集层面的变量和函数进行覆盖，同时用例集层面的变量和函数也并不会被修改。</p>
<p>3、从热加载的顺序可以看出，查找变量或函数的顺序是从测试用例所在目录开始，沿着父路径逐层往上，直到系统的根目录。因此，我们可以利用这个优先级原则来组织我们的用例和依赖的<code>Python</code>函数模块。例如，我们可以将不同模块的测试用例集文件放在不同的文件夹下：针对各个模块独有的依赖函数和变量，可以放置在对应文件夹的<code>debugtalk.py</code>文件中；而整个项目公共的函数和变量，就可以放置到项目文件夹的<code>debugtalk.py</code>中。</p>
<p>文件组织结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  project ✗ tree .</div><div class="line">.</div><div class="line">├── debugtalk.py</div><div class="line">├── module_A</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── debugtalk.py</div><div class="line">│   ├── testsetA1.yml</div><div class="line">│   └── testsetA2.yml</div><div class="line">└── module_B</div><div class="line">    ├── __init__.py</div><div class="line">    ├── debugtalk.py</div><div class="line">    ├── testsetB1.yml</div><div class="line">    └── testsetB2.yml</div></pre></td></tr></table></figure>
<p>这其中还有一点需要格外注意。因为我们在框架运行过程中需要将<code>debugtalk.py</code>作为函数模块进行导入，因此我们首先要保障<code>debugtalk.py</code>满足<code>Python</code>模块的要求，也就是在对应的文件夹中要包含<code>__init__.py</code>文件。</p>
<p>如果对热加载机制的实现感兴趣，可直接阅读框架源码，重点只需查看<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/ate/utils.py" target="_blank" rel="external"><code>ate/utils.py</code></a>中的三个函数：</p>
<ul>
<li>search_conf_item(start_path, item_type, item_name)</li>
<li>get_imported_module_from_file(file_path)</li>
<li>filter_module(module, filter_type)</li>
</ul>
<h2 id="测试用例编写方式的变化"><a href="#测试用例编写方式的变化" class="headerlink" title="测试用例编写方式的变化"></a>测试用例编写方式的变化</h2><p>在新增<code>热加载机制</code>之后，编写测试用例的方式发生一些改变（优化），主要包括三点：</p>
<ul>
<li>导入<code>Python</code>模块的关键词改名为<code>import_module_items</code>（原名为<code>import_module_functions</code>）；</li>
<li>不再需要显式指定导入的<code>Python</code>模块路径，变更为热加载机制自动发现；</li>
<li><code>Python</code>模块中的变量也会被导入，公共变量可放置在<code>Python</code>模块中，而不再必须通过<code>variables</code>定义。</li>
</ul>
<p>考虑到兼容性问题，框架升级的同时也保留了对原有测试用例编写方式的支持，因此框架升级对已有测试用例的正常运行也不会造成影响。不过，我还是强烈建议大家采用最新的用例编写方式，充分利用热加载机制带来的便利。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>现在回过头来看<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的演进历程，以及之前写的关于<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>设计方面的文章，会发现当初的确是有一些考虑不周全的地方。也许这也是编程的乐趣所在吧，在前行的道路中，总会有新的感悟和新的收获，迭代优化的过程，就仿佛是在打磨一件艺术品。</p>
<p>这种感觉，甚好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://github.com/debugtalk/ApiTestEngine&quot; target=&quot;
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="热加载" scheme="http://debugtalk.com/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="debugtalk.py" scheme="http://debugtalk.com/tags/debugtalk-py/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 集成 Locust 实现更好的性能测试体验</title>
    <link href="http://debugtalk.com/post/apitestengine-supersede-locust/"/>
    <id>http://debugtalk.com/post/apitestengine-supersede-locust/</id>
    <published>2017-08-26T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>不是接口测试框架么，也能实现性能测试？</p>
<p>是的，你没有看错，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>集成了<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>性能测试框架，只需一份测试用例，就能同时实现接口自动化测试和接口性能测试，在不改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>任何特性的情况下，甚至比<code>Locust</code>本身更易用。</p>
<p>如果你还没有接触过<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>这款性能测试工具，那么这篇文章可能不适合你。但我还是强烈推荐你了解一下这款工具。简单地说，<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>是一款采用<code>Python</code>语言编写实现的开源性能测试工具，简洁、轻量、高效，并发机制基于<code>gevent</code>协程，可以实现单机模拟生成较高的并发压力。关于<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的特性介绍和使用教程，我之前已经写过不少，你们可以在我的博客中找到<a href="http://debugtalk.com/tags/Locust/">对应文章</a>。</p>
<p>如果你对实现的过程没有兴趣，可以直接跳转到文章底部，看<code>最终实现效果</code>章节。</p>
<h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>在当前市面上的测试工具中，接口测试和性能测试基本上是两个泾渭分明的领域。这也意味着，针对同一个系统的服务端接口，我们要对其实现接口自动化测试和接口性能测试时，通常都是采用不同的工具，分别维护两份测试脚本或用例。</p>
<p>之前我也是这么做的。但是在做了一段时间后我就在想，不管是接口功能测试，还是接口性能测试，核心都是要模拟对接口发起请求，然后对接口响应内容进行解析和校验；唯一的差异在于，接口性能测试存在并发的概念，相当于模拟了大量用户同时在做接口测试。</p>
<p>既然如此，那接口自动化测试用例和接口性能测试脚本理应可以合并为一套，这样就可以避免重复的脚本开发工作了。</p>
<p>在开发<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的过程中，之前的文章也说过，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>完全基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Python-Requests</code></a>库实现HTTP的请求处理，可以在编写接口测试用例时复用到<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Python-Requests</code></a>的所有功能特性。而之前在学习<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的源码时，发现<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>在实现HTTP请求的时候，也完全是基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Python-Requests</code></a>库。</p>
<p>在这一层关系的基础上，我提出一个大胆的设想，能否通过一些方式或手段，可以使<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>中编写的<code>YAML/JSON</code>格式的接口测试用例，也能直接让<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>直接调用呢？</p>
<h2 id="灵感初探"><a href="#灵感初探" class="headerlink" title="灵感初探"></a>灵感初探</h2><p>想法有了以后，就开始探索实现的方法了。</p>
<p>首先，我们可以看下<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的脚本形式。如下例子是一个比较简单的场景（截取自官网首页）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteTasks</span><span class="params">(TaskSet)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></div><div class="line">        self.client.post(<span class="string">"/login"</span>, &#123;</div><div class="line">            <span class="string">"username"</span>: <span class="string">"test_user"</span>,</div><div class="line">            <span class="string">"password"</span>: <span class="string">""</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line"><span class="meta">    @task</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></div><div class="line">        self.client.get(<span class="string">"/"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @task</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">(self)</span>:</span></div><div class="line">        self.client.get(<span class="string">"/about/"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span><span class="params">(HttpLocust)</span>:</span></div><div class="line">    task_set = WebsiteTasks</div><div class="line">    min_wait = <span class="number">5000</span></div><div class="line">    max_wait = <span class="number">15000</span></div></pre></td></tr></table></figure>
<p>在<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的脚本中，我们会在<code>TaskSet</code>子类中描述单个用户的行为，每一个带有<code>@task</code>装饰器的方法都对应着一个HTTP请求场景。而<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的一个很大特点就是，所有的测试用例脚本都是<code>Python</code>文件，因此我们可以采用Python实现各种复杂的场景。</p>
<p>等等！模拟单个用户请求，而且还是纯粹的Python语言，我们不是在接口测试中已经实现的功能么？</p>
<p>例如，下面的代码就是从单元测试中截取的测试用例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run_testset</span><span class="params">(self)</span>:</span></div><div class="line">    testcase_file_path = os.path.join(</div><div class="line">        os.getcwd(), <span class="string">'examples/quickstart-demo-rev-3.yml'</span>)</div><div class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</div><div class="line">    results = self.test_runner.run_testset(testsets[<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p><code>test_runner.run_testset</code>是已经在<code>ApiTestEngine</code>中实现的方法，作用是传入测试用例（<code>YAML/JSON</code>）的路径，然后就可以加载测试用例，运行整个测试场景。并且，由于我们在测试用例<code>YAML/JSON</code>中已经描述了<code>validators</code>，即接口的校验部分，因此我们也无需再对接口响应结果进行校验描述了。</p>
<p>接下来，实现方式就非常简单了。</p>
<p>我们只需要制作一个<code>locustfile.py</code>的模板文件，内容如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding: utf-8</span></div><div class="line"><span class="keyword">import</span> zmq</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</div><div class="line"><span class="keyword">from</span> ate <span class="keyword">import</span> utils, runner</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageTasks</span><span class="params">(TaskSet)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></div><div class="line">        self.test_runner = runner.Runner(self.client)</div><div class="line">        self.testset = self.locust.testset</div><div class="line"></div><div class="line"><span class="meta">    @task</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_specified_scenario</span><span class="params">(self)</span>:</span></div><div class="line">       self.test_runner.run_testset(self.testset)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageUser</span><span class="params">(HttpLocust)</span>:</span></div><div class="line">    host = <span class="string">''</span></div><div class="line">    task_set = WebPageTasks</div><div class="line">    min_wait = <span class="number">1000</span></div><div class="line">    max_wait = <span class="number">5000</span></div><div class="line"></div><div class="line">    testcase_file_path = os.path.join(os.getcwd(), <span class="string">'skypixel.yml'</span>)</div><div class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</div><div class="line">    testset = testsets[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>可以看出，整个文件中，只有测试用例文件的路径是与具体测试场景相关的，其它内容全都可以不变。</p>
<p>于是，针对不同的测试场景，我们只需要将<code>testcase_file_path</code>替换为接口测试用例文件的路径，即可实现对应场景的接口性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ApiTestEngine git:(master) ✗ locust <span class="_">-f</span> locustfile.py</div><div class="line">[2017-08-27 11:30:01,829] bogon/INFO/locust.main: Starting web monitor at *:8089</div><div class="line">[2017-08-27 11:30:01,831] bogon/INFO/locust.main: Starting Locust 0.8a2</div></pre></td></tr></table></figure>
<p>后面的操作就完全是<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的内容了，使用方式完全一样。</p>
<p><img src="/images/locust-start.jpg" alt=""></p>
<h2 id="优化1：自动生成locustfile"><a href="#优化1：自动生成locustfile" class="headerlink" title="优化1：自动生成locustfile"></a>优化1：自动生成locustfile</h2><p>通过前面的探索实践，我们基本上就实现了一份测试用例同时兼具接口自动化测试和接口性能测试的功能。</p>
<p>然而，在使用上还不够便捷，主要有两点：</p>
<ul>
<li>需要手工修改模板文件中的<code>testcase_file_path</code>路径；</li>
<li><code>locustfile.py</code>模板文件的路径必须放在<code>ApiTestEngine</code>的项目根目录下。</li>
</ul>
<p>于是，我产生了让<code>ApiTestEngine</code>框架本身自动生成<code>locustfile.py</code>文件的想法。</p>
<p>在实现这个想法的过程中，我想过两种方式。</p>
<p>第一种，通过分析<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的源码，可以看到<code>Locust</code>在<code>main.py</code>中具有一个<code>load_locustfile</code>方法，可以加载Python格式的文件，并提取出其中的<code>locust_classes</code>（也就是<code>Locust</code>的子类）；后续，就是将<code>locust_classes</code>作为参数传给<code>Locust</code>的<code>Runner</code>了。</p>
<p>若采用这种思路，我们就可以实现一个类似<code>load_locustfile</code>的方法，将<code>YAML/JSON</code>文件中的内容动态生成<code>locust_classes</code>，然后再传给<code>Locust</code>的<code>Runner</code>。这里面会涉及到动态地创建类和添加方法，好处是不需要生成<code>locustfile.py</code>中间文件，并且可以实现最大的灵活性，但缺点在于需要改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的源码，即重新实现<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的<code>main.py</code>中的多个函数。虽然难度不会太大，但考虑到后续需要与<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的更新保持一致，具有一定的维护工作量，便放弃了该种方案。</p>
<p>第二种，就是生成<code>locustfile.py</code>这样一个中间文件，然后将文件路径传给<code>Locust</code>。这样的好处在于我们可以不改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的任何地方，直接对其进行使用。与<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的传统使用方式差异在于，之前我们是在<code>Terminal</code>中通过参数启动<code>Locust</code>，而现在我们是在<code>ApiTestEngine</code>框架中通过Python代码启动<code>Locust</code>。</p>
<p>具体地，我在<code>setup.py</code>的<code>entry_points</code>中新增了一个命令<code>locusts</code>，并绑定了对应的程序入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">entry_points=&#123;</div><div class="line">    <span class="string">'console_scripts'</span>: [</div><div class="line">        <span class="string">'ate=ate.cli:main_ate'</span>,</div><div class="line">        <span class="string">'locusts=ate.cli:main_locust'</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>ate/cli.py</code>中新增了<code>main_locust</code>函数，作为<code>locusts</code>命令的入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">""" Performance test with locust: parse command line options and run commands.</span></div><div class="line">    """</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">from</span> locust.main <span class="keyword">import</span> main</div><div class="line">    <span class="keyword">except</span> ImportError:</div><div class="line">        print(<span class="string">"Locust is not installed, exit."</span>)</div><div class="line">        exit(<span class="number">1</span>)</div><div class="line"></div><div class="line">    sys.argv[<span class="number">0</span>] = <span class="string">'locust'</span></div><div class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</div><div class="line">        sys.argv.extend([<span class="string">"-h"</span>])</div><div class="line"></div><div class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">"-h"</span>, <span class="string">"--help"</span>, <span class="string">"-V"</span>, <span class="string">"--version"</span>]:</div><div class="line">        main()</div><div class="line">        sys.exit(<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        testcase_index = sys.argv.index(<span class="string">'-f'</span>) + <span class="number">1</span></div><div class="line">        <span class="keyword">assert</span> testcase_index &lt; len(sys.argv)</div><div class="line">    <span class="keyword">except</span> (ValueError, AssertionError):</div><div class="line">        print(<span class="string">"Testcase file is not specified, exit."</span>)</div><div class="line">        sys.exit(<span class="number">1</span>)</div><div class="line"></div><div class="line">    testcase_file_path = sys.argv[testcase_index]</div><div class="line">    sys.argv[testcase_index] = parse_locustfile(testcase_file_path)</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>若你执行<code>locusts -V</code>或<code>locusts -h</code>，会发现效果与<code>locust</code>的特性完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ locusts -V</div><div class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout: Locust 0.8a2</div><div class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout:</div></pre></td></tr></table></figure>
<p>事实上，通过上面的代码（<code>main_locust</code>）也可以看出，<code>locusts</code>命令只是对<code>locust</code>进行了一层封装，用法基本等价。唯一的差异在于，当<code>-f</code>参数指定的是<code>YAML/JSON</code>格式的用例文件时，会先转换为Python格式的<code>locustfile.py</code>，然后再传给<code>locust</code>。</p>
<p>至于解析函数<code>parse_locustfile</code>，实现起来也很简单。我们只需要在框架中保存一份<code>locustfile.py</code>的模板文件（<code>ate/locustfile_template</code>），并将<code>testcase_file_path</code>采用占位符代替。然后，在解析函数中，就可以读取整个模板文件，将其中的占位符替换为<code>YAML/JSON</code>用例文件的实际路径，然后再保存为<code>locustfile.py</code>，并返回其路径即可。</p>
<p>具体的代码就不贴了，有兴趣的话可自行查看。</p>
<p>通过这一轮优化，<code>ApiTestEngine</code>就继承了<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的全部功能，并且可以直接指定<code>YAML/JSON</code>格式的文件启动<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>执行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ locusts <span class="_">-f</span> examples/first-testcase.yml</div><div class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</div><div class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</div></pre></td></tr></table></figure>
<h2 id="优化2：一键启动多个locust实例"><a href="#优化2：一键启动多个locust实例" class="headerlink" title="优化2：一键启动多个locust实例"></a>优化2：一键启动多个locust实例</h2><p>经过第一轮优化后，本来应该是告一段落了，因为此时<code>ApiTestEngine</code>已经可以非常便捷地实现接口自动化测试和接口性能测试的切换了。</p>
<p>直到有一天，在<code>TesterHome</code>论坛讨论<code>Locust</code>的一个<a href="https://testerhome.com/topics/9277#reply-84542" target="_blank" rel="external">回复</a>中，<a href="https://testerhome.com/keithmork" target="_blank" rel="external"><code>@keithmork</code></a>说了这么一句话。</p>
<blockquote>
<p>期待有一天<code>ApiTestEngine</code>的热度超过<code>Locust</code>本身</p>
</blockquote>
<p>看到这句话时我真的不禁泪流满面。虽然我也是一直在用心维护<code>ApiTestEngine</code>，却从未有过这样的奢望。</p>
<p>但反过来细想，为啥不能有这样的想法呢？当前<code>ApiTestEngine</code>已经继承了<code>Locust</code>的所有功能，在不影响<code>Locust</code>已有特性的同时，还可以采用<code>YAML/JSON</code>格式来编写维护测试用例，并实现了一份测试用例可同时用于接口自动化和接口性能测试的目的。</p>
<p>这些特性都是<code>Locust</code>所不曾拥有的，而对于使用者来说的确也都是比较实用的功能。</p>
<p>于是，新的目标在内心深处萌芽了，那就是在<code>ApiTestEngine</code>中通过对<code>Locust</code>更好的封装，让<code>Locust</code>的使用者体验更爽。</p>
<p>然后，我又想到了自己之前做的一个开源项目，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="external"><code>debugtalk/stormer</code></a>。当时做这个项目的初衷在于，当我们使用<code>Locust</code>进行压测时，要想使用压测机所有CPU的性能，就需要采用<code>master-slave</code>模式。因为<code>Locust</code>默认是单进程运行的，只能运行在压测机的一个CPU核上；而通过采用<code>master-slave</code>模式，启动多个<code>slave</code>，就可以让不同的<code>slave</code>运行在不同的CPU核上，从而充分发挥压测机多核处理器的性能。</p>
<p>而在实际使用<code>Locust</code>的时候，每次只能手动启动<code>master</code>，并依次手动启动多个<code>slave</code>。若遇到测试脚本调整的情况，就需要逐一结束<code>Locust</code>的所有进程，然后再重复之前的启动步骤。如果有使用过<code>Locust</code>的同学，应该对此痛苦的经历都有比较深的体会。当时也是基于这一痛点，我开发了<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="external"><code>debugtalk/stormer</code></a>，目的就是可以一次性启动或销毁多个<code>Locust</code>实例。这个脚本做出来后，自己用得甚爽，也得到了<code>Github</code>上一些朋友的青睐。</p>
<p>既然现在要提升<code>ApiTestEngine</code>针对<code>Locust</code>的使用便捷性，那么这个特性毫无疑问也应该加进去。就此，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="external"><code>debugtalk/stormer</code></a>项目便被废弃，正式合并到<code>debugtalk/ApiTestEngine</code>。</p>
<p>想法明确后，实现起来也挺简单的。</p>
<p>原则还是保持不变，那就是不改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>本身的特性，只在传参的时候在中间层进行操作。</p>
<p>具体地，我们可以新增一个<code>--full-speed</code>参数。当不指定该参数时，使用方式跟之前完全相同；而指定<code>--full-speed</code>参数后，就可以采用多进程的方式启动多个实例（实例个数等于压测机的处理器核数）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># do original work</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="string">"--full-speed"</span> <span class="keyword">in</span> sys.argv:</div><div class="line">        locusts.run_locusts_at_full_speed(sys.argv)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        locusts.main()</div></pre></td></tr></table></figure>
<p>具体实现逻辑在<code>ate/locusts.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">from</span> locust.main <span class="keyword">import</span> main</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_master</span><span class="params">(sys_argv)</span>:</span></div><div class="line">    sys_argv.append(<span class="string">"--master"</span>)</div><div class="line">    sys.argv = sys_argv</div><div class="line">    main()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_slave</span><span class="params">(sys_argv)</span>:</span></div><div class="line">    sys_argv.extend([<span class="string">"--slave"</span>])</div><div class="line">    sys.argv = sys_argv</div><div class="line">    main()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_locusts_at_full_speed</span><span class="params">(sys_argv)</span>:</span></div><div class="line">    sys_argv.pop(sys_argv.index(<span class="string">"--full-speed"</span>))</div><div class="line">    slaves_num = multiprocessing.cpu_count()</div><div class="line"></div><div class="line">    processes = []</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(slaves_num):</div><div class="line">        p_slave = multiprocessing.Process(target=start_slave, args=(sys_argv,))</div><div class="line">        p_slave.daemon = <span class="keyword">True</span></div><div class="line">        p_slave.start()</div><div class="line">        processes.append(p_slave)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        start_master(sys_argv)</div><div class="line">    <span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">        sys.exit(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>由此可见，关键点也就是使用了<code>multiprocessing.Process</code>，在不同的进程中分别调用<code>Locust</code>的<code>main()</code>函数，实现逻辑十分简单。</p>
<h2 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h2><p>经过前面的优化，采用<code>ApiTestEngine</code>执行性能测试时，使用就十分便捷了。</p>
<p>安装<code>ApiTestEngine</code>后，系统中就具有了<code>locusts</code>命令，使用方式跟<code>Locust</code>框架的<code>locust</code>几乎完全相同，我们完全可以使用<code>locusts</code>命令代替原生的<code>locust</code>命令。</p>
<p>例如，下面的命令执行效果与<code>locust</code>完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ locusts -V</div><div class="line">$ locusts -h</div><div class="line">$ locusts <span class="_">-f</span> locustfile.py</div><div class="line">$ locusts <span class="_">-f</span> locustfile.py --master -P 8088</div><div class="line">$ locusts <span class="_">-f</span> locustfile.py --slave &amp;</div></pre></td></tr></table></figure>
<p>差异在于，<code>locusts</code>具有更加丰富的功能。</p>
<p>在<code>ApiTestEngine</code>中编写的<code>YAML/JSON</code>格式的接口测试用例文件，直接运行就可以启动<code>Locust</code>运行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ locusts <span class="_">-f</span> examples/first-testcase.yml</div><div class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</div><div class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</div></pre></td></tr></table></figure>
<p>加上<code>--full-speed</code>参数，就可以同时启动多个<code>Locust</code>实例（实例个数等于处理器核数），充分发挥压测机多核处理器的性能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ locusts <span class="_">-f</span> examples/first-testcase.yml --full-speed -P 8088</div><div class="line">[2017-08-26 23:51:47,071] bogon/INFO/locust.main: Starting web monitor at *:8088</div><div class="line">[2017-08-26 23:51:47,075] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,078] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,080] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,083] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.runners: Client <span class="string">'bogon_656e0af8e968a8533d379dd252422ad3'</span> reported as ready. Currently 1 clients ready to swarm.</div><div class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_09f73850252ee4ec739ed77d3c4c6dba'</span> reported as ready. Currently 2 clients ready to swarm.</div><div class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_869f7ed671b1a9952b56610f01e2006f'</span> reported as ready. Currently 3 clients ready to swarm.</div><div class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_80a804cda36b80fac17b57fd2d5e7cdb'</span> reported as ready. Currently 4 clients ready to swarm.</div></pre></td></tr></table></figure>
<p><img src="/images/locusts-full-speed.jpg" alt=""></p>
<p>后续，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>将持续进行优化，欢迎大家多多反馈改进建议。</p>
<p>Enjoy!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/debugtalk/ApiTestEngine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;ApiTestEngine&lt;/code&gt;&lt;/a&gt;不是接口测试框架么，也能实现性能测试？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Locust" scheme="http://debugtalk.com/tags/Locust/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine QuickStart</title>
    <link href="http://debugtalk.com/post/apitestengine-quickstart/"/>
    <id>http://debugtalk.com/post/apitestengine-quickstart/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-Sample-Interface-Service"><a href="#Introduction-to-Sample-Interface-Service" class="headerlink" title="Introduction to Sample Interface Service"></a>Introduction to Sample Interface Service</h2><p>Along with this project, I devised a sample interface service, and you can use it to familiarize how to play with <code>ApiTestEngine</code>.</p>
<p>This sample service mainly has two parts:</p>
<ul>
<li>Authorization, each request of other APIs should sign with some header fields and get token first.</li>
<li>RESTful APIs for user management, you can do CRUD manipulation on users.</li>
</ul>
<p>As you see, it is very similar to the mainstream production systems. Therefore once you are familiar with handling this demo service, you can master most test scenarios in your project.</p>
<h2 id="Launch-Sample-Interface-Service"><a href="#Launch-Sample-Interface-Service" class="headerlink" title="Launch Sample Interface Service"></a>Launch Sample Interface Service</h2><p>The demo service is a flask server, we can launch it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ export FLASK_APP=tests/api_server.py</div><div class="line">$ flask run</div><div class="line"> * Serving Flask app &quot;tests.api_server&quot;</div><div class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</div></pre></td></tr></table></figure>
<p>Now the sample interface service is running, and we can move on to the next step.</p>
<h2 id="Capture-HTTP-request-and-response"><a href="#Capture-HTTP-request-and-response" class="headerlink" title="Capture HTTP request and response"></a>Capture HTTP request and response</h2><p>Before we write testcases, we should know the details of the API. It is a good choice to use a web debugging proxy tool like <code>Charles Proxy</code> to capture the HTTP traffic.</p>
<p>For example, the image below illustrates getting token from the sample service first, and then creating one user successfully.</p>
<p><img src="/images/ate-quickstart-http-1.jpg" alt=""></p>
<p><img src="/images/ate-quickstart-http-2.jpg" alt=""></p>
<p>After thorough understanding of the APIs, we can now begin to write testcases.</p>
<h2 id="Write-the-first-test-case"><a href="#Write-the-first-test-case" class="headerlink" title="Write the first test case"></a>Write the first test case</h2><p>Open your favorite text editor and you can write test cases like this.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> iOS/<span class="number">10.3</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            os_platform:</span> ios</div><div class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> <span class="number">19067</span>cf712265eb5426db8d3664026c1ccea02b9</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            token:</span> F8prvGryC5beBr4g</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>As you see, each API request is described in a <code>test</code> block. And in the <code>request</code> field, it describes the detail of HTTP request, includes url, method, headers and data, which are in line with the captured traffic.</p>
<p>You may wonder why we use the <code>json</code> field other than <code>data</code>. That’s because the post data is in <code>JSON</code> format, when we use <code>json</code> to indicate the post data, we do not have to specify <code>Content-Type</code> to be <code>application/json</code> in request headers or dump data before request.</p>
<p>Have you recalled some familiar scenes?</p>
<p>Yes! That’s what we did in <a href="requests.request"><code>requests.request</code></a>! Since <code>ApiTestEngine</code> takes full reuse of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>, it inherits all powerful features of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>, and we can handle HTTP request as the way we do before.</p>
<h2 id="Run-test-cases"><a href="#Run-test-cases" class="headerlink" title="Run test cases"></a>Run test cases</h2><p>Suppose the test case file is named as <code>quickstart-demo-rev-0.yml</code> and is located in <code>examples</code> folder, then we can run it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ate examples/demo-rev-0.yml</div><div class="line">Running tests...</div><div class="line">----------------------------------------------------------------------</div><div class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 48 ms, response_length: 46 bytes</div><div class="line">OK (0.049669)s</div><div class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</div><div class="line">ERROR:root: Failed to POST http://127.0.0.1:5000/api/users/1000! exception msg: 403 Client Error: FORBIDDEN for url: http://127.0.0.1:5000/api/users/1000</div><div class="line">ERROR (0.006471)s</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 2 tests in 0.056s</div><div class="line"></div><div class="line">FAILED</div><div class="line"> (Errors=1)</div></pre></td></tr></table></figure>
<p>Oops! The second test case failed with 403 status code.</p>
<p>That is because we request with the same data as we captured in <code>Charles Proxy</code>, while the <code>token</code> is generated dynamically, thus the recorded data can not be be used twice directly.</p>
<h2 id="Optimize-test-case-correlation"><a href="#Optimize-test-case-correlation" class="headerlink" title="Optimize test case: correlation"></a>Optimize test case: correlation</h2><p>To fix this problem, we should correlate <code>token</code> field in the second API test case, which is also called <code>correlation</code>.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> iOS/<span class="number">10.3</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            os_platform:</span> ios</div><div class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> <span class="number">19067</span>cf712265eb5426db8d3664026c1ccea02b9</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expected"</span>: <span class="number">16</span>&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            token:</span> $token</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>As you see, the <code>token</code> field is no longer hardcoded, instead it is extracted from the first API request with <code>extractors</code> mechanism. In the meanwhile, it is assigned to <code>token</code> variable, which can be referenced by the subsequent API requests.</p>
<p>Now we save the test cases to <code>quickstart-demo-rev-1.yml</code> and rerun it, and we will find that both API requests to be successful.</p>
<h2 id="Optimize-test-case-parameterization"><a href="#Optimize-test-case-parameterization" class="headerlink" title="Optimize test case: parameterization"></a>Optimize test case: parameterization</h2><p>Let’s look back to our test set <code>quickstart-demo-rev-1.yml</code>, and we can see the <code>device_sn</code> field is still hardcoded. This may be quite different from the actual scenarios.</p>
<p>In actual scenarios, each user’s <code>device_sn</code> is different, so we should parameterize the request parameters, which is also called <code>parameterization</code>. In the meanwhile, the <code>sign</code> field is calculated with other header fields, thus it may change significantly if any header field changes slightly.</p>
<p>However, the test cases are only <code>YAML</code> documents, it is impossible to generate parameters dynamically in such text. Fortunately, we can combine <code>Python</code> scripts with <code>YAML</code> test cases in <code>ApiTestEngine</code>.</p>
<p>To achieve this goal, we can utilize <code>import_module_functions</code> and <code>variables</code> mechanisms.</p>
<p>To be specific, we can create a Python file (<code>examples/utils.py</code>) and implement the related algorithm in it. Since we want to import this file, so we should put a <code>__init__.py</code> in this folder to make it as a Python module.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"><span class="keyword">import</span> hmac</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> string</div><div class="line"></div><div class="line">SECRET_KEY = <span class="string">"DebugTalk"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sign</span><span class="params">(*args)</span>:</span></div><div class="line">    content = <span class="string">''</span>.join(args).encode(<span class="string">'ascii'</span>)</div><div class="line">    sign_key = SECRET_KEY.encode(<span class="string">'ascii'</span>)</div><div class="line">    sign = hmac.new(sign_key, content, hashlib.sha1).hexdigest()</div><div class="line">    <span class="keyword">return</span> sign</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></div><div class="line">    random_char_list = []</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len):</div><div class="line">        random_char = random.choice(string.ascii_letters + string.digits)</div><div class="line">        random_char_list.append(random_char)</div><div class="line"></div><div class="line">    random_string = <span class="string">''</span>.join(random_char_list)</div><div class="line">    <span class="keyword">return</span> random_string</div></pre></td></tr></table></figure>
<p>And then, we can revise our demo test case and reference the functions. Suppose the revised file named <code>quickstart-demo-rev-2.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    import_module_functions:</span></div><div class="line"><span class="bullet">        -</span> examples.utils</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></div><div class="line"><span class="attr">        - device_sn:</span> $&#123;gen_random_string(<span class="number">15</span>)&#125;</div><div class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></div><div class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> $user_agent</div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"><span class="attr">            os_platform:</span> $os_platform</div><div class="line"><span class="attr">            app_version:</span> $app_version</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> $&#123;get_sign($user_agent, $device_sn, $os_platform, $app_version)&#125;</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expected"</span>: <span class="number">16</span>&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"><span class="attr">            token:</span> $token</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>In this revised test case, we firstly import module functions in <code>import_module_functions</code> block by specifying the Python module path, which is relative to the current working directory.</p>
<p>To make fields like <code>device_sn</code> can be used more than once, we also bind values to variables in <code>variables</code> block. When we bind variables, we can not only bind exact value to a variable name, but also can call a function and bind the evaluated value to it.</p>
<p>When we want to reference a variable in the test case, we can do this with a escape character <code>$</code>. For example, <code>$user_agent</code> will not be taken as a normal string, and <code>ApiTestEngine</code> will consider it as a variable named <code>user_agent</code>, search and return its binding value.</p>
<p>When we want to reference a function, we shall use another escape character <code>${}</code>. Any content in <code>${}</code> will be considered as function calling, so we should guarantee that we call functions in the right way. At the same time, variables can also be referenced as parameters of function.</p>
<h2 id="Optimize-test-case-overall-config-block"><a href="#Optimize-test-case-overall-config-block" class="headerlink" title="Optimize test case: overall config block"></a>Optimize test case: overall config block</h2><p>There is still one issue unsolved.</p>
<p>The <code>device_sn</code> field is defined in the first API test case, thus it may be impossible to reference it in other test cases. Context separation is a well-designed mechanism, and we should obey this good practice.</p>
<p>To handle this case, overall <code>config</code> block is supported in <code>ApiTestEngine</code>. If we define variables or import functions in <code>config</code> block, these variables and functions will become global and can be referenced in the whole test set.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># examples/quickstart-demo-rev-3.yml</span></div><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"smoketest for CRUD users."</span></div><div class="line"><span class="attr">    import_module_functions:</span></div><div class="line"><span class="bullet">        -</span> examples.utils</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - device_sn:</span> $&#123;gen_random_string(<span class="number">15</span>)&#125;</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span></div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></div><div class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></div><div class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> $user_agent</div><div class="line"><span class="attr">            os_platform:</span> $os_platform</div><div class="line"><span class="attr">            app_version:</span> $app_version</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> $&#123;get_sign($user_agent, $device_sn, $os_platform, $app_version)&#125;</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expected"</span>: <span class="number">16</span>&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            token:</span> $token</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>As you see, we import public <code>Python</code> modules and variables in <code>config</code> block. Also, we can set <code>base_url</code> in <code>config</code> block, thereby we can only specify relative path in each API request url. Besides, we can also set common fields in <code>config</code> <code>request</code>, such as <code>device_sn</code> in headers.</p>
<p>Until now, the test cases are finished and each detail is handled properly.</p>
<h2 id="Run-test-cases-and-generate-report"><a href="#Run-test-cases-and-generate-report" class="headerlink" title="Run test cases and generate report"></a>Run test cases and generate report</h2><p>Finally, let’s run test set <code>quickstart-demo-rev-4.yml</code> once more.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ ate examples/quickstart-demo-rev-4.yml</div><div class="line">Running tests...</div><div class="line">----------------------------------------------------------------------</div><div class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 33 ms, response_length: 46 bytes</div><div class="line">OK (0.037027)s</div><div class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</div><div class="line">INFO:root: status_code: 201, response_time: 15 ms, response_length: 54 bytes</div><div class="line">OK (0.016414)s</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 2 tests in 0.054s</div><div class="line">OK</div><div class="line"></div><div class="line">Generating HTML reports...</div><div class="line">Template is not specified, load default template instead.</div><div class="line">Reports generated: /Users/Leo/MyProjects/ApiTestEngine/reports/quickstart-demo-rev-0/2017-08-01-16-51-51.html</div></pre></td></tr></table></figure>
<p>Great! The test case runs successfully and generates a <code>HTML</code> test report.</p>
<p><img src="/images/ate-quickstart-demo-report.jpg" alt=""></p>
<h2 id="Further-more"><a href="#Further-more" class="headerlink" title="Further more"></a>Further more</h2><p>This is just a starting point, see the <code>advanced guide</code> for the advanced features.</p>
<ul>
<li>templating</li>
<li>data extraction and validation</li>
<li><a href="https://github.com/debugtalk/ApiTestEngine/blob/master/docs/comparator.md" target="_blank" rel="external"><code>comparator</code></a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Introduction-to-Sample-Interface-Service&quot;&gt;&lt;a href=&quot;#Introduction-to-Sample-Interface-Service&quot; class=&quot;headerlink&quot; title=&quot;Introduction
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>【大疆内推】岗位描述我只想这么写</title>
    <link href="http://debugtalk.com/post/d-test-hire-info/"/>
    <id>http://debugtalk.com/post/d-test-hire-info/</id>
    <published>2017-08-08T16:00:00.000Z</published>
    <updated>2018-03-04T15:50:56.846Z</updated>
    
    <content type="html"><![CDATA[<p>近期，大疆互联网事业部广招各路英豪，各类岗位都有大量的<code>Hire Count</code>。</p>
<p>在我们质量部，现急需招聘<code>软件测试工程师</code>、<code>测试开发工程师</code>和<code>QA</code>，名额无限制。</p>
<p>如果你对我们的岗位感兴趣，可能你还想了解如下信息。</p>
<h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>大疆这家公司我就不介绍了，大家有兴趣可以看下我们的<a href="http://www.dji.com/" target="_blank" rel="noopener">公司主页</a>，或者在网上自行搜索。</p>
<p>可能很多人都知道大疆是一家做无人机的公司，但却不知道我们一直在探索着与互联网各种跨界融合的方式，在移动互联网、云计算、大数据、物联网、电子商务等领域同样投入了大量的资源。而互联网事业部，则肩负着该项重要使命。</p>
<p>我们质量部作为互联网事业部的测试团队，对接了整个部门的所有产品和项目，一直致力于提升整个部门的软件质量的研发效率。</p>
<h2 id="岗位职责及要求"><a href="#岗位职责及要求" class="headerlink" title="岗位职责及要求"></a>岗位职责及要求</h2><p>当前我们有<code>测试</code>、<code>测试开发</code>、<code>QA</code>这三类岗位。</p>
<p>关于这三类岗位的职责和差异，基本上跟各大互联网公司的岗位对应。之前我在内部新员工培训时有过一次分享，并且整理成了一篇文章，<a href="http://debugtalk.com/post/introduction-to-testing-engineer-daily-work/">《【科普】互联网测试岗位的工作日常》</a>，大家如有兴趣，可以进一步了解。</p>
<p>而对于岗位的要求，我不想复制粘贴招聘信息上千篇一律的描述，我就只谈下我对每个岗位需求的理解。</p>
<p>对于测试工程师，最重要的莫过于熟悉业务、善于发现问题、跟进并推动问题的解决。对于两年工作经验以内的，我们看重基础，对计算机软件、网络、软件测试理论等方面能有较好的掌握，如果在工作中还能积极地学习新技术并在项目中尝试使用，会是一个不错的亮点。对于两年工作经验以上的，我们期望能对业务流程、测试工作本身有更深的理解，并且在软件测试技术方面有一定的积累，最好能有一些成功的实践经验。</p>
<p>对于测试开发工程师，我们重点关注两个方面，一是对测试本身的理解，最好能有比较丰富的业务测试经验，毕竟开发出来的工具还是要为业务测试服务的；另一方面，作为带有<code>开发</code>的title，希望也能有较好的代码能力，并且最好有成功的实践案例或作品。</p>
<p>对于QA，业务、流程、管理，以及有较强的推动能力。</p>
<p>不管是什么岗位，善于学习，乐于总结，具有写笔记或博客的习惯，都会是很大的加分项。</p>
<p>关于硬性条件这块儿，希望能是本科及以上学历，计算机相关专业。公司并没有严格限制学历，但是当学历不达标时，对工作背景以及其它方面会有更高的期望。</p>
<h2 id="薪资福利"><a href="#薪资福利" class="headerlink" title="薪资福利"></a>薪资福利</h2><p>对于薪资福利，不同岗位和级别会有一定差异，但不管是什么岗位，处于行业领先的薪资水平还是可以保障的。</p>
<p>年底有机会获得奔驰宝马福利车这种奖励可能会觉得离自己太遥远，但年终奖还是不错的，具体看绩效。</p>
<p>另外比较可喜的是，从公司不断增加的福利可以看到，公司也在一直致力于提升员工的各项软福利和归属感，各项规章管理制度也在日益完善和更加人性化。</p>
<p>除了单纯的薪资福利，相信公司业务迅猛发展带来的个人能力成长空间，也是你所期待的。在大疆，公司的口号是探索未来无限可能（The future of possible），这对员工个人来说，也同样适用。</p>
<h2 id="其它岗位"><a href="#其它岗位" class="headerlink" title="其它岗位"></a>其它岗位</h2><p>除了测试相关的岗位，我们在前后端开发、业务运维、运维开发等各个岗位都有海量的招聘需求。</p>
<p>如果你们有兴趣，我同样可以帮忙对接到各个岗位的负责人。</p>
<h2 id="投递方式"><a href="#投递方式" class="headerlink" title="投递方式"></a>投递方式</h2><p>可以直接发到我的邮箱：mail@debugtalk.com<br>也可以发送到我的微信公众号：<code>DebugTalk</code></p>
<p>合适的简历我会积极内推，并全程跟进状态和进度。假如跟我们的岗位需求不匹配，我也会及时反馈结果及原因。</p>
<p>愿疆来有你，不管最后我们能否成为同事，希望我们都能成为朋友。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，大疆互联网事业部广招各路英豪，各类岗位都有大量的&lt;code&gt;Hire Count&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在我们质量部，现急需招聘&lt;code&gt;软件测试工程师&lt;/code&gt;、&lt;code&gt;测试开发工程师&lt;/code&gt;和&lt;code&gt;QA&lt;/code&gt;，名额无限制。&lt;/
    
    </summary>
    
    
      <category term="招聘" scheme="http://debugtalk.com/tags/%E6%8B%9B%E8%81%98/"/>
    
  </entry>
  
  <entry>
    <title>How to install a package from Github that has other github dependencies ?</title>
    <link href="http://debugtalk.com/post/How-to-install-a-package-from-Github-that-has-other-github-dependencies/"/>
    <id>http://debugtalk.com/post/How-to-install-a-package-from-Github-that-has-other-github-dependencies/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2017-12-24T01:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发<code>ApiTestEngine</code>时遇到一个安装包依赖的问题，耗费了不少时间寻找解决方案，考虑到还算比较有普遍性，因此总结形成这篇文章。</p>
<h2 id="从-pip-install-说起"><a href="#从-pip-install-说起" class="headerlink" title="从 pip install 说起"></a>从 pip install 说起</h2><p>先不那么简单地描述下背景。</p>
<p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>作为一款接口测试工具，需要具有灵活的命令行调用方式，因此最好能在系统中进行安装并注册为一个<code>CLI</code>命令。</p>
<p>在Python中，安装依赖库的最佳方式是采用<a href="https://pip.pypa.io/en/stable/" target="_blank" rel="external"><code>pip</code></a>，例如安装<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>时，就可以采用如下命令搞定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pip install locustio</div><div class="line">Collecting locustio</div><div class="line">  Using cached locustio-0.7.5.tar.gz</div><div class="line">[...]</div><div class="line">Successfully installed locustio-0.7.5</div></pre></td></tr></table></figure>
<p>但要想采用<code>pip install SomePackage</code>的方式，前提是<code>SomePackage</code>已经托管在<code>PyPI</code>。关于<code>PyPI</code>，可以理解为<code>Python</code>语言的第三方库的仓库索引，当前绝大多数流行的<code>Python</code>第三方库都托管在<code>PyPI</code>上。</p>
<p>但是，这里存在一个问题。在<code>PyPI</code>当中，所有的包都是由其作者自行上传的。如果作者比较懒，那么可能托管在<code>PyPI</code>上的最新版本相较于最新代码就会比较滞后。</p>
<p><code>Locust</code>就是一个典型的例子。从上面的安装过程可以看出，我们采用<code>pip install locustio</code>安装的<code>Locust</code>版本是<code>v0.7.5</code>，而在<code>Locust</code>的<code>Github</code>仓库中，<code>v0.7.5</code>已经是一年之前的版本了。也是因为这个原因，之前在我的博客里面介绍<code>Locust</code>的<a href="http://debugtalk.com/post/head-first-locust-user-guide/">图表展示功能</a>后，已经有不下5个人向我咨询为啥他们看不到这个图表模块。这是因为<code>Locust</code>的图表模块是在今年（2017）年初时添加的功能，master分支的代码版本也已经升级到<code>v0.8a2</code>了，但<code>PyPI</code>上的版本却一直没有更新。</p>
<p>而要想使用到项目最新的功能，就只能采用源码进行安装。</p>
<p>大多数编程语言在使用源码进行安装时，都需要先将源码下载到本地，然后通过命令进行编译，例如<code>Linux</code>中常见的<code>make &amp;&amp; make install</code>。对于<code>Python</code>项目来说，也可以采用类似的模式，先将项目<code>clone</code>到本地，然后进入到项目的根目录，执行<code>python setup.py install</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/locustio/locust.git</div><div class="line">$ cd locust</div><div class="line">$ python setup.py install</div><div class="line">[...]</div><div class="line">Finished processing dependencies for locustio==0.8a2</div></pre></td></tr></table></figure>
<p>不过，要想采用这种方式进行安装也是有前提的，那就是项目必须已经实现了基于<code>setuptools</code>的安装方式，并在项目的根目录下存在<code>setup.py</code>。</p>
<p>可以看出，这种安装方式还是比较繁琐的，需要好几步才能完成安装。而且，对于大多数使用者来说，他们并不需要阅读项目源码，因此<code>clone</code>操作也实属多余。</p>
<p>可喜的是，<code>pip</code>不仅支持安装<code>PyPI</code>上的包，也可以直接通过项目的<code>git</code>地址进行安装。还是以<code>Locust</code>项目为例，我们通过<code>pip</code>命令也可以实现一条命令安装<code>Github</code>项目源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/locustio/locust.git@master#egg=locustio</div><div class="line">Collecting locustio from git+https://github.com/locustio/locust.git@master#egg=locustio</div><div class="line">[...]</div><div class="line">Successfully installed locustio-0.8a2</div></pre></td></tr></table></figure>
<p>对于项目地址来说，完整的描述应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install vcs+protocol://repo_url/#egg=pkg&amp;subdirectory=pkg_dir</div></pre></td></tr></table></figure>
<p>这里的<code>vcs</code>也不仅限于<code>git</code>，<code>svn</code>和<code>hg</code>也是一样的，而<code>protocol</code>除了采用<code>SSH</code>形式的项目地址，也可以采用<code>HTTPS</code>的地址，在此不再展开。</p>
<p>通过这种方式，我们就总是可以使用到项目的最新功能特性了。当然，前提条件也是一样的，需要项目中已经实现了<code>setup.py</code>。</p>
<p>考虑到<code>ApiTestEngine</code>还处于频繁的新特性开发阶段，因此这种途径无疑是让用户安装使用最新代码的最佳方式。</p>
<h2 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h2><p>在<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>中，存在测试结果报告展示这一部分的功能，而这部分的功能是需要依赖于另外一个托管在GitHub上的项目，<a href="https://github.com/debugtalk/PyUnitReport" target="_blank" rel="external"><code>PyUnitReport</code></a>。</p>
<p>于是，问题就变为：如何构造<code>ApiTestEngine</code>项目的<code>setup.py</code>，可以实现用户在安装<code>ApiTestEngine</code>时自动安装<code>PyUnitReport</code>依赖。</p>
<p>对于这个需求，已经确定可行的办法：先通过<code>pip</code>安装依赖的库（<code>PyUnitReport</code>），然后再安装当前项目（<code>ApiTestEngine</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport</div><div class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div></pre></td></tr></table></figure>
<p>这种方式虽然可行，但是需要执行两条命令，显然不是我们想要的效果。</p>
<p>经过搜索，发现针对该需求，可以在<code>setuptools.setup()</code>中通过<code>install_requires</code>和<code>dependency_links</code>这两个配置项组合实现。</p>
<p>具体地，配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">install_requires=[</div><div class="line">   &quot;requests&quot;,</div><div class="line">   &quot;flask&quot;,</div><div class="line">   &quot;PyYAML&quot;,</div><div class="line">   &quot;coveralls&quot;,</div><div class="line">   &quot;coverage&quot;,</div><div class="line">   &quot;PyUnitReport&quot;</div><div class="line">],</div><div class="line">dependency_links=[</div><div class="line">   &quot;git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport&quot;</div><div class="line">],</div></pre></td></tr></table></figure>
<p>这里有一点需要格外注意，那就是指定的依赖包如果存在于<code>PyPI</code>，那么只需要在<code>install_requires</code>中指定包名和版本号即可（不指定版本号时，默认安装最新版本）；而对于以仓库URL地址存在的依赖包，那么不仅需要在<code>dependency_links</code>中指定，同时也要在<code>install_requires</code>中指定。</p>
<p>然后，就可以直接通过<code>ApiTestEngine</code>项目的git地址一键进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div></pre></td></tr></table></figure>
<p>虽然在寻找解决办法的过程中，看到大家都在说<code>dependency_links</code>由于安全性的问题，即将被弃用，而且在<code>setuptools</code>的官方文章中的确也没有看到<code>dependency_links</code>的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEPRECATION: Dependency Links processing has been deprecated and will be removed in a future release.</div></pre></td></tr></table></figure>
<p>不过在我本地的<code>macOS</code>系统上尝试发现，该种方式的确是可行的，因此就采用这种方式进行发布了。</p>
<p>但是当我后续在<code>Linux</code>服务器上安装时，却无法成功，总是在安装<code>PyUnitReport</code>依赖库的时候报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div><div class="line">[...]</div><div class="line">Collecting PyUnitReport (from ApiTestEngine)</div><div class="line">  Could not find a version that satisfies the requirement PyUnitReport (from ApiTestEngine) (from versions: )</div><div class="line">No matching distribution found for PyUnitReport (from ApiTestEngine)</div></pre></td></tr></table></figure>
<p>另外，同时也有多个用户反馈了同样的问题，这才发现这种方式在<code>Linux</code>和<code>Windows</code>下是不行的。</p>
<p>然后，再次经过大量的搜索，却始终没有特别明确的答案，搞得我也在怀疑，<code>dependency_links</code>到底是不是真的已经弃用了，但是就算是弃用了，也应该有新的替代方案啊，但也并没有找到。</p>
<p>这个问题就这么放了差不多一个星期的样子。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>今天周末在家，想来想去，不解决始终不爽，虽然只是多执行一条命令的问题。</p>
<p>于是又是经过大量搜索，幸运的是终于从<code>pypa/pip</code>的<code>issues</code>中找到一条<a href="https://github.com/pypa/pip/issues/3610" target="_blank" rel="external"><code>issue</code></a>，作者是<a href="https://github.com/pypa/pip/issues/3610#issue-147115114" target="_blank" rel="external"><code>Dominik Neise</code></a>，他详细描述了他遇到的问题和尝试过的方法，看到他的描述我真是惊呆了，跟我的情况完全一模一样不说，连尝试的思路也完全一致。</p>
<p>然后，在下面的回复中，看到了<a href="https://github.com/pypa/pip/issues/3610#issuecomment-283578756" target="_blank" rel="external"><code>Gary Wu</code></a>和<a href="https://github.com/pypa/pip/issues/3610#issuecomment-317281367" target="_blank" rel="external"><code>kbuilds</code></a>的解答，总算是找到了问题的原因和解决方案。</p>
<p>问题在于，在<code>dependency_links</code>中指定仓库URL地址的时候，在指定<code>egg</code>信息时，<code>pip</code>还同时需要一个版本号（<code>version number</code>），并且以短横线<code>-</code>分隔，然后执行的时候再加上<code>--process-dependency-links</code>参数。</p>
<p>回到之前的<code>dependency_links</code>，我们应该写成如下形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependency_links=[</div><div class="line">   &quot;git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport-0&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>在这里，短横线<code>-</code>后面我并没有填写<code>PyUnitReport</code>实际的版本号，因为经过尝试发现，这里填写任意数值都是成功的，因此我就填写为<code>0</code>了，省得后续在升级<code>PyUnitReport</code>以后还要来修改这个地方。</p>
<p>然后，就可以通过如下命令进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install --process-dependency-links git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div></pre></td></tr></table></figure>
<p>至此，问题总算解决了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>那么，<code>dependency_links</code>到底是不是要废弃了呢？</p>
<p>从<code>pip</code>的<code>GitHub</code>项目中看到这么一个<a href="https://github.com/pypa/pip/issues/4187" target="_blank" rel="external"><code>issue</code></a>，<code>--process-dependency-links</code>之前废弃了一段时间，但是又给加回来了，因为当前还没有更好的可替代的方案。因此，在出现替代方案之前，<code>dependency_links</code>应该是最好的方式了吧。</p>
<p>最后再感叹下，老外提问时描述问题的专业性和细致程度真是令人佩服，大家可以再仔细看下这个<a href="https://github.com/pypa/pip/issues/3610#issue-147115114" target="_blank" rel="external"><code>issue</code></a>好好感受下。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#dependencies-that-aren-t-in-pypi" target="_blank" rel="external">http://setuptools.readthedocs.io/en/latest/setuptools.html#dependencies-that-aren-t-in-pypi</a></li>
<li><a href="https://pip.pypa.io/en/stable/reference/pip_install/" target="_blank" rel="external">https://pip.pypa.io/en/stable/reference/pip_install/</a></li>
<li><a href="https://github.com/pypa/pip/issues/3610" target="_blank" rel="external">https://github.com/pypa/pip/issues/3610</a></li>
<li><a href="https://github.com/pypa/pip/issues/4187" target="_blank" rel="external">https://github.com/pypa/pip/issues/4187</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发&lt;code&gt;ApiTestEngine&lt;/code&gt;时遇到一个安装包依赖的问题，耗费了不少时间寻找解决方案，考虑到还算比较有普遍性，因此总结形成这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;从-pip-install-说起&quot;&gt;&lt;a href=&quot;#从-pip-install-
    
    </summary>
    
    
      <category term="Locust" scheme="http://debugtalk.com/tags/Locust/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="setuptools" scheme="http://debugtalk.com/tags/setuptools/"/>
    
      <category term="pip" scheme="http://debugtalk.com/tags/pip/"/>
    
  </entry>
  
</feed>
