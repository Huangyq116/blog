<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DebugTalk</title>
  <subtitle>探索一个软件工程师的无限可能</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://debugtalk.com/"/>
  <updated>2017-12-24T01:49:57.000Z</updated>
  <id>http://debugtalk.com/</id>
  
  <author>
    <name>九毫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HttpRunner 的测试用例分层机制</title>
    <link href="http://debugtalk.com/post/HttpRunner-testcase-layer/"/>
    <id>http://debugtalk.com/post/HttpRunner-testcase-layer/</id>
    <published>2017-12-22T16:00:00.000Z</published>
    <updated>2017-12-24T01:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在<code>HttpRunner</code>中，测试用例引擎最大的特色就是支持<code>YAML/JSON</code>格式的用例描述形式。</p>
<p>采用<code>YAML/JSON</code>格式编写维护测试用例，优势还是很明显的：</p>
<ul>
<li>相比于表格形式，具有更加强大的灵活性和更丰富的信息承载能力；</li>
<li>相比于代码形式，减少了不必要的编程语言语法重复，并最大化地统一了用例描述形式，提高了用例的可维护性。</li>
</ul>
<p>以最常见的登录注销为例，我们的测试用例通常会描述为如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> demo-login-logoff</div><div class="line"><span class="attr">    variable_binds:</span></div><div class="line"><span class="attr">        - UserName:</span> test001</div><div class="line"><span class="attr">        - Password:</span> <span class="number">123456</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://xxx.debugtalk.com</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Accept:</span> application/json</div><div class="line"><span class="attr">            User-Agent:</span> iOS/<span class="number">10.3</span></div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Login</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/Login</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            UserName:</span> $UserName</div><div class="line"><span class="attr">            Pwd:</span> $Password</div><div class="line"><span class="attr">            VerCode:</span> <span class="string">""</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Logoff</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/LoginOff</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div></pre></td></tr></table></figure>
<p>相信大家已经对该种用例描述形式十分熟悉了。不过，该种描述形式的问题在于，接口通常会出现在多个测试场景中，而每次都需要对接口进行定义描述，包括请求的URL、Header、Body、以及预期响应值等，这就会产生大量的重复。</p>
<p>例如，在某个项目中存在三个测试场景：</p>
<ul>
<li>场景A：注册新账号（<code>API_1/2</code>）、登录新注册的账号（<code>API_3/4/5</code>）、查看登录状态（<code>API_6</code>）；</li>
<li>场景B：登录已有账号（<code>API_3/4/5</code>）、注销登录（<code>API_7/8</code>）；</li>
<li>场景C：注销登录（<code>API_7/8</code>）、查看登录状态（<code>API_6</code>）、注册新账号（<code>API_1/2</code>）。</li>
</ul>
<p>按照常规的接口测试用例编写方式，我们需要创建3个场景文件，然后在各个文件中分别描述三个测试场景相关的接口信息。示意图如下所示。</p>
<p><img src="/images/httprunner-testcase-layer-1.jpeg" alt=""></p>
<p>在本例中，接口（<code>API_1/2/6</code>）在场景A和场景C中都进行了定义；接口（<code>API_3/4/5</code>）在场景A和场景B中都进行了定义；接口（<code>API_7/8</code>）在场景B和场景C中都进行了定义。可以预见，当测试场景增多以后，接口定义描述的维护就会变得非常困难和繁琐。</p>
<h2 id="接口的分层定义描述"><a href="#接口的分层定义描述" class="headerlink" title="接口的分层定义描述"></a>接口的分层定义描述</h2><p>那要如何进行优化呢？</p>
<p>其实也很简单，在编程语言中，如果出现重复代码块，我们通常会将其封装为类或方法，然后在需要时进行调用，以此来消除重复。同样地，我们也可以将项目的API进行统一定义，里面包含API的请求和预期响应描述，然后在测试场景中进行引用即可。</p>
<p>示意图如下所示。</p>
<p><img src="/images/httprunner-testcase-layer-2.jpeg" alt=""></p>
<p>具体地，我们可以约定将项目的所有API接口定义放置在<code>api</code>目录下，并在<code>api</code>目录中按照项目的系统模块来组织接口的定义；同时，将测试场景放置到<code>testcases</code>目录中。</p>
<p>此时测试用例文件的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">✗ tree tests</div><div class="line">tests</div><div class="line">├── api</div><div class="line">│   └── v1</div><div class="line">│       ├── Account.yml</div><div class="line">│       ├── BusinessTrip.yml</div><div class="line">│       ├── Common.yml</div><div class="line">│       └── Leave.yml</div><div class="line">├── debugtalk.py</div><div class="line">└── testcases</div><div class="line">    ├── scenario_A.yml</div><div class="line">    ├── scenario_B.yml</div><div class="line">    └── scenario_C.yml</div></pre></td></tr></table></figure>
<p>而对于API接口的定义，与之前的描述方式基本一致，只做了两点调整：</p>
<ul>
<li>接口定义块（<code>block</code>）的标识为<code>api</code>；</li>
<li>接口定义块中包含<code>def</code>字段，形式为<code>api_name(*args)</code>，作为接口的唯一标识ID；需要注意的是，即使<code>api</code>没有参数，也需要带上括号，<code>api_name()</code>；这和编程语言中定义函数是一样的。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- api:</span></div><div class="line"><span class="attr">    def:</span> api_v1_Account_Login_POST($UserName, $Password)</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/Login</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            UserName:</span> $UserName</div><div class="line"><span class="attr">            Pwd:</span> $Password</div><div class="line"><span class="attr">            VerCode:</span> <span class="string">""</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div><div class="line"></div><div class="line"><span class="attr">- api:</span></div><div class="line"><span class="attr">    def:</span> api_v1_Account_LoginOff_GET()</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/v1/Account/LoginOff</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, <span class="number">200</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.IsSuccess"</span>, <span class="literal">True</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"content.Code"</span>, <span class="number">200</span>]</div></pre></td></tr></table></figure>
<p>有了接口的定义描述后，我们编写测试场景时就可以直接引用接口定义了。</p>
<p>同样是背景描述中的登录注销场景，测试用例就描述为变为如下形式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> demo</div><div class="line"><span class="attr">    variable_binds:</span></div><div class="line"><span class="attr">        - UserName:</span> test001</div><div class="line"><span class="attr">        - Password:</span> <span class="number">123456</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://xxx.debugtalk.com</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Accept:</span> application/json</div><div class="line"><span class="attr">            User-Agent:</span> iOS/<span class="number">10.3</span></div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Login</div><div class="line"><span class="attr">    api:</span> api_v1_Account_Login_POST($UserName, $Password)</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> Logoff</div><div class="line"><span class="attr">    api:</span> api_v1_Account_LoginOff_GET()</div></pre></td></tr></table></figure>
<p>不难看出，对API接口进行分层定义后，我们在测试用例场景中引用接口定义时，与编程语言里面调用函数的形式基本完全一样，只需要指定接口的名称，以及所需传递的参数值；同样的，即使没有参数，也需要带上括号。</p>
<p>实现接口的分层定义描述后，我们就可以避免接口的重复定义。但是，我们回过头来看之前的案例，发现仍然会存在一定的重复。</p>
<p><img src="/images/httprunner-testcase-layer-3.jpeg" alt=""></p>
<p>如上图所示，场景A和场景C都包含了注册新账号（<code>API_1/2</code>）和查看登录状态（<code>API_6</code>），场景A和场景B都包含了登录已有账号（<code>API_3/4/5</code>），场景B和场景C都包含了注销登录（<code>API_7/8</code>）。</p>
<p>虽然我们已经将接口的定义描述抽离出来，避免了重复的定义；但是在实际业务场景中，某些功能（例如登录、注销）会在多个场景中重复出现，而该功能又涉及到多个接口的组合调用，这同样也会出现大量的重复。</p>
<h2 id="接口的模块化封装"><a href="#接口的模块化封装" class="headerlink" title="接口的模块化封装"></a>接口的模块化封装</h2><p>玩过积木的同学可能就会想到，我们也可以将系统的常用功能封装为模块（suite），只需要在模块中定义一次，然后就可以在测试场景中重复进行引用，从而避免了模块功能的重复描述。</p>
<p><img src="/images/httprunner-testcase-layer-4.jpeg" alt=""></p>
<p>具体地，我们可以约定将项目的所有模块定义放置在<code>suite</code>目录下，并在<code>suite</code>目录中按照项目的功能来组织模块的定义。</p>
<p>后续，我们在<code>testcases</code>目录中描述测试场景时，就可同时引用接口定义和模块定义了；模块和接口的混合调用，必将为我们编写测试场景带来极大的灵活性。</p>
<p>此时测试用例文件的目录结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">✗ tree tests</div><div class="line">tests</div><div class="line">├── api</div><div class="line">│   └── v1</div><div class="line">│       ├── Account.yml</div><div class="line">│       ├── BusinessTrip.yml</div><div class="line">│       ├── Common.yml</div><div class="line">│       └── Leave.yml</div><div class="line">├── debugtalk.py</div><div class="line">├── suite</div><div class="line">│   ├── BusinessTravelApplication</div><div class="line">│   │   ├── approve-application.yml</div><div class="line">│   │   ├── executive-application.yml</div><div class="line">│   │   ├── reject-application.yml</div><div class="line">│   │   └── submit-application.yml</div><div class="line">│   └── LeaveApplication</div><div class="line">│       ├── approve.yml</div><div class="line">│       ├── cancel.yml</div><div class="line">│       └── submit-application.yml</div><div class="line">└── testcases</div><div class="line">    ├── scenario_A.yml</div><div class="line">    ├── scenario_B.yml</div><div class="line">    └── scenario_C.yml</div></pre></td></tr></table></figure>
<p>需要注意的是，我们在组织测试用例描述的文件目录结构时，遵循约定大于配置的原则：</p>
<ul>
<li>API接口定义必须放置在<code>api</code>目录下</li>
<li>模块定义必须放置在<code>suite</code>目录下</li>
<li>测试场景文件必须放置在<code>testcases</code>目录下</li>
<li>相关的函数定义放置在<code>debugtalk.py</code>中</li>
</ul>
<p>至此，我们实现了测试用例的<code>接口-模块-场景</code>分层，从而彻底避免了重复定义描述。</p>
<h2 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h2><p>得益于约定大于配置的原则，在<code>HttpRunner</code>中实现了一个脚手架工具，可以快速创建项目的目录结构。该想法来源于<code>Django</code>的<code>django-admin.py startproject project_name</code>。</p>
<p>使用方式也与<code>Django</code>类似，只需要通过<code>--startproject</code>指定新项目的名称即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ hrun --startproject helloworld</div><div class="line">INFO:root: Start to create new project: /Users/Leo/MyProjects/helloworld</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/api</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/suite</div><div class="line">INFO:root:      created folder: /Users/Leo/MyProjects/helloworld/tests/testcases</div><div class="line">INFO:root:      created file: /Users/Leo/MyProjects/helloworld/tests/debugtalk.py</div></pre></td></tr></table></figure>
<p>运行之后，就会在指定的目录中生成新项目的目录结构，接下来，我们就可以按照测试用例的<code>接口-模块-场景</code>分层原则往里面添加用例描述信息了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果看到这里你还不明白测试用例分层的必要性，那也没关系，测试用例分层不是必须的，你还是可以按照之前的方式组织测试用例。不过当你某一天发现需要进行分层管理时，你会发现它就在那里，很实用。</p>
<p>最后，在<code>HttpRunner</code>项目的<a href="https://github.com/HttpRunner/HttpRunner/tree/master/examples/HelloWorld" target="_blank" rel="external"><code>examples/HelloWorld</code></a>目录中，包含了一份完整的分层测试用例示例，相信会对大家有所帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;HttpRunner&lt;/code&gt;中，测试用例引擎最大的特色就是支持&lt;code&gt;YAML/JSON&lt;/code
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="testcase" scheme="http://debugtalk.com/tags/testcase/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 的结果校验器优化</title>
    <link href="http://debugtalk.com/post/HttpRunner-validator-optimization/"/>
    <id>http://debugtalk.com/post/HttpRunner-validator-optimization/</id>
    <published>2017-12-12T16:00:00.000Z</published>
    <updated>2017-12-13T15:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在测试用例中，包含预期结果这么一项，用于辅助测试人员执行测试用例时判断系统的功能是否正常。而在自动化测试中，我们的目标是让测试用例自动执行，因此自动化测试用例中同样需要包含预期结果一项，只不过系统响应结果不再由人工来进行判断，而是交由测试工具或框架来实现。</p>
<p>这部分功能对应的就是测试结果校验器（validator），基本上能称得上自动化测试工具或框架的都包含该功能特性。</p>
<h2 id="设计之初"><a href="#设计之初" class="headerlink" title="设计之初"></a>设计之初</h2><p><code>HttpRunner</code>在设计之初，结果校验器（validator）的实现比较简单。</p>
<p>对于每一个<code>test</code>，可以指定0个或多个校验项，放置在<code>validate</code>中。在自动化测试执行的时候，会在发起HTTP请求、解析结果响应之后，逐个检查各个校验项，若存在任意校验项不通过的情况，则该<code>test</code>将终止并被标记为失败。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expect"</span>: <span class="number">16</span>&#125;</div></pre></td></tr></table></figure>
<p>如上例所示，每一个校验项均为一个<code>json</code>结构，里面包含<code>check</code>、<code>expect</code>、<code>comparator</code>三个属性字段。其中，<code>check</code>对应着要检查的字段，<code>expect</code>对应着检查字段预期的值，这两项是必须指定的；<code>comparator</code>字段对应着比较方法，若不指定，则默认采用<code>eq</code>，即检查字段与预期值相等。</p>
<p>为了实现尽可能强大的检查功能，<code>check</code>属性值可通过链式操作精确指定具体的字段，<code>comparator</code>也内置实现了大量的检查功能。</p>
<p>举个例子可能会更清晰些。假如某结构的响应结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// status code: 200</div><div class="line"></div><div class="line">// response headers</div><div class="line">&#123;</div><div class="line">   "Content-Type": "application/json"</div><div class="line">&#125;</div><div class="line"></div><div class="line">// response body content</div><div class="line">&#123;</div><div class="line">   "success": False,</div><div class="line">   "person": &#123;</div><div class="line">       "name": &#123;</div><div class="line">           "first_name": "Leo",</div><div class="line">           "last_name": "Lee",</div><div class="line">       &#125;,</div><div class="line">       "age": 29,</div><div class="line">       "cities": ["Guangzhou", "Shenzhen"]</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么假如我们要检查<code>status code</code>，<code>check</code>就可以指定为<code>status_code</code>；假如要检查<code>response headers</code>中的<code>Content-Type</code>，<code>check</code>就可以指定为<code>headers.content-type</code>；假如要检查<code>response body</code>中的<code>first_name</code>，<code>check</code>就可以指定为<code>content.person.name.first_name</code>。可以看出，假如下一层级为字典结构，那么就可以通过<code>.</code>运算符指定下一层级的<code>key</code>，依次类推。</p>
<p>对于字段内容为列表<code>list</code>的情况略有不同，我们需要通过序号来指定具体检查哪一项内容。例如，<code>Guangzhou</code>对应的检查项为<code>content.person.cities.0</code>，<code>Shenzhen</code>对应的检查项为<code>content.person.cities.1</code>。</p>
<p>在比较方式（<code>comparator</code>）方面，<code>HttpRunner</code>除了<code>eq</code>，还内置了大量的检查方法。例如，我们可以通过<code>gt</code>、<code>ge</code>、<code>lt</code>、<code>le</code>等比较数值大小，通过<code>len_eq</code>、<code>len_gt</code>、<code>len_lt</code>等比较长度是否相等（列表、字典、字符串均适用），通过<code>contains</code>、<code>contained_by</code>来判断包含关系，通过<code>startswith</code>、<code>endswith</code>判断字符串的开头结尾，甚至通过<code>regex_match</code>来判断是否满足正则匹配等。详细的比较方式还有许多，需要时可查看<a href="http://httprunner.readthedocs.io/en/latest/write-testcases.html#comparator" target="_blank" rel="external">comparator</a>表格。</p>
<h2 id="存在的局限性"><a href="#存在的局限性" class="headerlink" title="存在的局限性"></a>存在的局限性</h2><p>在大多数情况下，<code>HttpRunner</code>的结果校验器（validator）是够用的。不过问题在于，框架不可能为用户实现所有的检查方法，假如用户需要某些特殊的检查方法时，<code>HttpRunner</code>就没法实现了。</p>
<p>这的确是一个问题，之前<code>Junho2010</code>提的issue <a href="https://github.com/HttpRunner/HttpRunner/issues/29" target="_blank" rel="external">#29</a>中举了一个例子，应该也算是比较有代表性。</p>
<blockquote>
<p>发送请求时的数据使用了随机生成，然后需要比较结果中的数据是否是和这个相关（通过某个算法转换）。比如我输入的是321，我的结果是<code>(3+2+1) * avg(3+2+1)</code>这种转化，目前的comparator是比较难于实现的。</p>
</blockquote>
<p>要解决这个问题，最好的方式应该是在<code>HttpRunner</code>中实现自定义结果校验器的机制；用户在有需要的时候，可以自己编写校验函数，然后在<code>validate</code>中引用校验函数。之前也介绍过<code>HttpRunner</code>的热加载机制，<a href="http://debugtalk.com/post/apitestengine-hot-plugin/">《约定大于配置：ApiTestEngine实现热加载机制》</a>，自定义结果校验器应该也是可以采用这种方式来实现的。</p>
<p>第二个需要优化的点，<code>HttpRunner</code>的结果校验器还不支持变量引用，会造成某些场景下的局限性。例如，<code>testwangchao</code>曾提过一个issue <a href="https://github.com/HttpRunner/HttpRunner/issues/52" target="_blank" rel="external">#52</a>：</p>
<blockquote>
<p>接口response内，会返回数据库内的自增ID。ID校验的时候，希望<code>expected</code>为参数化的值。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">validate:</span></div><div class="line"><span class="bullet">    -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.data.table_list.0.id"</span>, <span class="string">"expected"</span>: <span class="string">"$id"</span>&#125;</div></pre></td></tr></table></figure>
<p>另外，在<a href="http://debugtalk.com/post/apitestengine-not-only-about-json-api/">《ApiTestEngine，不再局限于API的测试》</a>一文中有介绍过，结果提取器（<code>extract</code>）新增实现了通过正则表达式对任意文本响应内容的字段提取。考虑到结果校验器（<code>validate</code>）也需要先从结果响应中提取出特定字段才能与预期值进行比较，在具体实现上完全可以复用同一部分代码，因此在<code>validate</code>的<code>check</code>部分也可以进行统一化处理。</p>
<p>经过前面的局限性问题描述，我们的改造目标也明确了，主要有三个方面：</p>
<ul>
<li>新增支持自定义结果校验器</li>
<li>结果校验器中实现变量引用</li>
<li>结果校验内容新增支持正则表达式提取</li>
</ul>
<h2 id="改造结果"><a href="#改造结果" class="headerlink" title="改造结果"></a>改造结果</h2><p>具体的改造过程就不写了，有兴趣的同学可以直接阅读源码，重点查看<a href="https://github.com/HttpRunner/HttpRunner/blob/master/httprunner/context.py" target="_blank" rel="external"><code>httprunner/context.py</code></a>中的<code>parse_validator</code>、<code>do_validation</code>和<code>validate</code>三个函数。</p>
<p>经过优化后，改造目标中的三项功能都实现了。为了更好地展现改造后的结果校验器，此处将结合实例进行演示。</p>
<h3 id="新增支持自定义结果校验器"><a href="#新增支持自定义结果校验器" class="headerlink" title="新增支持自定义结果校验器"></a>新增支持自定义结果校验器</h3><p>先来看第一个优化项，新增支持自定义结果校验器。</p>
<p>假设我们需要使用HTTP响应状态码各个数字的和来进行校验，例如，<code>201</code>状态码对应的数字和为3，<code>503</code>状态码对应的数字和为8。该实例只是为了演示用，实际上并不会用到这样的校验方式。</p>
<p>首先，该种校验方式在<code>HttpRunner</code>中并没有内置，因此需要我们自己来实现。实现方式与热加载机制相同，只需要将自定义的校验函数放置到当前<code>YAML/JSON</code>文件同级或者父级目录的<code>debugtalk.py</code>中。</p>
<p>对于自定义的校验函数，需要遵循三个规则：</p>
<ul>
<li>自定义校验函数需放置到<code>debugtalk.py</code>中</li>
<li>参数有两个：第一个为原始数据，第二个为原始数据经过运算后得到的预期结果值</li>
<li>在校验函数中通过<code>assert</code>将实际运算结果与预期结果值进行比较</li>
</ul>
<p>对于前面提到的演示案例，我们就可以在<code>debugtalk.py</code>中编写如下校验函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_status_code</span><span class="params">(status_code, expect_sum)</span>:</span></div><div class="line">    <span class="string">""" sum status code digits</span></div><div class="line">        e.g. 400 =&gt; 4, 201 =&gt; 3</div><div class="line">    """</div><div class="line">    sum_value = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> str(status_code):</div><div class="line">        sum_value += int(digit)</div><div class="line"></div><div class="line">    <span class="keyword">assert</span> sum_value == expect_sum</div></pre></td></tr></table></figure>
<p>然后，在<code>YAML/JSON</code>格式测试用例的<code>validate</code>中，我们就可以将校验函数名称<code>sum_status_code</code>作为<code>comparator</code>进行使用了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"sum_status_code"</span>, <span class="string">"expect"</span>: <span class="number">2</span>&#125;</div></pre></td></tr></table></figure>
<p>由此可见，自定义的校验函数<code>sum_status_code</code>与<code>HttpRunner</code>内置的校验方法<code>eq</code>在使用方式上完全相同，应该没有理解上的难度。</p>
<h3 id="结果校验器中实现变量引用"><a href="#结果校验器中实现变量引用" class="headerlink" title="结果校验器中实现变量引用"></a>结果校验器中实现变量引用</h3><p>对于第二个优化项，结果校验器中实现变量引用。在使用方式上我们应该与<code>request</code>中的变量引用一致，即通过<code>$var</code>的方式来引用变量<code>var</code>。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - expect_status_code:</span> <span class="number">200</span></div><div class="line"><span class="attr">        - token_len:</span> <span class="number">16</span></div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="string">"$expect_status_code"</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expect"</span>: <span class="string">"$token_len"</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"$token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expect"</span>: <span class="string">"$token_len"</span>&#125;</div></pre></td></tr></table></figure>
<p>通过以上示例可以看出，在结果校验器<code>validate</code>中，<code>check</code>和<code>expect</code>均可实现实现变量的引用；而引用的变量，可以来自四种类型：</p>
<ul>
<li>当前<code>test</code>中定义的<code>variables</code>，例如<code>expect_status_code</code></li>
<li>当前<code>test</code>中提取（<code>extract</code>）的结果变量，例如<code>token</code></li>
<li>当前测试用例集<code>testset</code>中，先前<code>test</code>中提取（<code>extract</code>）的结果变量</li>
<li>当前测试用例集<code>testset</code>中，全局配置<code>config</code>中定义的变量</li>
</ul>
<p>而<code>check</code>字段除了可以引用变量，以及保留了之前的链式操作定位字段（例如上例中的<code>content.token</code>）外，还新增了采用正则表达式提取内容的方式，也就是第三个优化项。</p>
<h3 id="结果校验内容新增支持正则表达式提取"><a href="#结果校验内容新增支持正则表达式提取" class="headerlink" title="结果校验内容新增支持正则表达式提取"></a>结果校验内容新增支持正则表达式提取</h3><p>假设如下接口的响应结果内容为<code>LB123abcRB789</code>，那么要提取出<code>abc</code>部分进行校验，就可以采用如下描述方式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"LB123(.*)RB789"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expect"</span>: <span class="string">"abc"</span>&#125;</div></pre></td></tr></table></figure>
<p>可见在使用方式上与在结果提取器（<code>extract</code>）中完全相同。</p>
<h3 id="结果校验器的进一步简化"><a href="#结果校验器的进一步简化" class="headerlink" title="结果校验器的进一步简化"></a>结果校验器的进一步简化</h3><p>最后，为了进一步简化结果校验的描述，我在<code>validate</code>中新增实现了一种描述方式。</p>
<p>简化后的描述方式与原始方式对比如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">validate:</span></div><div class="line"><span class="attr">    - comparator_name:</span> [check_item, expect_value]</div><div class="line"><span class="bullet">    -</span> &#123;<span class="string">"check"</span>: check_item, <span class="string">"comparator"</span>: comparator_name, <span class="string">"expect"</span>: expect_value&#125;</div></pre></td></tr></table></figure>
<p>同样是前面的例子，采用新的描述方式后会更加简洁。而两种方式表达的含义是完全等价的。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"status_code"</span>, $expect_status_code]</div><div class="line"><span class="attr">        - sum_status_code:</span> [<span class="string">"status_code"</span>, <span class="number">2</span>]</div><div class="line"><span class="attr">        - len_eq:</span> [<span class="string">"$token"</span>, $token_len]</div><div class="line"><span class="attr">        - len_eq:</span> [<span class="string">"content.token"</span>, <span class="number">16</span>]</div><div class="line"><span class="attr">        - eq:</span> [<span class="string">"LB123(.*)RB789"</span>, <span class="string">"abc"</span>]</div></pre></td></tr></table></figure>
<p>当然，此次优化保证了与历史版本的兼容，之前编写的测试用例脚本的运行是完全不会受到任何影响的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在测试用例中，包含预期结果这么一项，用于辅助测试人员执行测试用例时判断系统的功能是否正常。而在自动化测试中，我们的目标是让测试用例自动执行，因此自动化测试用例中同样需要包含预期结果一项，只不过系统响应结果不再由人工来进行判断，而是交由测试工具或框架来实现。&lt;/p&gt;
&lt;p&gt;这
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="validator" scheme="http://debugtalk.com/tags/validator/"/>
    
  </entry>
  
  <entry>
    <title>HttpRunner 支持 HAR 意味着什么？</title>
    <link href="http://debugtalk.com/post/HttpRunner-supports-HAR/"/>
    <id>http://debugtalk.com/post/HttpRunner-supports-HAR/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-11-14T16:23:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HttpRunner</code>开始支持<code>HAR</code>啦！！！</p>
<p>如果你还没有体会到这三个感叹号的含义，那们你可能对<code>HAR</code>还不了解。</p>
<h2 id="HAR-是什么？"><a href="#HAR-是什么？" class="headerlink" title="HAR 是什么？"></a>HAR 是什么？</h2><p><code>HAR</code>的全称为<code>HTTP Archive</code>，是<a href="https://www.w3.org/" target="_blank" rel="external"><code>W3C(World Wide Web Consortium)</code></a>发布的一个通用标准。简单地说，<code>HAR</code>是一个约定的<code>JSON</code>文件格式，用于记录<code>HTTP</code>请求交互的所有内容，包括请求响应的详细记录和性能度量数据。</p>
<p>虽然当前<code>HAR</code>标准还处于<code>Draft</code>状态，但它已经被业界广泛地采用了，许多我们日常使用的工具都已支持<code>HAR</code>。在下面罗列的工具中，相信大家都已经比较熟悉了。</p>
<ul>
<li>Fiddler</li>
<li>Charles Web Proxy</li>
<li>Google Chrome</li>
<li>Firebug</li>
<li>HttpWatch</li>
<li>Firefox</li>
<li>Internet Explorer 9</li>
<li>Microsoft Edge</li>
<li>Paw</li>
<li>Restlet Client</li>
</ul>
<p>可以看出，工具覆盖了主流的抓包工具、浏览器和接口测试工具。这些工具都支持<code>HAR</code>标准，可以将录制得到的数据包导出为<code>.har</code>的文件。</p>
<p>假如我们可以将<code>HAR</code>格式转换为<code>HttpRunner</code>的自动化测试用例，这就相当于<code>HttpRunner</code>可以和非常多的工具结合使用，并获得了接口录制和用例生成功能，灵活性和易用性都将得到极大的提升。</p>
<p>那么，将<code>HAR</code>格式转换为<code>HttpRunner</code>的自动化测试用例是否可行呢？</p>
<p>我们不妨先研究下<code>HAR</code>的格式。</p>
<h2 id="HAR-格式详解"><a href="#HAR-格式详解" class="headerlink" title="HAR 格式详解"></a>HAR 格式详解</h2><p>通过如上列出的任意一款工具，都可以将录制得到的数据包导出为<code>.har</code>的文件。我们采用文本编辑器打开<code>.har</code>文件后，会发现是一个<code>JSON</code>的数据结构。</p>
<p>默认情况下，<code>.har</code>文件的<code>JSON</code>数据结构是经过压缩的，直接看可能不够直观。推荐大家可以在文本编辑器中安装<code>Prettify JSON</code>的插件，然后就可以将压缩后的<code>JSON</code>数据一键转换为美观的格式。</p>
<p>更好的方式是，我们可以直接查看<code>W3C</code>编写的<a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/HAR/Overview.html" target="_blank" rel="external"><code>HAR</code>格式标准</a>。</p>
<p>通过文档可知，<code>HAR</code>是只有一个key的<code>JSON</code>数据结构，并且key值只能为<code>log</code>；而<code>log</code>的值也为一个<code>JSON</code>结构，里面的key包括：<code>version</code>、<code>creator</code>、<code>browser</code>、<code>pages</code>、<code>entries</code>、<code>comment</code>。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"log"</span>: &#123;</div><div class="line">        <span class="attr">"version"</span>: <span class="string">""</span>,</div><div class="line">        <span class="attr">"creator"</span>: &#123;&#125;,</div><div class="line">        <span class="attr">"browser"</span>: &#123;&#125;,</div><div class="line">        <span class="attr">"pages"</span>: [],</div><div class="line">        <span class="attr">"entries"</span>: [],</div><div class="line">        <span class="attr">"comment"</span>: <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>version</code>、<code>creator</code>和<code>entries</code>是必有字段，不管是哪款工具导出的<code>.har</code>文件，肯定都会包含这三个字段。而我们在转换生成自动化测试用例时，只需获取HTTP请求和响应的内容，这些全都包含在<code>entries</code>里面，因此我们只需要关注<code>entries</code>的内容即可。</p>
<p><code>entries</code>字段对应的值为一个列表型数据结构，里面的值按照请求时间进行排序，罗列出各个HTTP请求的详细内容。具体地，HTTP请求记录的信息如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">"entries": [</div><div class="line">    &#123;</div><div class="line">        "pageref": "page_0",</div><div class="line">        "startedDateTime": "2009-04-16T12:07:23.596Z",</div><div class="line">        "time": 50,</div><div class="line">        "request": &#123;...&#125;,</div><div class="line">        "response": &#123;...&#125;,</div><div class="line">        "cache": &#123;...&#125;,</div><div class="line">        "timings": &#123;&#125;,</div><div class="line">        "serverIPAddress": "10.0.0.1",</div><div class="line">        "connection": "52492",</div><div class="line">        "comment": ""</div><div class="line">    &#125;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>由此可见，记录的HTTP信息非常全面，包含了HTTP请求交互过程中的所有内容。</p>
<p>而从生成自动化测试用例的角度来看，我们并不需要那么多信息，我们只需从中提取关键信息即可。</p>
<p>编写自动化测试用例，最关键的信息是要知道接口的请求URL、请求方法、请求headers、请求数据等，这些都包含在<code>request</code>字段对应的字典中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">"request": &#123;</div><div class="line">    "method": "GET",</div><div class="line">    "url": "http://www.example.com/path/?param=value",</div><div class="line">    "httpVersion": "HTTP/1.1",</div><div class="line">    "cookies": [],</div><div class="line">    "headers": [],</div><div class="line">    "queryString" : [],</div><div class="line">    "postData" : &#123;&#125;,</div><div class="line">    "headersSize" : 150,</div><div class="line">    "bodySize" : 0,</div><div class="line">    "comment" : ""</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据这些信息，我们就可以完成HTTP请求的构造。</p>
<p>当请求发送出去后，我们要想实现自动化地判断接口响应是否正确，我们还需要设置一些断言。而与HTTP响应相关的所有信息全都包含在<code>response</code>字段对应的字典中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">"response": &#123;</div><div class="line">    "status": 200,</div><div class="line">    "statusText": "OK",</div><div class="line">    "httpVersion": "HTTP/1.1",</div><div class="line">    "cookies": [],</div><div class="line">    "headers": [],</div><div class="line">    "content": &#123;&#125;,</div><div class="line">    "redirectURL": "",</div><div class="line">    "headersSize" : 160,</div><div class="line">    "bodySize" : 850,</div><div class="line">    "comment" : ""</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从通用性的角度考虑，我们会判断HTTP响应的状态码是否正确，这对应着<code>status</code>字段；如果我们还想在接口业务层面具有更多的判断，我们还会判断响应内容中的一些关键字段是否符合预期，这对应着<code>content</code>字段。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">"content": &#123;</div><div class="line">    "size": 33,</div><div class="line">    "compression": 0,</div><div class="line">    "mimeType": "text/html; charset=utf-8",</div><div class="line">    "text": "\n",</div><div class="line">    "comment": ""</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>content</code>字段，可能会稍微复杂一些，因为接口响应内容的格式可能多种多样。</p>
<p>例如，响应内容可能<code>text/html</code>页面的形式，也可能是<code>application/json</code>的形式，具体类型可以查看<code>mimeType</code>得到，而具体的内容存储在<code>text</code>字段中。</p>
<p>另外，有时候响应数据还可能是经过编码的，用的最多的编码方式为<code>base64</code>。我们可以根据<code>encoding</code>字段获取得到具体的编码形式，然后采用对应的解码方式对<code>text</code>进行解码，最终获得原始的响应内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">"content": &#123;</div><div class="line">    "size": 63,</div><div class="line">    "mimeType": "application/json; charset=utf-8",</div><div class="line">    "text": "eyJJc1N1Y2Nlc3MiOnRydWUsIkNvZGUiOjIwMCwiVmFsdWUiOnsiQmxuUmVzdWx0Ijp0cnVlfX0=",</div><div class="line">    "encoding": "base64"</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>以上面的<code>content</code>为例，我们通过<code>encoding</code>查看到编码形式为<code>base64</code>，并通过<code>text</code>字段获取到编码后的内容；那么我们就可以采用<code>base64</code>的解码函数，转换得到原始的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import base64</div><div class="line">&gt;&gt;&gt; base64.b64decode(text)</div><div class="line">b<span class="string">'&#123;"IsSuccess":true,"Code":200,"Value":&#123;"BlnResult":true&#125;&#125;'</span></div></pre></td></tr></table></figure>
<p>同时，我们根据<code>mimeType</code>可以得到响应内容<code>application/json</code>数据类型，那么就可以对其再进行<code>json.loads</code>操作，最终得到可供程序处理的<code>JSON</code>数据结构。</p>
<p>通过上述对<code>HAR</code>格式的详细介绍，可以看出<code>HAR</code>格式十分清晰，在对其充分了解的基础上，再编写测试用例转换工具就很简单了。</p>
<h2 id="har2case"><a href="#har2case" class="headerlink" title="har2case"></a>har2case</h2><p>编码过程没有太多值得说的，直接看最终成品吧。</p>
<p>最终产出的工具就是<a href="https://github.com/HttpRunner/har2case" target="_blank" rel="external"><code>har2case</code></a>，是一个命令行工具，可以直接将<code>.har</code>文件转换为<code>YAML</code>或<code>JSON</code>格式的自动化测试用例。</p>
<p>当前<code>har2case</code>已经上传到<code>PYPI</code>上了，通过<code>pip</code>或<code>easy_install</code>即可安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ pip install har2<span class="keyword">case</span></div><div class="line"><span class="comment"># or</span></div><div class="line">$ easy_install har2<span class="keyword">case</span></div></pre></td></tr></table></figure>
<p>使用方式很简单，只需在<code>har2case</code>命令后分别带上<code>HAR</code>源文件路径和目标生成的<code>YAML/JSON</code>路径即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ har2<span class="keyword">case</span> tests/data/demo.har demo.yml</div><div class="line">INFO:root:Generate YAML testset successfully: demo.yml</div><div class="line"></div><div class="line">$ har2<span class="keyword">case</span> tests/data/demo.har demo.json</div><div class="line">INFO:root:Generate JSON testset successfully: demo.json</div></pre></td></tr></table></figure>
<p>可以看出，具体是生成<code>YAML</code>还是<code>JSON</code>格式的问题，取决于指定目标文件的后缀：后缀为<code>.yml</code>或<code>.yaml</code>则生成<code>YAML</code>文件，后缀为<code>.json</code>则生成<code>JSON</code>文件。</p>
<p>如果不指定目标文件也行，则会默认生成<code>JSON</code>文件，文件名称和路径与<code>.har</code>源文件相同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ har2<span class="keyword">case</span> tests/data/demo.har</div><div class="line">INFO:root:Generate JSON testset successfully: tests/data/demo.json</div></pre></td></tr></table></figure>
<p>具体的使用方式可以通过执行<code>har2case -h</code>查看。</p>
<p>在大多数情况下，生成的用例可直接在<code>HttpRunner</code>中使用，当然，是做接口自动化测试、接口性能测试，还是持续集成线上监控，这都取决于你。</p>
<p>不过，假如录制的场景中包含动态关联的情况，即后续接口请求参数依赖于前面接口的响应，并且每次调用接口时参数都会动态变化，那么就需要人工再对生成的脚本进行关联处理，甚至包括编写一些自定义函数等。</p>
<h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><p>读到这里，相信大家应该能体会到文章开头那三个感叹号的含义了，我也的确是带着难以言表的兴奋之情发布这个新功能的。</p>
<p>经过小范围的实际使用，效果很是不错，接口自动化测试用例的编写效率得到了极大的提升。而且，由于<code>HAR</code>本身的开放性，留给用户的选择非常多。</p>
<p>即便如此，我觉得<code>HttpRunner</code>的易用性还可以得到更大的提升。</p>
<p>当前，我规划了两项新特性将在近期完成：</p>
<ul>
<li>支持<code>PostMan</code>：将<code>Postman Collection Format</code>格式转换为<code>HttpRunner</code>支持的<code>YAML/JSON</code>测试用例；</li>
<li>支持<code>Swagger</code>：将<code>Swagger</code>定义的API转换为<code>HttpRunner</code>支持的<code>YAML/JSON</code>测试用例。</li>
</ul>
<p>等这两个新特性完成之后，相信<code>HttpRunner</code>会更上一个台阶。</p>
<p>如果你们有什么更好的想法，欢迎联系我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HttpRunner&lt;/code&gt;开始支持&lt;code&gt;HAR&lt;/code&gt;啦！！！&lt;/p&gt;
&lt;p&gt;如果你还没有体会到这三个感叹号的含义，那们你可能对&lt;code&gt;HAR&lt;/code&gt;还不了解。&lt;/p&gt;
&lt;h2 id=&quot;HAR-是什么？&quot;&gt;&lt;a href=&quot;#HAR
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
      <category term="HAR" scheme="http://debugtalk.com/tags/HAR/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 正式更名为 HttpRunner</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-rename-to-HttpRunner/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-rename-to-HttpRunner/</id>
    <published>2017-11-07T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/apitestengine-not-only-about-json-api/">《ApiTestEngine，不再局限于API的测试》</a>一文的末尾，我提到随着<code>ApiTestEngine</code>的发展，它的实际功能特性和名字已经不大匹配，需要考虑改名了。</p>
<p>经过慎重考虑，最终决定将<code>ApiTestEngine</code>正式更名为<code>HttpRunner</code>。</p>
<h2 id="名字的由来"><a href="#名字的由来" class="headerlink" title="名字的由来"></a>名字的由来</h2><p>为什么选择<code>HttpRunner</code>这个名字呢？</p>
<p>在改名之前，我的想法很明确，就是要在新名字中体现该工具最核心的两个特点：</p>
<ul>
<li>该工具可实现任意基于HTTP协议接口的测试（自动化测试、持续集成、线上监控都是以此作为基础）</li>
<li>该工具可同时实现性能测试（这是区别于其它工具的最大卖点）</li>
</ul>
<p>围绕着这两点，我开始踏上了纠结的取名之路。</p>
<p>首先想到的，<code>ApiTestEngine</code>实现<code>HTTP</code>请求是依赖于<a href="http://python-requests.org" target="_blank" rel="external"><code>Python Requests</code></a>，实现性能测试是依赖于<a href="http://locust.io" target="_blank" rel="external"><code>Locust</code></a>，而<code>Locust</code>同样依赖于<code>Python Requests</code>。可以说，<code>ApiTestEngine</code>完全是构建在<code>Python Requests</code>之上的，后续无论怎么进化，这一层关系应该都不会变。</p>
<p>考虑到<code>Python Requests</code>的<code>slogan</code>是：</p>
<blockquote>
<p>Python HTTP Requests for Humans™</p>
</blockquote>
<p>因此，我想在<code>ApiTestEngine</code>的新名字中应该包含<code>HTTP</code>。</p>
<p>那如何体现性能测试呢？</p>
<p>想到的关键词就<code>load</code>、<code>perf</code>、<code>meter</code>这些（来源于LoadRunner，NeoLoad，JMeter），但又不能直接用，因为名字中带有这些词让人感觉就只是性能测试工具。而且，还要考虑跟<code>HTTP</code>这个词进行搭配。</p>
<p>最终，感觉<code>runner</code>这个词比较合适，一方面这来源于<code>LoadRunner</code>，大众的认可度可能会比较高；同时，这个词用在自动化测试和性能测试上都不会太牵强。</p>
<p>更重要的是，<code>HttpRunner</code>这个组合词当前还没有人用过，不管是<code>PyPI</code>还是<code>GitHub</code>，甚至域名都是可注册状态。</p>
<p>所以，就认定<code>HttpRunner</code>这个名字了。</p>
<h2 id="相关影响"><a href="#相关影响" class="headerlink" title="相关影响"></a>相关影响</h2><p><code>ApiTestEngine</code>更名为<code>HttpRunner</code>之后，会对用户产生哪些影响呢？</p>
<p>先说结论，没有任何不好的影响！</p>
<p>在链接访问方面，受益于GitHub仓库链接的自动重定向机制，仓库在改名或者过户（Transfer ownership）之后，访问原有链接会自动实现重定向，因此之前博客中的链接也都不会受到影响。</p>
<p>新的仓库地址：<a href="https://github.com/HttpRunner/HttpRunner" target="_blank" rel="external">https://github.com/HttpRunner/HttpRunner</a></p>
<p>在使用的命令方面，<code>HttpRunner</code>采用<code>httprunner</code>作为新的命令代替原有的<code>ate</code>命令；当然，为了考虑兼容性，<code>HttpRunner</code>对<code>ate</code>命令也进行了保留，因此<code>httprunner</code>和<code>ate</code>命令同时可用，并完全等价。在性能测试方面，<code>locusts</code>命令保持不变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ httprunner -V</div><div class="line">HttpRunner version: 0.8.1b</div><div class="line">PyUnitReport version: 0.1.3b</div></pre></td></tr></table></figure>
<p>既然是全新的名字，新的篇章必然也得有一些新的东西。</p>
<p>为了方面用户安装，<code>HttpRunner</code>已托管至<a href="https://pypi.python.org/pypi/HttpRunner" target="_blank" rel="external"><code>PyPI</code></a>；后续大家可以方便的采用<code>pip</code>命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install HttpRunner</div></pre></td></tr></table></figure>
<p>同时，<code>HttpRunner</code>新增了大量使用说明文档（之前的博客主要都是开发过程记录），并托管到专业的<code>readthedocs</code>上面。在文档语言方面，英文优先，中文相对滞后。</p>
<p>访问网址：</p>
<ul>
<li>英文：<a href="http://httprunner.readthedocs.io/" target="_blank" rel="external">http://httprunner.readthedocs.io/</a></li>
<li>中文（滞后）：<a href="http://httprunner-cn.readthedocs.io/" target="_blank" rel="external">http://httprunner-cn.readthedocs.io/</a></li>
</ul>
<p>另外，为了具有更高的逼格，同时购入域名<code>httprunner.top</code>，后续将作为项目的主页地址。当前还处于实名认证中，预计2~3个工作日后就可以访问了。</p>
<p>关于项目改名这事儿，就说到这儿吧，希望你们也喜欢。</p>
<blockquote>
<p>Hello World, HttpRunner.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/apitestengine-not-only-about-json-api/&quot;&gt;《ApiTestEngine，不再局限于API的测试》&lt;/a&gt;一文的末尾，我提到随着&lt;code&gt;ApiTestEngine
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine，不再局限于API的测试</title>
    <link href="http://debugtalk.com/post/apitestengine-not-only-about-json-api/"/>
    <id>http://debugtalk.com/post/apitestengine-not-only-about-json-api/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从编写<a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>至今，已经快半年了。在这一段时间内，<code>ApiTestEngine</code>经过持续迭代，也已完全实现了当初预设的目标。</p>
<p>然而，在设计<code>ApiTestEngine</code>之初只考虑了面向最常规的API接口类型，即<code>HTTP</code>响应内容为<code>JSON</code>数据结构的类型。那么，如果<code>HTTP</code>接口响应内容不是<code>JSON</code>，而是<code>XML</code>或<code>SOAP</code>，甚至为<code>HTML</code>呢？</p>
<p>答案是，不支持！</p>
<p>不支持的原因是什么呢？</p>
<p>其实，不管是何种业务类型或者技术架构的系统接口，我们在对其进行测试时都可以拆分为三步：</p>
<ul>
<li>发起接口请求（Request）</li>
<li>解析接口响应（Parse Response）</li>
<li>校验测试结果（Validation）</li>
</ul>
<p>而<code>ApiTestEngine</code>不支持<code>XML/HTML</code>类型的接口，问题恰恰是出现在<code>解析接口响应</code>和<code>校验测试结果</code>这两个环节。考虑到<code>校验测试结果</code>环节是依赖于<code>解析接口响应</code>，即需要先从接口响应结果中解析出具体的字段，才能实现与预期结果的校验检测，因此，制约<code>ApiTestEngine</code>无法支持<code>XML/HTML</code>类型接口的根本原因在于无法支持对<code>XML/HTML</code>的解析。</p>
<p>也因为这个原因，<code>ApiTestEngine</code>存在局限性，没法推广到公司内部的所有项目组。遇到<code>JSON</code>类型以外的接口时，只能再使用别的测试工具，体验上很是不爽。</p>
<p>在经历了一段时间的不爽后，我开始重新思考<code>ApiTestEngine</code>的设计，希望使其具有更大的适用范围。通过前面的分析我们也不难看出，解决问题的关键在于实现针对<code>XML/HTML</code>的解析器。</p>
<h2 id="JSON接口的解析"><a href="#JSON接口的解析" class="headerlink" title="JSON接口的解析"></a>JSON接口的解析</h2><p>在实现<code>XML/HTML</code>的解析器之前，我们不妨先看下<code>ApiTestEngine</code>的<code>JSON</code>解析器是怎么工作的。</p>
<p>在<code>JSON</code>类型的数据结构中，无论结构有多么复杂，数据字段都只可能为如下三种数据类型之一：</p>
<ul>
<li>值（value）类型，包括数字、字符串等；该种数据类型的特点是不会再有下一层极的数据；</li>
<li>字典（dict）类型；该种数据类型的特点是包含无序的下一层极的数据；</li>
<li>列表（list）类型：该种数据类型的特点是包含有序的下一层极的数据。</li>
</ul>
<p>基于这一背景，<code>ApiTestEngine</code>在实现<code>JSON</code>的字段提取器（<code>extractor</code>）时，就采用了点（<code>.</code>）的运算符。</p>
<p>例如，假如<code>HTTP</code>接口响应的<code>headers</code>和<code>body</code>为如下内容：</p>
<p>response headers:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span>,</div><div class="line">    <span class="attr">"Content-Length"</span>: <span class="number">69</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>response body:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"success"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"person"</span>: &#123;</div><div class="line">        <span class="attr">"name"</span>: &#123;</div><div class="line">            <span class="attr">"first_name"</span>: <span class="string">"Leo"</span>,</div><div class="line">            <span class="attr">"last_name"</span>: <span class="string">"Lee"</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">"age"</span>: <span class="number">29</span>,</div><div class="line">        <span class="attr">"cities"</span>: [<span class="string">"Guangzhou"</span>, <span class="string">"Shenzhen"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么对应的字段提取方式就为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;headers.content-type&quot; =&gt; &quot;application/json&quot;</div><div class="line">&quot;headers.content-length&quot; =&gt; 69</div><div class="line">&quot;body.success&quot;/&quot;content.success&quot;/&quot;text.success&quot; =&gt; false</div><div class="line"></div><div class="line">&quot;content.person.name.first_name&quot; =&gt; &quot;Leo&quot;</div><div class="line">&quot;content.person.age&quot; =&gt; 29</div><div class="line">&quot;content.person.cities&quot; =&gt; [&quot;Guangzhou&quot;, &quot;Shenzhen&quot;]</div><div class="line">&quot;content.person.cities.0&quot; =&gt; &quot;Guangzhou&quot;</div><div class="line">&quot;content.person.cities.1&quot; =&gt; &quot;Shenzhen&quot;</div></pre></td></tr></table></figure>
<p>可以看出，通过点（<code>.</code>）运算符，我们可以从上往下逐级定位到具体的字段：</p>
<ul>
<li>当下一级为字典时，通过<code>.key</code>来指定下一级的节点，例如<code>.person</code>，指定了<code>content</code>下的<code>person</code>节点；</li>
<li>当下一级为列表时，通过<code>.index</code>来指定下一级的节点，例如<code>.0</code>，指定了<code>cities</code>下的第一个元素。</li>
</ul>
<p>定位到具体字段后，我们也就可以方便地提取字段值供后续使用了，作为参数或者进行结果校验均可。</p>
<h2 id="实现XML-HTML的解析器"><a href="#实现XML-HTML的解析器" class="headerlink" title="实现XML/HTML的解析器"></a>实现XML/HTML的解析器</h2><p>从点（<code>.</code>）运算符的描述形式上来看，它和<code>XML/HTML</code>的<code>xpath</code>十分类似。既然如此，那我们针对<code>XML/HTML</code>类型的接口，是否可以基于<code>xpath</code>来实现解析器呢？</p>
<p>在大多数情况下的确可以。例如，针对如下HTML页面，当我们要获取标题信息时，我们就可以通过<code>xpath</code>来指定提取字段：<code>body/h1</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>订单页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>订单号：SA89193<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然而，如果我们想获取订单号（SA89193）时，使用<code>xpath</code>就没有办法了（通过<code>body/div/p</code>获取到的是<code>订单号：SA89193</code>，还需进一步地进行处理）。</p>
<p>那除了<code>xpath</code>，我们还能使用什么其它方法从<code>XML/HTML</code>中提取特定字段呢？</p>
<p>由于早些年对<code>LoadRunner</code>比较熟悉，因此我首先想到了<code>LoadRunner</code>的<code>web_reg_save_param</code>函数；在该函数中，我们可以通过指定左右边界（LB &amp; RB）来查找字段，将其提取出来并保存到变量中供后续使用。借鉴这种方式虽然可行，但在描述方式上还是比较复杂，特别是在<code>YAML</code>测试用例的<code>extract</code>中描述的时候。</p>
<p>再一想，这种方式的底层实现不就是正则表达式么。而且我们通过Python脚本解析网页时，采用正则表达式来对目标字段进行匹配和提取，的确也是通用性非常强的方式。</p>
<p>例如，假设我们现在想从<code>http://debugtalk.com</code>首页中提取出座右铭，通过查看网页源代码，我们可以看到座右铭对应的位置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"blog-motto"</span>&gt;</span>探索一个软件工程师的无限可能<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么，要提取“探索一个软件工程师的无限可能”字符串时，我们就可以使用正则表达式<code>r&quot;blog-motto\&quot;&gt;(.*)&lt;/h2&gt;&quot;</code>进行匹配，然后使用<code>regex</code>的<code>group</code>将匹配内容提取出来。</p>
<p>对应的Python脚本实现如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re, requests</div><div class="line">&gt;&gt;&gt; resp = requests.get(<span class="string">"http://debugtalk.com"</span>)</div><div class="line">&gt;&gt;&gt; content = resp.text</div><div class="line">&gt;&gt;&gt; matched = re.search(r<span class="string">"blog-motto\"&gt;(.*)&lt;/h2&gt;"</span>, content)</div><div class="line">&gt;&gt;&gt; matched.group(1)</div><div class="line"><span class="string">'探索一个软件工程师的无限可能'</span></div></pre></td></tr></table></figure>
<p>思路确定后，实现起来就很快了。</p>
<p>此处省略256字。。。</p>
<p>最终，我在<code>ApiTestEngine</code>中新增实现了一个基于正则表达式的提取器。使用形式与JSON解析保持一致，只需要将之前的点（<code>.</code>）运算符更改为正则表达式即可。</p>
<p>还是前面提取座右铭的例子，我们就可以通过<code>YAML</code>格式来编写测试用例。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> demo</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://debugtalk.com/</div><div class="line"><span class="attr">        method:</span> GET</div><div class="line"><span class="attr">    extract:</span></div><div class="line"><span class="attr">        - motto:</span> <span class="string">'blog-motto\"&gt;(.*)&lt;/h2&gt;'</span></div><div class="line"><span class="attr">    validate:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div></pre></td></tr></table></figure>
<p>需要说明的是，指定的正则表达式必须满足<code>r&quot;.*\(.*\).*&quot;</code>的格式要求，必须并且只能有一个分组（即一对括号）。如果在同一段内容中需要提取多个字段，那就分多次匹配即可。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>实现了基于正则表达式的提取器后，我们就彻底实现了对任意格式<code>HTTP</code>响应内容的解析，不仅限于<code>XML/HTML</code>类型，对于任意基于<code>HTTP</code>协议的的接口，<code>ApiTestEngine</code>都可以适用了。当然，如果接口响应是<code>JSON</code>类型，我们虽然可以也使用正则表达式提取，但更建议采用原有的点（<code>.</code>）运算符形式，因为描述更清晰。</p>
<p>至此，<code>ApiTestEngine</code>可以说是真正意义上实现了，面向任意类型的<code>HTTP</code>协议接口，只需要编写维护一份<code>YAML</code>用例，即可同时实现接口自动化测试、性能测试、持续集成、线上监控的全测试类型覆盖！</p>
<p>现在看来，<code>ApiTestEngine</code>的名字与其实际功能有些不大匹配了，是该考虑改名了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从编写&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-api-test-best-prac
    
    </summary>
    
    
      <category term="JSON API" scheme="http://debugtalk.com/tags/JSON-API/"/>
    
      <category term="正则表达式" scheme="http://debugtalk.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>约定大于配置：ApiTestEngine实现热加载机制</title>
    <link href="http://debugtalk.com/post/apitestengine-hot-plugin/"/>
    <id>http://debugtalk.com/post/apitestengine-hot-plugin/</id>
    <published>2017-09-08T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>中编写测试用例时，我们有时需要定义全局的变量，或者引用外部函数实现一些动态的计算逻辑。当前采用的方式是：</p>
<ul>
<li>若需定义全局的参数变量，则要在<code>YAML/JSON</code>的<code>config</code>中，使用<code>variables</code>定义变量；</li>
<li>若需引用外部函数，则要在<code>YAML/JSON</code>的<code>config</code>中，使用<code>import_module_items</code>导入指定的<code>Python</code>模块。</li>
</ul>
<p>虽然这种方式提供了极大的灵活性，但是对于用户来说可能会显得比较复杂。另外一方面，这种方式也会造成大量重复的情况。</p>
<p>例如，对于变量来说，假如我们的项目中存在100个测试场景，而每个场景中都需要将用户账号（<code>test@ijd</code>）作为全局变量来使用，那么在现有模式下，我们只能在这100个<code>YAML/JSON</code>文件的<code>config</code>中都采用如下方式定义一遍：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"smoketest for scenario A."</span></div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - username:</span> test@ijd</div></pre></td></tr></table></figure>
<p>同样的，对于外部函数来说，假如我们项目的100个测试场景都需要用到生成随机字符串的函数（<code>gen_random_string</code>），那么我们也不得不在这100个<code>YAML/JSON</code>文件的<code>config</code>中都导入一次该函数所在的<code>Python</code>模块（假设相对于工作目录的路径为<code>extra/utils.py</code>）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"smoketest for scenario A."</span></div><div class="line"><span class="attr">    import_module_items:</span></div><div class="line"><span class="bullet">        -</span> extra.utils</div></pre></td></tr></table></figure>
<p>由此可见，当测试场景越来越多以后，要维护好全局变量和外部函数，必定会是一个很大的工作量。</p>
<p>那么，如果既要能引用公共的变量和函数，又要减少重复的定义和导入，那要怎么做呢？</p>
<h2 id="pytest-的-conftest-py"><a href="#pytest-的-conftest-py" class="headerlink" title="pytest 的 conftest.py"></a>pytest 的 conftest.py</h2><p>前段时间在接触<code>pytest</code>时，看到<code>pytest</code>支持<code>conftest.py</code>的插件机制，这是一种在测试文件中可以实现模块自动发现和热加载的机制。具体地，只要是在文件目录存在命名为<code>conftest.py</code>的文件，里面定义的<code>hook</code>函数都会在<code>pytest</code>运行过程中被导入，并可被测试用例进行调用。同时，<code>conftest.py</code>存在优先级策略，从测试用例所在目录到系统根目录的整个路径中，越靠近测试用例的<code>conftest.py</code>优先级越高。</p>
<p>其实这也是采用了<code>约定大于配置</code>（<code>convention over configuration</code>）的思想。<code>约定大于配置</code>是一种软件设计范式，旨在减少软件开发人员需做决定的数量，在遵从约定的过程中就不自觉地沿用了最佳工程实践。我个人也是比较喜欢这种方式的，所以在设计<code>ApiTestEngine</code>的时候，也借鉴了一些类似的思想。</p>
<p>受到该启发，我想也可以采用类似的思想，采用自动热加载的机制，解决背景描述中存在的重复定义和引用的问题。</p>
<p>既然是<code>约定大于配置</code>，那么我们首先就得定一个默认的<code>Python</code>模块名，类似于<code>pytest</code>的<code>conftest.py</code>。</p>
<p>这就是<code>debugtalk.py</code>。</p>
<h2 id="debugtalk-py-的命名由来"><a href="#debugtalk-py-的命名由来" class="headerlink" title="debugtalk.py 的命名由来"></a>debugtalk.py 的命名由来</h2><p>为啥会采用<code>debugtalk.py</code>这个命名呢？</p>
<p>其实当时在想这个名字的时候也是耗费了很多心思，毕竟是要遵从<code>约定大于配置</code>的思想，因此在设计这个约定的命名时就格外谨慎，但始终没有想到一个既合适又满意的。</p>
<p>在我看来，这个命名应该至少满足如下两个条件：</p>
<ul>
<li>唯一性强</li>
<li>简单易记</li>
</ul>
<p>首先，约定的模块名应该具有较强的唯一性和较高的区分度，是用户通常都不会采用的命名；否则，可能就会出现测试用例在运行过程中，热加载时导入预期之外的<code>Python</code>模块。</p>
<p>但也不能仅仅为了具有区分度，就使用一个很长或者毫无意义的字符串作为模块名；毕竟还是要给用户使用的，总不能每次写用例时还要去查看下文档吧；所以命名简单易记便于用户使用也很重要。</p>
<p>也是因为这两个有点互相矛盾的原则，让我在设计命名时很是纠结。最终在拉同事讨论良久而无果的时候，同事说，不如就命名为<code>debugtalk.py</code>得了。</p>
<p>仔细一想，这命名还真符合要求。在唯一性方面，采用<code>debugtalk.py</code>在<code>Google</code>、<code>Bing</code>、<code>Baidu</code>等搜索引擎中采用精确匹配，基本没有无关信息，这样在后续遇到问题时，也容易搜索到已有的解决方案；而在简单易记方面，相信这个命名也不会太复杂。</p>
<p>当然，<code>debugtalk.py</code>只是作为框架默认加载的<code>Python</code>模块名，如果你不喜欢，也可以进行配置修改。</p>
<h2 id="热加载机制实现原理"><a href="#热加载机制实现原理" class="headerlink" title="热加载机制实现原理"></a>热加载机制实现原理</h2><p>然后，再来讲解下热加载机制的实现。</p>
<p>其实原理也不复杂，从背景描述可以看出，我们期望实现的需求主要有两点：</p>
<ul>
<li>自动发现<code>debugtalk.py</code>函数模块，并且具有优先级策略；</li>
<li>将<code>debugtalk.py</code>函数模块中的变量和函数导入到当前框架运行的内存空间。</li>
</ul>
<p>将这两点与测试用例引擎的实现机制结合起来，<code>ApiTestEngine</code>在运行过程中的热加载机制应该就如下图所示。</p>
<p><img src="/images/ate-hot-plugin.png" alt=""></p>
<p>这个流程图对热加载机制描述得已经足够清晰了，我再针对其中的几个点进行说明：</p>
<p>1、在初始化测试用例集（testset）的时候，除了将<code>config</code>中<code>variables</code>和<code>import_module_items</code>指定的变量和函数导入外，还会默认导入<code>ate/built_in.py</code>模块。之所以这么做，是因为对于大多数系统可能都会用到一些通用的函数，例如获取当前时间戳（<code>get_timestamp</code>）、生成随机字符串（<code>gen_random_string</code>）等。与其在每个项目中都单独去实现这些函数，不如就将其添加到框架中作为默认支持的函数（相当于框架层面的<code>debugtalk.py</code>），这样大家在项目中就不需要再重复做这些基础性工作了。</p>
<p>2、在<code>ApiTestEngine</code>框架中，存在测试用例（<code>testcase</code>）和测试用例集（<code>testset</code>）两个层面的作用域，两者的界限十分明确。这样设计的目的在于，我们既可以实现用例集层面的变量和函数的定义和导入，也可以保障各个用例之间的独立性，不至于出现作用域相互污染的情况。具体地，作用域在用例集初始化时定义或导入的变量和函数，会存储在用例集层面的作用域；而在运行每条测试用例时，会先继承（<code>deepcopy</code>）用例集层面的作用域，如果存在同名的变量或函数定义，则会对用例集层面的变量和函数进行覆盖，同时用例集层面的变量和函数也并不会被修改。</p>
<p>3、从热加载的顺序可以看出，查找变量或函数的顺序是从测试用例所在目录开始，沿着父路径逐层往上，直到系统的根目录。因此，我们可以利用这个优先级原则来组织我们的用例和依赖的<code>Python</code>函数模块。例如，我们可以将不同模块的测试用例集文件放在不同的文件夹下：针对各个模块独有的依赖函数和变量，可以放置在对应文件夹的<code>debugtalk.py</code>文件中；而整个项目公共的函数和变量，就可以放置到项目文件夹的<code>debugtalk.py</code>中。</p>
<p>文件组织结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  project ✗ tree .</div><div class="line">.</div><div class="line">├── debugtalk.py</div><div class="line">├── module_A</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── debugtalk.py</div><div class="line">│   ├── testsetA1.yml</div><div class="line">│   └── testsetA2.yml</div><div class="line">└── module_B</div><div class="line">    ├── __init__.py</div><div class="line">    ├── debugtalk.py</div><div class="line">    ├── testsetB1.yml</div><div class="line">    └── testsetB2.yml</div></pre></td></tr></table></figure>
<p>这其中还有一点需要格外注意。因为我们在框架运行过程中需要将<code>debugtalk.py</code>作为函数模块进行导入，因此我们首先要保障<code>debugtalk.py</code>满足<code>Python</code>模块的要求，也就是在对应的文件夹中要包含<code>__init__.py</code>文件。</p>
<p>如果对热加载机制的实现感兴趣，可直接阅读框架源码，重点只需查看<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/ate/utils.py" target="_blank" rel="external"><code>ate/utils.py</code></a>中的三个函数：</p>
<ul>
<li>search_conf_item(start_path, item_type, item_name)</li>
<li>get_imported_module_from_file(file_path)</li>
<li>filter_module(module, filter_type)</li>
</ul>
<h2 id="测试用例编写方式的变化"><a href="#测试用例编写方式的变化" class="headerlink" title="测试用例编写方式的变化"></a>测试用例编写方式的变化</h2><p>在新增<code>热加载机制</code>之后，编写测试用例的方式发生一些改变（优化），主要包括三点：</p>
<ul>
<li>导入<code>Python</code>模块的关键词改名为<code>import_module_items</code>（原名为<code>import_module_functions</code>）；</li>
<li>不再需要显式指定导入的<code>Python</code>模块路径，变更为热加载机制自动发现；</li>
<li><code>Python</code>模块中的变量也会被导入，公共变量可放置在<code>Python</code>模块中，而不再必须通过<code>variables</code>定义。</li>
</ul>
<p>考虑到兼容性问题，框架升级的同时也保留了对原有测试用例编写方式的支持，因此框架升级对已有测试用例的正常运行也不会造成影响。不过，我还是强烈建议大家采用最新的用例编写方式，充分利用热加载机制带来的便利。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>现在回过头来看<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的演进历程，以及之前写的关于<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>设计方面的文章，会发现当初的确是有一些考虑不周全的地方。也许这也是编程的乐趣所在吧，在前行的道路中，总会有新的感悟和新的收获，迭代优化的过程，就仿佛是在打磨一件艺术品。</p>
<p>这种感觉，甚好！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;https://github.com/debugtalk/ApiTestEngine&quot; target=&quot;
    
    </summary>
    
    
      <category term="热加载" scheme="http://debugtalk.com/tags/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="debugtalk.py" scheme="http://debugtalk.com/tags/debugtalk-py/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 集成 Locust 实现更好的性能测试体验</title>
    <link href="http://debugtalk.com/post/apitestengine-supersede-locust/"/>
    <id>http://debugtalk.com/post/apitestengine-supersede-locust/</id>
    <published>2017-08-26T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>不是接口测试框架么，也能实现性能测试？</p>
<p>是的，你没有看错，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>集成了<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>性能测试框架，只需一份测试用例，就能同时实现接口自动化测试和接口性能测试，在不改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>任何特性的情况下，甚至比<code>Locust</code>本身更易用。</p>
<p>如果你还没有接触过<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>这款性能测试工具，那么这篇文章可能不适合你。但我还是强烈推荐你了解一下这款工具。简单地说，<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>是一款采用<code>Python</code>语言编写实现的开源性能测试工具，简洁、轻量、高效，并发机制基于<code>gevent</code>协程，可以实现单机模拟生成较高的并发压力。关于<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的特性介绍和使用教程，我之前已经写过不少，你们可以在我的博客中找到<a href="http://debugtalk.com/tags/Locust/">对应文章</a>。</p>
<p>如果你对实现的过程没有兴趣，可以直接跳转到文章底部，看<code>最终实现效果</code>章节。</p>
<h2 id="灵感来源"><a href="#灵感来源" class="headerlink" title="灵感来源"></a>灵感来源</h2><p>在当前市面上的测试工具中，接口测试和性能测试基本上是两个泾渭分明的领域。这也意味着，针对同一个系统的服务端接口，我们要对其实现接口自动化测试和接口性能测试时，通常都是采用不同的工具，分别维护两份测试脚本或用例。</p>
<p>之前我也是这么做的。但是在做了一段时间后我就在想，不管是接口功能测试，还是接口性能测试，核心都是要模拟对接口发起请求，然后对接口响应内容进行解析和校验；唯一的差异在于，接口性能测试存在并发的概念，相当于模拟了大量用户同时在做接口测试。</p>
<p>既然如此，那接口自动化测试用例和接口性能测试脚本理应可以合并为一套，这样就可以避免重复的脚本开发工作了。</p>
<p>在开发<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的过程中，之前的文章也说过，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>完全基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Python-Requests</code></a>库实现HTTP的请求处理，可以在编写接口测试用例时复用到<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Python-Requests</code></a>的所有功能特性。而之前在学习<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的源码时，发现<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>在实现HTTP请求的时候，也完全是基于<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Python-Requests</code></a>库。</p>
<p>在这一层关系的基础上，我提出一个大胆的设想，能否通过一些方式或手段，可以使<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>中编写的<code>YAML/JSON</code>格式的接口测试用例，也能直接让<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>直接调用呢？</p>
<h2 id="灵感初探"><a href="#灵感初探" class="headerlink" title="灵感初探"></a>灵感初探</h2><p>想法有了以后，就开始探索实现的方法了。</p>
<p>首先，我们可以看下<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的脚本形式。如下例子是一个比较简单的场景（截取自官网首页）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteTasks</span><span class="params">(TaskSet)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></div><div class="line">        self.client.post(<span class="string">"/login"</span>, &#123;</div><div class="line">            <span class="string">"username"</span>: <span class="string">"test_user"</span>,</div><div class="line">            <span class="string">"password"</span>: <span class="string">""</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line"><span class="meta">    @task</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></div><div class="line">        self.client.get(<span class="string">"/"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @task</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">about</span><span class="params">(self)</span>:</span></div><div class="line">        self.client.get(<span class="string">"/about/"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsiteUser</span><span class="params">(HttpLocust)</span>:</span></div><div class="line">    task_set = WebsiteTasks</div><div class="line">    min_wait = <span class="number">5000</span></div><div class="line">    max_wait = <span class="number">15000</span></div></pre></td></tr></table></figure>
<p>在<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的脚本中，我们会在<code>TaskSet</code>子类中描述单个用户的行为，每一个带有<code>@task</code>装饰器的方法都对应着一个HTTP请求场景。而<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的一个很大特点就是，所有的测试用例脚本都是<code>Python</code>文件，因此我们可以采用Python实现各种复杂的场景。</p>
<p>等等！模拟单个用户请求，而且还是纯粹的Python语言，我们不是在接口测试中已经实现的功能么？</p>
<p>例如，下面的代码就是从单元测试中截取的测试用例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run_testset</span><span class="params">(self)</span>:</span></div><div class="line">    testcase_file_path = os.path.join(</div><div class="line">        os.getcwd(), <span class="string">'examples/quickstart-demo-rev-3.yml'</span>)</div><div class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</div><div class="line">    results = self.test_runner.run_testset(testsets[<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p><code>test_runner.run_testset</code>是已经在<code>ApiTestEngine</code>中实现的方法，作用是传入测试用例（<code>YAML/JSON</code>）的路径，然后就可以加载测试用例，运行整个测试场景。并且，由于我们在测试用例<code>YAML/JSON</code>中已经描述了<code>validators</code>，即接口的校验部分，因此我们也无需再对接口响应结果进行校验描述了。</p>
<p>接下来，实现方式就非常简单了。</p>
<p>我们只需要制作一个<code>locustfile.py</code>的模板文件，内容如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding: utf-8</span></div><div class="line"><span class="keyword">import</span> zmq</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> HttpLocust, TaskSet, task</div><div class="line"><span class="keyword">from</span> ate <span class="keyword">import</span> utils, runner</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageTasks</span><span class="params">(TaskSet)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></div><div class="line">        self.test_runner = runner.Runner(self.client)</div><div class="line">        self.testset = self.locust.testset</div><div class="line"></div><div class="line"><span class="meta">    @task</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_specified_scenario</span><span class="params">(self)</span>:</span></div><div class="line">       self.test_runner.run_testset(self.testset)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebPageUser</span><span class="params">(HttpLocust)</span>:</span></div><div class="line">    host = <span class="string">''</span></div><div class="line">    task_set = WebPageTasks</div><div class="line">    min_wait = <span class="number">1000</span></div><div class="line">    max_wait = <span class="number">5000</span></div><div class="line"></div><div class="line">    testcase_file_path = os.path.join(os.getcwd(), <span class="string">'skypixel.yml'</span>)</div><div class="line">    testsets = utils.load_testcases_by_path(testcase_file_path)</div><div class="line">    testset = testsets[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<p>可以看出，整个文件中，只有测试用例文件的路径是与具体测试场景相关的，其它内容全都可以不变。</p>
<p>于是，针对不同的测试场景，我们只需要将<code>testcase_file_path</code>替换为接口测试用例文件的路径，即可实现对应场景的接口性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  ApiTestEngine git:(master) ✗ locust <span class="_">-f</span> locustfile.py</div><div class="line">[2017-08-27 11:30:01,829] bogon/INFO/locust.main: Starting web monitor at *:8089</div><div class="line">[2017-08-27 11:30:01,831] bogon/INFO/locust.main: Starting Locust 0.8a2</div></pre></td></tr></table></figure>
<p>后面的操作就完全是<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的内容了，使用方式完全一样。</p>
<p><img src="/images/locust-start.jpg" alt=""></p>
<h2 id="优化1：自动生成locustfile"><a href="#优化1：自动生成locustfile" class="headerlink" title="优化1：自动生成locustfile"></a>优化1：自动生成locustfile</h2><p>通过前面的探索实践，我们基本上就实现了一份测试用例同时兼具接口自动化测试和接口性能测试的功能。</p>
<p>然而，在使用上还不够便捷，主要有两点：</p>
<ul>
<li>需要手工修改模板文件中的<code>testcase_file_path</code>路径；</li>
<li><code>locustfile.py</code>模板文件的路径必须放在<code>ApiTestEngine</code>的项目根目录下。</li>
</ul>
<p>于是，我产生了让<code>ApiTestEngine</code>框架本身自动生成<code>locustfile.py</code>文件的想法。</p>
<p>在实现这个想法的过程中，我想过两种方式。</p>
<p>第一种，通过分析<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的源码，可以看到<code>Locust</code>在<code>main.py</code>中具有一个<code>load_locustfile</code>方法，可以加载Python格式的文件，并提取出其中的<code>locust_classes</code>（也就是<code>Locust</code>的子类）；后续，就是将<code>locust_classes</code>作为参数传给<code>Locust</code>的<code>Runner</code>了。</p>
<p>若采用这种思路，我们就可以实现一个类似<code>load_locustfile</code>的方法，将<code>YAML/JSON</code>文件中的内容动态生成<code>locust_classes</code>，然后再传给<code>Locust</code>的<code>Runner</code>。这里面会涉及到动态地创建类和添加方法，好处是不需要生成<code>locustfile.py</code>中间文件，并且可以实现最大的灵活性，但缺点在于需要改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的源码，即重新实现<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的<code>main.py</code>中的多个函数。虽然难度不会太大，但考虑到后续需要与<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的更新保持一致，具有一定的维护工作量，便放弃了该种方案。</p>
<p>第二种，就是生成<code>locustfile.py</code>这样一个中间文件，然后将文件路径传给<code>Locust</code>。这样的好处在于我们可以不改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的任何地方，直接对其进行使用。与<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的传统使用方式差异在于，之前我们是在<code>Terminal</code>中通过参数启动<code>Locust</code>，而现在我们是在<code>ApiTestEngine</code>框架中通过Python代码启动<code>Locust</code>。</p>
<p>具体地，我在<code>setup.py</code>的<code>entry_points</code>中新增了一个命令<code>locusts</code>，并绑定了对应的程序入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">entry_points=&#123;</div><div class="line">    <span class="string">'console_scripts'</span>: [</div><div class="line">        <span class="string">'ate=ate.cli:main_ate'</span>,</div><div class="line">        <span class="string">'locusts=ate.cli:main_locust'</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>ate/cli.py</code>中新增了<code>main_locust</code>函数，作为<code>locusts</code>命令的入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">""" Performance test with locust: parse command line options and run commands.</span></div><div class="line">    """</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">from</span> locust.main <span class="keyword">import</span> main</div><div class="line">    <span class="keyword">except</span> ImportError:</div><div class="line">        print(<span class="string">"Locust is not installed, exit."</span>)</div><div class="line">        exit(<span class="number">1</span>)</div><div class="line"></div><div class="line">    sys.argv[<span class="number">0</span>] = <span class="string">'locust'</span></div><div class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</div><div class="line">        sys.argv.extend([<span class="string">"-h"</span>])</div><div class="line"></div><div class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">"-h"</span>, <span class="string">"--help"</span>, <span class="string">"-V"</span>, <span class="string">"--version"</span>]:</div><div class="line">        main()</div><div class="line">        sys.exit(<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        testcase_index = sys.argv.index(<span class="string">'-f'</span>) + <span class="number">1</span></div><div class="line">        <span class="keyword">assert</span> testcase_index &lt; len(sys.argv)</div><div class="line">    <span class="keyword">except</span> (ValueError, AssertionError):</div><div class="line">        print(<span class="string">"Testcase file is not specified, exit."</span>)</div><div class="line">        sys.exit(<span class="number">1</span>)</div><div class="line"></div><div class="line">    testcase_file_path = sys.argv[testcase_index]</div><div class="line">    sys.argv[testcase_index] = parse_locustfile(testcase_file_path)</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>若你执行<code>locusts -V</code>或<code>locusts -h</code>，会发现效果与<code>locust</code>的特性完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ locusts -V</div><div class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout: Locust 0.8a2</div><div class="line">[2017-08-27 12:41:27,740] bogon/INFO/stdout:</div></pre></td></tr></table></figure>
<p>事实上，通过上面的代码（<code>main_locust</code>）也可以看出，<code>locusts</code>命令只是对<code>locust</code>进行了一层封装，用法基本等价。唯一的差异在于，当<code>-f</code>参数指定的是<code>YAML/JSON</code>格式的用例文件时，会先转换为Python格式的<code>locustfile.py</code>，然后再传给<code>locust</code>。</p>
<p>至于解析函数<code>parse_locustfile</code>，实现起来也很简单。我们只需要在框架中保存一份<code>locustfile.py</code>的模板文件（<code>ate/locustfile_template</code>），并将<code>testcase_file_path</code>采用占位符代替。然后，在解析函数中，就可以读取整个模板文件，将其中的占位符替换为<code>YAML/JSON</code>用例文件的实际路径，然后再保存为<code>locustfile.py</code>，并返回其路径即可。</p>
<p>具体的代码就不贴了，有兴趣的话可自行查看。</p>
<p>通过这一轮优化，<code>ApiTestEngine</code>就继承了<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>的全部功能，并且可以直接指定<code>YAML/JSON</code>格式的文件启动<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>执行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ locusts <span class="_">-f</span> examples/first-testcase.yml</div><div class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</div><div class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</div></pre></td></tr></table></figure>
<h2 id="优化2：一键启动多个locust实例"><a href="#优化2：一键启动多个locust实例" class="headerlink" title="优化2：一键启动多个locust实例"></a>优化2：一键启动多个locust实例</h2><p>经过第一轮优化后，本来应该是告一段落了，因为此时<code>ApiTestEngine</code>已经可以非常便捷地实现接口自动化测试和接口性能测试的切换了。</p>
<p>直到有一天，在<code>TesterHome</code>论坛讨论<code>Locust</code>的一个<a href="https://testerhome.com/topics/9277#reply-84542" target="_blank" rel="external">回复</a>中，<a href="https://testerhome.com/keithmork" target="_blank" rel="external"><code>@keithmork</code></a>说了这么一句话。</p>
<blockquote>
<p>期待有一天<code>ApiTestEngine</code>的热度超过<code>Locust</code>本身</p>
</blockquote>
<p>看到这句话时我真的不禁泪流满面。虽然我也是一直在用心维护<code>ApiTestEngine</code>，却从未有过这样的奢望。</p>
<p>但反过来细想，为啥不能有这样的想法呢？当前<code>ApiTestEngine</code>已经继承了<code>Locust</code>的所有功能，在不影响<code>Locust</code>已有特性的同时，还可以采用<code>YAML/JSON</code>格式来编写维护测试用例，并实现了一份测试用例可同时用于接口自动化和接口性能测试的目的。</p>
<p>这些特性都是<code>Locust</code>所不曾拥有的，而对于使用者来说的确也都是比较实用的功能。</p>
<p>于是，新的目标在内心深处萌芽了，那就是在<code>ApiTestEngine</code>中通过对<code>Locust</code>更好的封装，让<code>Locust</code>的使用者体验更爽。</p>
<p>然后，我又想到了自己之前做的一个开源项目，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="external"><code>debugtalk/stormer</code></a>。当时做这个项目的初衷在于，当我们使用<code>Locust</code>进行压测时，要想使用压测机所有CPU的性能，就需要采用<code>master-slave</code>模式。因为<code>Locust</code>默认是单进程运行的，只能运行在压测机的一个CPU核上；而通过采用<code>master-slave</code>模式，启动多个<code>slave</code>，就可以让不同的<code>slave</code>运行在不同的CPU核上，从而充分发挥压测机多核处理器的性能。</p>
<p>而在实际使用<code>Locust</code>的时候，每次只能手动启动<code>master</code>，并依次手动启动多个<code>slave</code>。若遇到测试脚本调整的情况，就需要逐一结束<code>Locust</code>的所有进程，然后再重复之前的启动步骤。如果有使用过<code>Locust</code>的同学，应该对此痛苦的经历都有比较深的体会。当时也是基于这一痛点，我开发了<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="external"><code>debugtalk/stormer</code></a>，目的就是可以一次性启动或销毁多个<code>Locust</code>实例。这个脚本做出来后，自己用得甚爽，也得到了<code>Github</code>上一些朋友的青睐。</p>
<p>既然现在要提升<code>ApiTestEngine</code>针对<code>Locust</code>的使用便捷性，那么这个特性毫无疑问也应该加进去。就此，<a href="https://github.com/debugtalk/Stormer" target="_blank" rel="external"><code>debugtalk/stormer</code></a>项目便被废弃，正式合并到<code>debugtalk/ApiTestEngine</code>。</p>
<p>想法明确后，实现起来也挺简单的。</p>
<p>原则还是保持不变，那就是不改变<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>本身的特性，只在传参的时候在中间层进行操作。</p>
<p>具体地，我们可以新增一个<code>--full-speed</code>参数。当不指定该参数时，使用方式跟之前完全相同；而指定<code>--full-speed</code>参数后，就可以采用多进程的方式启动多个实例（实例个数等于压测机的处理器核数）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_locust</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># do original work</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="string">"--full-speed"</span> <span class="keyword">in</span> sys.argv:</div><div class="line">        locusts.run_locusts_at_full_speed(sys.argv)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        locusts.main()</div></pre></td></tr></table></figure>
<p>具体实现逻辑在<code>ate/locusts.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">from</span> locust.main <span class="keyword">import</span> main</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_master</span><span class="params">(sys_argv)</span>:</span></div><div class="line">    sys_argv.append(<span class="string">"--master"</span>)</div><div class="line">    sys.argv = sys_argv</div><div class="line">    main()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_slave</span><span class="params">(sys_argv)</span>:</span></div><div class="line">    sys_argv.extend([<span class="string">"--slave"</span>])</div><div class="line">    sys.argv = sys_argv</div><div class="line">    main()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_locusts_at_full_speed</span><span class="params">(sys_argv)</span>:</span></div><div class="line">    sys_argv.pop(sys_argv.index(<span class="string">"--full-speed"</span>))</div><div class="line">    slaves_num = multiprocessing.cpu_count()</div><div class="line"></div><div class="line">    processes = []</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(slaves_num):</div><div class="line">        p_slave = multiprocessing.Process(target=start_slave, args=(sys_argv,))</div><div class="line">        p_slave.daemon = <span class="keyword">True</span></div><div class="line">        p_slave.start()</div><div class="line">        processes.append(p_slave)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        start_master(sys_argv)</div><div class="line">    <span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">        sys.exit(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>由此可见，关键点也就是使用了<code>multiprocessing.Process</code>，在不同的进程中分别调用<code>Locust</code>的<code>main()</code>函数，实现逻辑十分简单。</p>
<h2 id="最终实现效果"><a href="#最终实现效果" class="headerlink" title="最终实现效果"></a>最终实现效果</h2><p>经过前面的优化，采用<code>ApiTestEngine</code>执行性能测试时，使用就十分便捷了。</p>
<p>安装<code>ApiTestEngine</code>后，系统中就具有了<code>locusts</code>命令，使用方式跟<code>Locust</code>框架的<code>locust</code>几乎完全相同，我们完全可以使用<code>locusts</code>命令代替原生的<code>locust</code>命令。</p>
<p>例如，下面的命令执行效果与<code>locust</code>完全一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ locusts -V</div><div class="line">$ locusts -h</div><div class="line">$ locusts <span class="_">-f</span> locustfile.py</div><div class="line">$ locusts <span class="_">-f</span> locustfile.py --master -P 8088</div><div class="line">$ locusts <span class="_">-f</span> locustfile.py --slave &amp;</div></pre></td></tr></table></figure>
<p>差异在于，<code>locusts</code>具有更加丰富的功能。</p>
<p>在<code>ApiTestEngine</code>中编写的<code>YAML/JSON</code>格式的接口测试用例文件，直接运行就可以启动<code>Locust</code>运行性能测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ locusts <span class="_">-f</span> examples/first-testcase.yml</div><div class="line">[2017-08-18 17:20:43,915] Leos-MacBook-Air.local/INFO/locust.main: Starting web monitor at *:8089</div><div class="line">[2017-08-18 17:20:43,918] Leos-MacBook-Air.local/INFO/locust.main: Starting Locust 0.8a2</div></pre></td></tr></table></figure>
<p>加上<code>--full-speed</code>参数，就可以同时启动多个<code>Locust</code>实例（实例个数等于处理器核数），充分发挥压测机多核处理器的性能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ locusts <span class="_">-f</span> examples/first-testcase.yml --full-speed -P 8088</div><div class="line">[2017-08-26 23:51:47,071] bogon/INFO/locust.main: Starting web monitor at *:8088</div><div class="line">[2017-08-26 23:51:47,075] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,078] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,080] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,083] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.runners: Client <span class="string">'bogon_656e0af8e968a8533d379dd252422ad3'</span> reported as ready. Currently 1 clients ready to swarm.</div><div class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_09f73850252ee4ec739ed77d3c4c6dba'</span> reported as ready. Currently 2 clients ready to swarm.</div><div class="line">[2017-08-26 23:51:47,084] bogon/INFO/locust.main: Starting Locust 0.8a2</div><div class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_869f7ed671b1a9952b56610f01e2006f'</span> reported as ready. Currently 3 clients ready to swarm.</div><div class="line">[2017-08-26 23:51:47,085] bogon/INFO/locust.runners: Client <span class="string">'bogon_80a804cda36b80fac17b57fd2d5e7cdb'</span> reported as ready. Currently 4 clients ready to swarm.</div></pre></td></tr></table></figure>
<p><img src="/images/locusts-full-speed.jpg" alt=""></p>
<p>后续，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>将持续进行优化，欢迎大家多多反馈改进建议。</p>
<p>Enjoy!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/debugtalk/ApiTestEngine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;ApiTestEngine&lt;/code&gt;&lt;/a&gt;不是接口测试框架么，也能实现性能测试？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Locust" scheme="http://debugtalk.com/tags/Locust/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine QuickStart</title>
    <link href="http://debugtalk.com/post/apitestengine-quickstart/"/>
    <id>http://debugtalk.com/post/apitestengine-quickstart/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-Sample-Interface-Service"><a href="#Introduction-to-Sample-Interface-Service" class="headerlink" title="Introduction to Sample Interface Service"></a>Introduction to Sample Interface Service</h2><p>Along with this project, I devised a sample interface service, and you can use it to familiarize how to play with <code>ApiTestEngine</code>.</p>
<p>This sample service mainly has two parts:</p>
<ul>
<li>Authorization, each request of other APIs should sign with some header fields and get token first.</li>
<li>RESTful APIs for user management, you can do CRUD manipulation on users.</li>
</ul>
<p>As you see, it is very similar to the mainstream production systems. Therefore once you are familiar with handling this demo service, you can master most test scenarios in your project.</p>
<h2 id="Launch-Sample-Interface-Service"><a href="#Launch-Sample-Interface-Service" class="headerlink" title="Launch Sample Interface Service"></a>Launch Sample Interface Service</h2><p>The demo service is a flask server, we can launch it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ export FLASK_APP=tests/api_server.py</div><div class="line">$ flask run</div><div class="line"> * Serving Flask app &quot;tests.api_server&quot;</div><div class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</div></pre></td></tr></table></figure>
<p>Now the sample interface service is running, and we can move on to the next step.</p>
<h2 id="Capture-HTTP-request-and-response"><a href="#Capture-HTTP-request-and-response" class="headerlink" title="Capture HTTP request and response"></a>Capture HTTP request and response</h2><p>Before we write testcases, we should know the details of the API. It is a good choice to use a web debugging proxy tool like <code>Charles Proxy</code> to capture the HTTP traffic.</p>
<p>For example, the image below illustrates getting token from the sample service first, and then creating one user successfully.</p>
<p><img src="/images/ate-quickstart-http-1.jpg" alt=""></p>
<p><img src="/images/ate-quickstart-http-2.jpg" alt=""></p>
<p>After thorough understanding of the APIs, we can now begin to write testcases.</p>
<h2 id="Write-the-first-test-case"><a href="#Write-the-first-test-case" class="headerlink" title="Write the first test case"></a>Write the first test case</h2><p>Open your favorite text editor and you can write test cases like this.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> iOS/<span class="number">10.3</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            os_platform:</span> ios</div><div class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> <span class="number">19067</span>cf712265eb5426db8d3664026c1ccea02b9</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            token:</span> F8prvGryC5beBr4g</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>As you see, each API request is described in a <code>test</code> block. And in the <code>request</code> field, it describes the detail of HTTP request, includes url, method, headers and data, which are in line with the captured traffic.</p>
<p>You may wonder why we use the <code>json</code> field other than <code>data</code>. That’s because the post data is in <code>JSON</code> format, when we use <code>json</code> to indicate the post data, we do not have to specify <code>Content-Type</code> to be <code>application/json</code> in request headers or dump data before request.</p>
<p>Have you recalled some familiar scenes?</p>
<p>Yes! That’s what we did in <a href="requests.request"><code>requests.request</code></a>! Since <code>ApiTestEngine</code> takes full reuse of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>, it inherits all powerful features of <a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>, and we can handle HTTP request as the way we do before.</p>
<h2 id="Run-test-cases"><a href="#Run-test-cases" class="headerlink" title="Run test cases"></a>Run test cases</h2><p>Suppose the test case file is named as <code>quickstart-demo-rev-0.yml</code> and is located in <code>examples</code> folder, then we can run it in this way.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ate examples/demo-rev-0.yml</div><div class="line">Running tests...</div><div class="line">----------------------------------------------------------------------</div><div class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 48 ms, response_length: 46 bytes</div><div class="line">OK (0.049669)s</div><div class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</div><div class="line">ERROR:root: Failed to POST http://127.0.0.1:5000/api/users/1000! exception msg: 403 Client Error: FORBIDDEN for url: http://127.0.0.1:5000/api/users/1000</div><div class="line">ERROR (0.006471)s</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 2 tests in 0.056s</div><div class="line"></div><div class="line">FAILED</div><div class="line"> (Errors=1)</div></pre></td></tr></table></figure>
<p>Oops! The second test case failed with 403 status code.</p>
<p>That is because we request with the same data as we captured in <code>Charles Proxy</code>, while the <code>token</code> is generated dynamically, thus the recorded data can not be be used twice directly.</p>
<h2 id="Optimize-test-case-correlation"><a href="#Optimize-test-case-correlation" class="headerlink" title="Optimize test case: correlation"></a>Optimize test case: correlation</h2><p>To fix this problem, we should correlate <code>token</code> field in the second API test case, which is also called <code>correlation</code>.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> iOS/<span class="number">10.3</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            os_platform:</span> ios</div><div class="line"><span class="attr">            app_version:</span> <span class="number">2.8</span><span class="number">.6</span></div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> <span class="number">19067</span>cf712265eb5426db8d3664026c1ccea02b9</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expected"</span>: <span class="number">16</span>&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> <span class="number">9</span>TN6O2Bn1vzfybF</div><div class="line"><span class="attr">            token:</span> $token</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>As you see, the <code>token</code> field is no longer hardcoded, instead it is extracted from the first API request with <code>extractors</code> mechanism. In the meanwhile, it is assigned to <code>token</code> variable, which can be referenced by the subsequent API requests.</p>
<p>Now we save the test cases to <code>quickstart-demo-rev-1.yml</code> and rerun it, and we will find that both API requests to be successful.</p>
<h2 id="Optimize-test-case-parameterization"><a href="#Optimize-test-case-parameterization" class="headerlink" title="Optimize test case: parameterization"></a>Optimize test case: parameterization</h2><p>Let’s look back to our test set <code>quickstart-demo-rev-1.yml</code>, and we can see the <code>device_sn</code> field is still hardcoded. This may be quite different from the actual scenarios.</p>
<p>In actual scenarios, each user’s <code>device_sn</code> is different, so we should parameterize the request parameters, which is also called <code>parameterization</code>. In the meanwhile, the <code>sign</code> field is calculated with other header fields, thus it may change significantly if any header field changes slightly.</p>
<p>However, the test cases are only <code>YAML</code> documents, it is impossible to generate parameters dynamically in such text. Fortunately, we can combine <code>Python</code> scripts with <code>YAML</code> test cases in <code>ApiTestEngine</code>.</p>
<p>To achieve this goal, we can utilize <code>import_module_functions</code> and <code>variables</code> mechanisms.</p>
<p>To be specific, we can create a Python file (<code>examples/utils.py</code>) and implement the related algorithm in it. Since we want to import this file, so we should put a <code>__init__.py</code> in this folder to make it as a Python module.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"><span class="keyword">import</span> hmac</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> string</div><div class="line"></div><div class="line">SECRET_KEY = <span class="string">"DebugTalk"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sign</span><span class="params">(*args)</span>:</span></div><div class="line">    content = <span class="string">''</span>.join(args).encode(<span class="string">'ascii'</span>)</div><div class="line">    sign_key = SECRET_KEY.encode(<span class="string">'ascii'</span>)</div><div class="line">    sign = hmac.new(sign_key, content, hashlib.sha1).hexdigest()</div><div class="line">    <span class="keyword">return</span> sign</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></div><div class="line">    random_char_list = []</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len):</div><div class="line">        random_char = random.choice(string.ascii_letters + string.digits)</div><div class="line">        random_char_list.append(random_char)</div><div class="line"></div><div class="line">    random_string = <span class="string">''</span>.join(random_char_list)</div><div class="line">    <span class="keyword">return</span> random_string</div></pre></td></tr></table></figure>
<p>And then, we can revise our demo test case and reference the functions. Suppose the revised file named <code>quickstart-demo-rev-2.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    import_module_functions:</span></div><div class="line"><span class="bullet">        -</span> examples.utils</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></div><div class="line"><span class="attr">        - device_sn:</span> $&#123;gen_random_string(<span class="number">15</span>)&#125;</div><div class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></div><div class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> $user_agent</div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"><span class="attr">            os_platform:</span> $os_platform</div><div class="line"><span class="attr">            app_version:</span> $app_version</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> $&#123;get_sign($user_agent, $device_sn, $os_platform, $app_version)&#125;</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expected"</span>: <span class="number">16</span>&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"><span class="attr">            token:</span> $token</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>In this revised test case, we firstly import module functions in <code>import_module_functions</code> block by specifying the Python module path, which is relative to the current working directory.</p>
<p>To make fields like <code>device_sn</code> can be used more than once, we also bind values to variables in <code>variables</code> block. When we bind variables, we can not only bind exact value to a variable name, but also can call a function and bind the evaluated value to it.</p>
<p>When we want to reference a variable in the test case, we can do this with a escape character <code>$</code>. For example, <code>$user_agent</code> will not be taken as a normal string, and <code>ApiTestEngine</code> will consider it as a variable named <code>user_agent</code>, search and return its binding value.</p>
<p>When we want to reference a function, we shall use another escape character <code>${}</code>. Any content in <code>${}</code> will be considered as function calling, so we should guarantee that we call functions in the right way. At the same time, variables can also be referenced as parameters of function.</p>
<h2 id="Optimize-test-case-overall-config-block"><a href="#Optimize-test-case-overall-config-block" class="headerlink" title="Optimize test case: overall config block"></a>Optimize test case: overall config block</h2><p>There is still one issue unsolved.</p>
<p>The <code>device_sn</code> field is defined in the first API test case, thus it may be impossible to reference it in other test cases. Context separation is a well-designed mechanism, and we should obey this good practice.</p>
<p>To handle this case, overall <code>config</code> block is supported in <code>ApiTestEngine</code>. If we define variables or import functions in <code>config</code> block, these variables and functions will become global and can be referenced in the whole test set.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># examples/quickstart-demo-rev-3.yml</span></div><div class="line"><span class="attr">- config:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">"smoketest for CRUD users."</span></div><div class="line"><span class="attr">    import_module_functions:</span></div><div class="line"><span class="bullet">        -</span> examples.utils</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - device_sn:</span> $&#123;gen_random_string(<span class="number">15</span>)&#125;</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        base_url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span></div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            device_sn:</span> $device_sn</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> get token</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - user_agent:</span> <span class="string">'iOS/10.3'</span></div><div class="line"><span class="attr">        - os_platform:</span> <span class="string">'ios'</span></div><div class="line"><span class="attr">        - app_version:</span> <span class="string">'2.8.6'</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/get-token</div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            user_agent:</span> $user_agent</div><div class="line"><span class="attr">            os_platform:</span> $os_platform</div><div class="line"><span class="attr">            app_version:</span> $app_version</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            sign:</span> $&#123;get_sign($user_agent, $device_sn, $os_platform, $app_version)&#125;</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        - token:</span> content.token</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">200</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.token"</span>, <span class="string">"comparator"</span>: <span class="string">"len_eq"</span>, <span class="string">"expected"</span>: <span class="number">16</span>&#125;</div><div class="line"></div><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> /api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            token:</span> $token</div><div class="line"><span class="attr">        json:</span></div><div class="line"><span class="attr">            name:</span> <span class="string">"user1"</span></div><div class="line"><span class="attr">            password:</span> <span class="string">"123456"</span></div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>As you see, we import public <code>Python</code> modules and variables in <code>config</code> block. Also, we can set <code>base_url</code> in <code>config</code> block, thereby we can only specify relative path in each API request url. Besides, we can also set common fields in <code>config</code> <code>request</code>, such as <code>device_sn</code> in headers.</p>
<p>Until now, the test cases are finished and each detail is handled properly.</p>
<h2 id="Run-test-cases-and-generate-report"><a href="#Run-test-cases-and-generate-report" class="headerlink" title="Run test cases and generate report"></a>Run test cases and generate report</h2><p>Finally, let’s run test set <code>quickstart-demo-rev-4.yml</code> once more.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ ate examples/quickstart-demo-rev-4.yml</div><div class="line">Running tests...</div><div class="line">----------------------------------------------------------------------</div><div class="line"> get token ... INFO:root: Start to POST http://127.0.0.1:5000/api/get-token</div><div class="line">INFO:root: status_code: 200, response_time: 33 ms, response_length: 46 bytes</div><div class="line">OK (0.037027)s</div><div class="line"> create user which does not exist ... INFO:root: Start to POST http://127.0.0.1:5000/api/users/1000</div><div class="line">INFO:root: status_code: 201, response_time: 15 ms, response_length: 54 bytes</div><div class="line">OK (0.016414)s</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 2 tests in 0.054s</div><div class="line">OK</div><div class="line"></div><div class="line">Generating HTML reports...</div><div class="line">Template is not specified, load default template instead.</div><div class="line">Reports generated: /Users/Leo/MyProjects/ApiTestEngine/reports/quickstart-demo-rev-0/2017-08-01-16-51-51.html</div></pre></td></tr></table></figure>
<p>Great! The test case runs successfully and generates a <code>HTML</code> test report.</p>
<p><img src="/images/ate-quickstart-demo-report.jpg" alt=""></p>
<h2 id="Further-more"><a href="#Further-more" class="headerlink" title="Further more"></a>Further more</h2><p>This is just a starting point, see the <code>advanced guide</code> for the advanced features.</p>
<ul>
<li>templating</li>
<li>data extraction and validation</li>
<li><a href="https://github.com/debugtalk/ApiTestEngine/blob/master/docs/comparator.md" target="_blank" rel="external"><code>comparator</code></a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Introduction-to-Sample-Interface-Service&quot;&gt;&lt;a href=&quot;#Introduction-to-Sample-Interface-Service&quot; class=&quot;headerlink&quot; title=&quot;Introduction
    
    </summary>
    
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>【大疆内推】岗位描述我只想这么写</title>
    <link href="http://debugtalk.com/post/d-test-hire-info/"/>
    <id>http://debugtalk.com/post/d-test-hire-info/</id>
    <published>2017-08-08T16:00:00.000Z</published>
    <updated>2017-11-03T15:02:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期，大疆互联网事业部广招各路英豪，各类岗位都有大量的<code>Hire Count</code>。</p>
<p>在我们质量部，现急需招聘<code>软件测试工程师</code>、<code>测试开发工程师</code>和<code>QA</code>，名额无限制。</p>
<p>如果你对我们的岗位感兴趣，可能你还想了解如下信息。</p>
<h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>大疆这家公司我就不介绍了，大家有兴趣可以看下我们的<a href="http://www.dji.com/" target="_blank" rel="external">公司主页</a>，或者在网上自行搜索。</p>
<p>可能很多人都知道大疆是一家做无人机的公司，但却不知道我们一直在探索着与互联网各种跨界融合的方式，在移动互联网、云计算、大数据、物联网、电子商务等领域同样投入了大量的资源。而互联网事业部，则肩负着该项重要使命。</p>
<p>我们质量部作为互联网事业部的测试团队，对接了整个部门的所有产品和项目，一直致力于提升整个部门的软件质量的研发效率。</p>
<h2 id="岗位职责及要求"><a href="#岗位职责及要求" class="headerlink" title="岗位职责及要求"></a>岗位职责及要求</h2><p>当前我们有<code>测试</code>、<code>测试开发</code>、<code>QA</code>这三类岗位。</p>
<p>关于这三类岗位的职责和差异，基本上跟各大互联网公司的岗位对应。之前我在内部新员工培训时有过一次分享，并且整理成了一篇文章，<a href="http://debugtalk.com/post/introduction-to-testing-engineer-daily-work/">《【科普】互联网测试岗位的工作日常》</a>，大家如有兴趣，可以进一步了解。</p>
<p>而对于岗位的要求，我不想复制粘贴招聘信息上千篇一律的描述，我就只谈下我对每个岗位需求的理解。</p>
<p>对于测试工程师，最重要的莫过于熟悉业务、善于发现问题、跟进并推动问题的解决。对于两年工作经验以内的，我们看重基础，对计算机软件、网络、软件测试理论等方面能有较好的掌握，如果在工作中还能积极地学习新技术并在项目中尝试使用，会是一个不错的亮点。对于两年工作经验以上的，我们期望能对业务流程、测试工作本身有更深的理解，并且在软件测试技术方面有一定的积累，最好能有一些成功的实践经验。</p>
<p>对于测试开发工程师，我们重点关注两个方面，一是对测试本身的理解，最好能有比较丰富的业务测试经验，毕竟开发出来的工具还是要为业务测试服务的；另一方面，作为带有<code>开发</code>的title，希望也能有较好的代码能力，并且最好有成功的实践案例或作品。</p>
<p>对于QA，业务、流程、管理，以及有较强的推动能力。</p>
<p>不管是什么岗位，善于学习，乐于总结，具有写笔记或博客的习惯，都会是很大的加分项。</p>
<p>关于硬性条件这块儿，希望能是本科及以上学历，计算机相关专业。公司并没有严格限制学历，但是当学历不达标时，对工作背景以及其它方面会有更高的期望。</p>
<h2 id="薪资福利"><a href="#薪资福利" class="headerlink" title="薪资福利"></a>薪资福利</h2><p>对于薪资福利，不同岗位和级别会有一定差异，但不管是什么岗位，处于行业领先的薪资水平还是可以保障的。</p>
<p>年底有机会获得奔驰宝马福利车这种奖励可能会觉得离自己太遥远，但年终奖还是不错的，具体看绩效。</p>
<p>另外比较可喜的是，从公司不断增加的福利可以看到，公司也在一直致力于提升员工的各项软福利和归属感，各项规章管理制度也在日益完善和更加人性化。</p>
<p>除了单纯的薪资福利，相信公司业务迅猛发展带来的个人能力成长空间，也是你所期待的。在大疆，公司的口号是探索未来无限可能（The future of possible），这对员工个人来说，也同样适用。</p>
<h2 id="其它岗位"><a href="#其它岗位" class="headerlink" title="其它岗位"></a>其它岗位</h2><p>除了测试相关的岗位，我们在前后端开发、业务运维、运维开发等各个岗位都有海量的招聘需求。</p>
<p>如果你们有兴趣，我同样可以帮忙对接到各个岗位的负责人。</p>
<h2 id="投递方式"><a href="#投递方式" class="headerlink" title="投递方式"></a>投递方式</h2><p>可以直接发到我的邮箱：mail@debugtalk.com<br>也可以发送到我的微信公众号：<code>DebugTalk</code></p>
<p>合适的简历我会积极内推，并全程跟进状态和进度。假如跟我们的岗位需求不匹配，我也会及时反馈结果及原因。</p>
<p>愿疆来有你，不管最后我们能否成为同事，希望我们都能成为朋友。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期，大疆互联网事业部广招各路英豪，各类岗位都有大量的&lt;code&gt;Hire Count&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在我们质量部，现急需招聘&lt;code&gt;软件测试工程师&lt;/code&gt;、&lt;code&gt;测试开发工程师&lt;/code&gt;和&lt;code&gt;QA&lt;/code&gt;，名额无限制。&lt;/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How to install a package from Github that has other github dependencies ?</title>
    <link href="http://debugtalk.com/post/How-to-install-a-package-from-Github-that-has-other-github-dependencies/"/>
    <id>http://debugtalk.com/post/How-to-install-a-package-from-Github-that-has-other-github-dependencies/</id>
    <published>2017-08-04T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发<code>ApiTestEngine</code>时遇到一个安装包依赖的问题，耗费了不少时间寻找解决方案，考虑到还算比较有普遍性，因此总结形成这篇文章。</p>
<h2 id="从-pip-install-说起"><a href="#从-pip-install-说起" class="headerlink" title="从 pip install 说起"></a>从 pip install 说起</h2><p>先不那么简单地描述下背景。</p>
<p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>作为一款接口测试工具，需要具有灵活的命令行调用方式，因此最好能在系统中进行安装并注册为一个<code>CLI</code>命令。</p>
<p>在Python中，安装依赖库的最佳方式是采用<a href="https://pip.pypa.io/en/stable/" target="_blank" rel="external"><code>pip</code></a>，例如安装<a href="http://locust.io/" target="_blank" rel="external"><code>Locust</code></a>时，就可以采用如下命令搞定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pip install locustio</div><div class="line">Collecting locustio</div><div class="line">  Using cached locustio-0.7.5.tar.gz</div><div class="line">[...]</div><div class="line">Successfully installed locustio-0.7.5</div></pre></td></tr></table></figure>
<p>但要想采用<code>pip install SomePackage</code>的方式，前提是<code>SomePackage</code>已经托管在<code>PyPI</code>。关于<code>PyPI</code>，可以理解为<code>Python</code>语言的第三方库的仓库索引，当前绝大多数流行的<code>Python</code>第三方库都托管在<code>PyPI</code>上。</p>
<p>但是，这里存在一个问题。在<code>PyPI</code>当中，所有的包都是由其作者自行上传的。如果作者比较懒，那么可能托管在<code>PyPI</code>上的最新版本相较于最新代码就会比较滞后。</p>
<p><code>Locust</code>就是一个典型的例子。从上面的安装过程可以看出，我们采用<code>pip install locustio</code>安装的<code>Locust</code>版本是<code>v0.7.5</code>，而在<code>Locust</code>的<code>Github</code>仓库中，<code>v0.7.5</code>已经是一年之前的版本了。也是因为这个原因，之前在我的博客里面介绍<code>Locust</code>的<a href="http://debugtalk.com/post/head-first-locust-user-guide/">图表展示功能</a>后，已经有不下5个人向我咨询为啥他们看不到这个图表模块。这是因为<code>Locust</code>的图表模块是在今年（2017）年初时添加的功能，master分支的代码版本也已经升级到<code>v0.8a2</code>了，但<code>PyPI</code>上的版本却一直没有更新。</p>
<p>而要想使用到项目最新的功能，就只能采用源码进行安装。</p>
<p>大多数编程语言在使用源码进行安装时，都需要先将源码下载到本地，然后通过命令进行编译，例如<code>Linux</code>中常见的<code>make &amp;&amp; make install</code>。对于<code>Python</code>项目来说，也可以采用类似的模式，先将项目<code>clone</code>到本地，然后进入到项目的根目录，执行<code>python setup.py install</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/locustio/locust.git</div><div class="line">$ cd locust</div><div class="line">$ python setup.py install</div><div class="line">[...]</div><div class="line">Finished processing dependencies for locustio==0.8a2</div></pre></td></tr></table></figure>
<p>不过，要想采用这种方式进行安装也是有前提的，那就是项目必须已经实现了基于<code>setuptools</code>的安装方式，并在项目的根目录下存在<code>setup.py</code>。</p>
<p>可以看出，这种安装方式还是比较繁琐的，需要好几步才能完成安装。而且，对于大多数使用者来说，他们并不需要阅读项目源码，因此<code>clone</code>操作也实属多余。</p>
<p>可喜的是，<code>pip</code>不仅支持安装<code>PyPI</code>上的包，也可以直接通过项目的<code>git</code>地址进行安装。还是以<code>Locust</code>项目为例，我们通过<code>pip</code>命令也可以实现一条命令安装<code>Github</code>项目源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/locustio/locust.git@master#egg=locustio</div><div class="line">Collecting locustio from git+https://github.com/locustio/locust.git@master#egg=locustio</div><div class="line">[...]</div><div class="line">Successfully installed locustio-0.8a2</div></pre></td></tr></table></figure>
<p>对于项目地址来说，完整的描述应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install vcs+protocol://repo_url/#egg=pkg&amp;subdirectory=pkg_dir</div></pre></td></tr></table></figure>
<p>这里的<code>vcs</code>也不仅限于<code>git</code>，<code>svn</code>和<code>hg</code>也是一样的，而<code>protocol</code>除了采用<code>SSH</code>形式的项目地址，也可以采用<code>HTTPS</code>的地址，在此不再展开。</p>
<p>通过这种方式，我们就总是可以使用到项目的最新功能特性了。当然，前提条件也是一样的，需要项目中已经实现了<code>setup.py</code>。</p>
<p>考虑到<code>ApiTestEngine</code>还处于频繁的新特性开发阶段，因此这种途径无疑是让用户安装使用最新代码的最佳方式。</p>
<h2 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h2><p>在<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>中，存在测试结果报告展示这一部分的功能，而这部分的功能是需要依赖于另外一个托管在GitHub上的项目，<a href="https://github.com/debugtalk/PyUnitReport" target="_blank" rel="external"><code>PyUnitReport</code></a>。</p>
<p>于是，问题就变为：如何构造<code>ApiTestEngine</code>项目的<code>setup.py</code>，可以实现用户在安装<code>ApiTestEngine</code>时自动安装<code>PyUnitReport</code>依赖。</p>
<p>对于这个需求，已经确定可行的办法：先通过<code>pip</code>安装依赖的库（<code>PyUnitReport</code>），然后再安装当前项目（<code>ApiTestEngine</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport</div><div class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div></pre></td></tr></table></figure>
<p>这种方式虽然可行，但是需要执行两条命令，显然不是我们想要的效果。</p>
<p>经过搜索，发现针对该需求，可以在<code>setuptools.setup()</code>中通过<code>install_requires</code>和<code>dependency_links</code>这两个配置项组合实现。</p>
<p>具体地，配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">install_requires=[</div><div class="line">   &quot;requests&quot;,</div><div class="line">   &quot;flask&quot;,</div><div class="line">   &quot;PyYAML&quot;,</div><div class="line">   &quot;coveralls&quot;,</div><div class="line">   &quot;coverage&quot;,</div><div class="line">   &quot;PyUnitReport&quot;</div><div class="line">],</div><div class="line">dependency_links=[</div><div class="line">   &quot;git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport&quot;</div><div class="line">],</div></pre></td></tr></table></figure>
<p>这里有一点需要格外注意，那就是指定的依赖包如果存在于<code>PyPI</code>，那么只需要在<code>install_requires</code>中指定包名和版本号即可（不指定版本号时，默认安装最新版本）；而对于以仓库URL地址存在的依赖包，那么不仅需要在<code>dependency_links</code>中指定，同时也要在<code>install_requires</code>中指定。</p>
<p>然后，就可以直接通过<code>ApiTestEngine</code>项目的git地址一键进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div></pre></td></tr></table></figure>
<p>虽然在寻找解决办法的过程中，看到大家都在说<code>dependency_links</code>由于安全性的问题，即将被弃用，而且在<code>setuptools</code>的官方文章中的确也没有看到<code>dependency_links</code>的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEPRECATION: Dependency Links processing has been deprecated and will be removed in a future release.</div></pre></td></tr></table></figure>
<p>不过在我本地的<code>macOS</code>系统上尝试发现，该种方式的确是可行的，因此就采用这种方式进行发布了。</p>
<p>但是当我后续在<code>Linux</code>服务器上安装时，却无法成功，总是在安装<code>PyUnitReport</code>依赖库的时候报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pip install git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div><div class="line">[...]</div><div class="line">Collecting PyUnitReport (from ApiTestEngine)</div><div class="line">  Could not find a version that satisfies the requirement PyUnitReport (from ApiTestEngine) (from versions: )</div><div class="line">No matching distribution found for PyUnitReport (from ApiTestEngine)</div></pre></td></tr></table></figure>
<p>另外，同时也有多个用户反馈了同样的问题，这才发现这种方式在<code>Linux</code>和<code>Windows</code>下是不行的。</p>
<p>然后，再次经过大量的搜索，却始终没有特别明确的答案，搞得我也在怀疑，<code>dependency_links</code>到底是不是真的已经弃用了，但是就算是弃用了，也应该有新的替代方案啊，但也并没有找到。</p>
<p>这个问题就这么放了差不多一个星期的样子。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>今天周末在家，想来想去，不解决始终不爽，虽然只是多执行一条命令的问题。</p>
<p>于是又是经过大量搜索，幸运的是终于从<code>pypa/pip</code>的<code>issues</code>中找到一条<a href="https://github.com/pypa/pip/issues/3610" target="_blank" rel="external"><code>issue</code></a>，作者是<a href="https://github.com/pypa/pip/issues/3610#issue-147115114" target="_blank" rel="external"><code>Dominik Neise</code></a>，他详细描述了他遇到的问题和尝试过的方法，看到他的描述我真是惊呆了，跟我的情况完全一模一样不说，连尝试的思路也完全一致。</p>
<p>然后，在下面的回复中，看到了<a href="https://github.com/pypa/pip/issues/3610#issuecomment-283578756" target="_blank" rel="external"><code>Gary Wu</code></a>和<a href="https://github.com/pypa/pip/issues/3610#issuecomment-317281367" target="_blank" rel="external"><code>kbuilds</code></a>的解答，总算是找到了问题的原因和解决方案。</p>
<p>问题在于，在<code>dependency_links</code>中指定仓库URL地址的时候，在指定<code>egg</code>信息时，<code>pip</code>还同时需要一个版本号（<code>version number</code>），并且以短横线<code>-</code>分隔，然后执行的时候再加上<code>--process-dependency-links</code>参数。</p>
<p>回到之前的<code>dependency_links</code>，我们应该写成如下形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependency_links=[</div><div class="line">   &quot;git+https://github.com/debugtalk/PyUnitReport.git#egg=PyUnitReport-0&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>在这里，短横线<code>-</code>后面我并没有填写<code>PyUnitReport</code>实际的版本号，因为经过尝试发现，这里填写任意数值都是成功的，因此我就填写为<code>0</code>了，省得后续在升级<code>PyUnitReport</code>以后还要来修改这个地方。</p>
<p>然后，就可以通过如下命令进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install --process-dependency-links git+https://github.com/debugtalk/ApiTestEngine.git#egg=ApiTestEngine</div></pre></td></tr></table></figure>
<p>至此，问题总算解决了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>那么，<code>dependency_links</code>到底是不是要废弃了呢？</p>
<p>从<code>pip</code>的<code>GitHub</code>项目中看到这么一个<a href="https://github.com/pypa/pip/issues/4187" target="_blank" rel="external"><code>issue</code></a>，<code>--process-dependency-links</code>之前废弃了一段时间，但是又给加回来了，因为当前还没有更好的可替代的方案。因此，在出现替代方案之前，<code>dependency_links</code>应该是最好的方式了吧。</p>
<p>最后再感叹下，老外提问时描述问题的专业性和细致程度真是令人佩服，大家可以再仔细看下这个<a href="https://github.com/pypa/pip/issues/3610#issue-147115114" target="_blank" rel="external"><code>issue</code></a>好好感受下。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://setuptools.readthedocs.io/en/latest/setuptools.html#dependencies-that-aren-t-in-pypi" target="_blank" rel="external">http://setuptools.readthedocs.io/en/latest/setuptools.html#dependencies-that-aren-t-in-pypi</a></li>
<li><a href="https://pip.pypa.io/en/stable/reference/pip_install/" target="_blank" rel="external">https://pip.pypa.io/en/stable/reference/pip_install/</a></li>
<li><a href="https://github.com/pypa/pip/issues/3610" target="_blank" rel="external">https://github.com/pypa/pip/issues/3610</a></li>
<li><a href="https://github.com/pypa/pip/issues/4187" target="_blank" rel="external">https://github.com/pypa/pip/issues/4187</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发&lt;code&gt;ApiTestEngine&lt;/code&gt;时遇到一个安装包依赖的问题，耗费了不少时间寻找解决方案，考虑到还算比较有普遍性，因此总结形成这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;从-pip-install-说起&quot;&gt;&lt;a href=&quot;#从-pip-install-
    
    </summary>
    
    
      <category term="Locust" scheme="http://debugtalk.com/tags/Locust/"/>
    
      <category term="setuptools" scheme="http://debugtalk.com/tags/setuptools/"/>
    
      <category term="pip" scheme="http://debugtalk.com/tags/pip/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>解决Jenkins中无法展示HTML样式的问题</title>
    <link href="http://debugtalk.com/post/solve-Jenkins-can-not-show-html-css/"/>
    <id>http://debugtalk.com/post/solve-Jenkins-can-not-show-html-css/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-09-04T05:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于测试报告来说，除了内容的简洁精炼，样式的美观也很重要。常用的做法是，采用<code>HTML</code>格式的文档，并搭配<code>CSS</code>和<code>JS</code>，实现自定义的样式和动画效果（例如展开、折叠等）。</p>
<p>在<code>Jenkins</code>中要展示<code>HTML</code>文档，通常采用的方式有两种：</p>
<ul>
<li>使用<a href="https://wiki.jenkins.io/display/JENKINS/HTML+Publisher+Plugin" target="_blank" rel="external"><code>HTML Publisher Plugin</code></a>；</li>
<li>使用<code>Files to archive</code>功能，在<code>Build Artifacts</code>中显示<code>HTML</code>文档链接。</li>
</ul>
<p>第一种方式配合插件，可以通过图形化操作实现简易配置，并且展示效果也不错；而第二种方式的优势在于使用<code>Jenkins</code>自带的功能，不依赖插件也能实现基本的需求。</p>
<p>然而，不管是采用哪种方式，都有可能会遇到一种情况，就是展示出来的<code>HTML</code>报告样式全无。在浏览器的<code>Network</code>中查看资源加载情况，会发现相关的<code>CSS</code>和<code>JS</code>都没法正常加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Refused to load the stylesheet &apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&apos; because it violates the following Content Security Policy directive: &quot;style-src &apos;self&apos;&quot;.</div><div class="line">Refused to apply inline style because it violates the following Content Security Policy directive: &quot;style-src &apos;self&apos;&quot;. Either the &apos;unsafe-inline&apos; keyword, a hash (&apos;sha256-0EZqoz+oBhx7gF4nvY2bSqoGyy4zLjNF+SDQXGp/ZrY=&apos;), or a nonce (&apos;nonce-...&apos;) is required to enable inline execution.</div><div class="line">Blocked script execution in &apos;http://10.13.0.146:8888/job/SkyPixel-SmokeTest/34/artifact/reports/SkyPixel-smoketest/34.html&apos; because the document&apos;s frame is sandboxed and the &apos;allow-scripts&apos; permission is not set.</div><div class="line">Refused to load the stylesheet &apos;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&apos; because it violates the following Content Security Policy directive: &quot;style-src &apos;self&apos;&quot;.</div></pre></td></tr></table></figure>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>出现该现象的原因在于<code>Jenkins</code>中配置的<code>CSP</code>（<code>Content Security Policy</code>）。</p>
<p>简单地说，这是<code>Jenkins</code>的一个安全策略，默认会设置为一个非常严格的权限集，以防止Jenkins用户在<code>workspace</code>、<code>/userContent</code>、<code>archived artifacts</code>中受到恶意<code>HTML/JS</code>文件的攻击。</p>
<p>默认地，该权限集会设置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sandbox; default-src &apos;none&apos;; img-src &apos;self&apos;; style-src &apos;self&apos;;</div></pre></td></tr></table></figure>
<p>在该配置下，只允许加载：</p>
<ul>
<li>Jenkins服务器上托管的<code>CSS</code>文件</li>
<li>Jenkins服务器上托管的图片文件</li>
</ul>
<p>而如下形式的内容都会被禁止：</p>
<ul>
<li>JavaScript</li>
<li>plugins (object/embed)</li>
<li>HTML中的内联样式表（<code>Inline style sheets</code>），以及引用的外站CSS文件</li>
<li>HTML中的内联图片（<code>Inline image definitions</code>），以及外站引用的图片文件</li>
<li>frames</li>
<li>web fonts</li>
<li>XHR/AJAX</li>
<li>etc.</li>
</ul>
<p>可以看出，这个限制非常严格，在此限制下也就不难理解为什么我们的<code>HTML</code>没法正常展示样式了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><p>要解决该问题，方式也比较简单，就是修改<code>Content Security Policy</code>的默认配置。</p>
<p>修改方式为，进入<code>Manage Jenkins</code>-&gt;<code>Script console</code>，输入如下命令并进行执行。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"hudson.model.DirectoryBrowserSupport.CSP"</span>, <span class="string">""</span>)</div></pre></td></tr></table></figure>
<p>当看到如下结果后，则说明配置修改已经生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Result</div><div class="line">Result:</div></pre></td></tr></table></figure>
<p>再次进行构建，新生成的<code>HTML</code>就可以正常展示样式了。需要说明的是，该操作对之前构建生成的<code>HTML</code>报告无效。</p>
<h3 id="永久解决方案"><a href="#永久解决方案" class="headerlink" title="永久解决方案"></a>永久解决方案</h3><p>不过，该方法还存在一个问题：该配置只是临时生效，当重启<code>Jenkins</code>后，<code>Content Security Policy</code>又会恢复为默认值，从而<code>HTML</code>样式又没法展示了。</p>
<p>当前，<code>Jenkins</code>官方还没有相应的解决方法，我们只能在每次启动或重启<code>Jenkins</code>时，重新修改该安全策略。</p>
<p>如果手工地来重复这项工作，也是可行，但并不是一个好的解决方案。</p>
<p>回到刚才的<code>Script console</code>，会发现我们执行的命令其实就是一段<code>Groovy</code>代码；那么，如果我们可以实现在<code>Jenkins</code>每次启动时自动地执行该<code>Groovy</code>代码，那么也就同样能解决我们的问题了。</p>
<p>好在<code>Jenkins</code>已经有相应的插件：</p>
<ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Startup+Trigger" target="_blank" rel="external"><code>Startup Trigger</code></a>: 可实现在<code>Jenkins</code>节点(master/slave)启动时触发构建；</li>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Groovy+plugin" target="_blank" rel="external"><code>Groovy plugin</code></a>: 可实现直接执行<code>Groovy</code>代码。</li>
</ul>
<p>搜索安装<code>startup-trigger-plugin</code>和<code>Groovy</code>插件后，我们就可以进行配置了。</p>
<p>配置方式如下：</p>
<ul>
<li>新建一个job，该job专门用于<code>Jenkins</code>启动时执行的配置命令；</li>
<li>在<code>Build Triggers</code>模块下，勾选<code>Build when job nodes start</code>；</li>
<li>在<code>Build</code>模块下，<code>Add build step</code>-&gt;<code>Execute system Groovy script</code>，在<code>Groovy Script</code>中输入配置命令，<code>System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;, &quot;&quot;)</code>。</li>
</ul>
<p>需要注意的是，添加构建步骤的时候，应该选择<code>Execute system Groovy script</code>，而不是<code>Execute Groovy script</code>。关于这两者之间的差异，简单地说，<code>Groovy Script</code>相当于是运行在<code>master/slave</code>系统<code>JVM</code>环境中，而<code>system groovy script</code>，则是运行在<code>Jenkins master</code>的<code>JVM</code>环境中，与前面提到的<code>Jenkins Script Console</code>功能相同。如需了解更多信息，可查看<a href="https://wiki.jenkins.io/display/JENKINS/Groovy+plugin" target="_blank" rel="external"><code>Groovy plugin</code>的详细说明</a>。</p>
<p>至此，我们就彻底解决<code>HTML</code>样式展示异常的问题了。</p>
<p>但还有一点需要格外注意，在本文的演示中，我们修改<code>CSP</code>（<code>Content Security Policy</code>）配置时关闭了的所有安全保护策略，即将<code>hudson.model.DirectoryBrowserSupport.CSP</code>设置为空，其实这是存在很大的安全隐患的。</p>
<p>正确的做法，我们应该是结合项目的实际情况，选择对应的安全策略。例如，如果我们需要开启脚本文件加载，但是只限于Jenkins服务器上托管的<code>CSS</code>文件，那么就可以采用如下配置。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"hudson.model.DirectoryBrowserSupport.CSP"</span>, <span class="string">"sandbox; style-src 'self';"</span>)</div></pre></td></tr></table></figure>
<p>除此之外，<code>CSP</code>可以实现非常精细的权限配置，详细配置可参考<a href="https://content-security-policy.com/" target="_blank" rel="external"><code>Content Security Policy Reference</code></a>。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Configuring+Content+Security+Policy" target="_blank" rel="external">Configuring Content Security Policy</a></li>
<li><a href="https://content-security-policy.com/" target="_blank" rel="external">Content Security Policy Reference</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;对于测试报告来说，除了内容的简洁精炼，样式的美观也很重要。常用的做法是，采用&lt;code&gt;HTML&lt;/code&gt;格式的文档，并
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://debugtalk.com/tags/Jenkins/"/>
    
      <category term="Plugin" scheme="http://debugtalk.com/tags/Plugin/"/>
    
      <category term="测试报告" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
    
      <category term="持续集成" scheme="http://debugtalk.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 演进之路（4）测试用例中实现 Python 函数的调用</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-4-call-functions-in-yaml-testcases/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-4-call-functions-in-yaml-testcases/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/">《测试用例中实现<code>Python</code>函数的定义》</a>中，介绍了在<code>YAML/JSON</code>测试用例中实现<code>Python</code>函数定义的两种方法，以及它们各自适用的场景。</p>
<p>但是在<code>YAML/JSON</code>文本中要怎样实现函数的调用和传参呢？</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">variables:</span></div><div class="line"><span class="attr">   - TOKEN:</span> debugtalk</div><div class="line"><span class="attr">   - json:</span> &#123;&#125;</div><div class="line"><span class="attr">   - random:</span> $&#123;gen_random_string(<span class="number">5</span>)&#125;</div><div class="line"><span class="attr">   - authorization:</span> $&#123;gen_md5($TOKEN, $json, $random)&#125;</div></pre></td></tr></table></figure>
<p>例如上面的例子（YAML格式），<code>gen_random_string</code>和<code>gen_md5</code>都是已经定义好的函数，但<code>${gen_random_string(5)}</code>和<code>${gen_md5($TOKEN, $json, $random)}</code>终究只是文本字符串，程序是如何将其解析为实际的函数和参数，并实现调用的呢？</p>
<p>本文将对此进行重点讲解。</p>
<h2 id="函数的调用形式"><a href="#函数的调用形式" class="headerlink" title="函数的调用形式"></a>函数的调用形式</h2><p>在<code>Python</code>语言中，函数的调用形式包含如下四种形式：</p>
<ul>
<li>无参数：func()</li>
<li>顺序参数：func(a, b)</li>
<li>字典参数：func(a=1, b=2)</li>
<li>混合类型参数：func(1, 2, a=3, b=4)</li>
</ul>
<p>之前在<a href="http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/">《探索优雅的测试用例描述方式》</a>中介绍过，我们选择使用<code>${}</code>作为函数转义符，在<code>YAML/JSON</code>用例描述中调用已经定义好的函数。</p>
<p>于是，以上四种类型的函数定义在<code>YAML/JSON</code>中就会写成如下样子。</p>
<ul>
<li>无参数：${func()}</li>
<li>顺序参数：${func(a, b)}</li>
<li>字典参数：${func(a=1, b=2)}</li>
<li>混合类型参数：${func(1, 2, a=3, b=4)}</li>
</ul>
<p>还是之前的例子：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    import_module_functions:</span></div><div class="line"><span class="bullet">        -</span> tests.data.custom_functions</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - TOKEN:</span> debugtalk</div><div class="line"><span class="attr">        - json:</span> &#123;<span class="string">"name"</span>: <span class="string">"user"</span>, <span class="string">"password"</span>: <span class="string">"123456"</span>&#125;</div><div class="line"><span class="attr">        - random:</span> $&#123;gen_random_string(<span class="number">5</span>)&#125;</div><div class="line"><span class="attr">        - authorization:</span> $&#123;gen_md5($TOKEN, $json, $random)&#125;</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">            authorization:</span> $authorization</div><div class="line"><span class="attr">            random:</span> $random</div><div class="line"><span class="attr">        json:</span> $json</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>在这里面有一个<code>variables</code>模块，之前已经出现过很多次，也一直都没有讲解。但是，本文也不打算进行讲解，该部分内容将在下一篇讲解参数的定义和引用时再详细展开。</p>
<p>当前我们只需要知道，在该用例描述中，<code>${gen_random_string(5)}</code>和<code>${gen_md5($TOKEN, $json, $random)}</code>均实现了函数的传参和调用，而调用的函数正式之前我们定义的<code>gen_random_string</code>和<code>gen_md5</code>。</p>
<p>这里应该比较好理解，因为函数调用形式与在<code>Python</code>脚本中完全相同。但难点在于，这些描述在<code>YAML/JSON</code>中都是文本字符串形式，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>在加载测试用例的时候，是怎么识别出函数并完成调用的呢？</p>
<p>具体地，这里可以拆分为三个需求点：</p>
<ul>
<li>如何在<code>YAML/JSON</code>文本中识别函数？</li>
<li>如何将文本字符串的函数拆分为函数名称和参数？</li>
<li>如何使用函数名称和参数实现对应函数的调用？</li>
</ul>
<h2 id="正则表达式的妙用"><a href="#正则表达式的妙用" class="headerlink" title="正则表达式的妙用"></a>正则表达式的妙用</h2><p>对于第一个需求点，我们之前已经做好了铺垫，设计了<code>${}</code>作为函数的转义符；而当初之所以这么设计，也是为了在加载测试用例时便于解析识别，因为我们可以通过使用正则表达式，非常准确地将函数从文本格式的测试用例中提取出来。</p>
<p>既然<code>Python</code>函数的调用形式是确定的，都是<code>函数名(参数)</code>的形式，那么使用正则表达式的分组匹配功能，我们就可以很好地实现函数名称与参数的匹配，也就实现了第二个需求点。</p>
<p>例如，我们可以采用如下正则表达式，来对<code>YAML/JSON</code>中的每一个值（Value）进行匹配性检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r&quot;^\$\&#123;(\w+)\((.*)\)\&#125;$&quot;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import re</div><div class="line">&gt;&gt;&gt; regex = r<span class="string">"^\$\&#123;(\w+)\((.*)\)\&#125;$"</span></div><div class="line">&gt;&gt;&gt; string = <span class="string">"<span class="variable">$&#123;func(3, 5)&#125;</span>"</span></div><div class="line">&gt;&gt;&gt; matched = re.match(regex, string)</div><div class="line">&gt;&gt;&gt; matched.group(1)</div><div class="line"><span class="string">'func'</span></div><div class="line">&gt;&gt;&gt; matched.group(2)</div><div class="line"><span class="string">'3, 5'</span></div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; string = <span class="string">"<span class="variable">$&#123;func(a=1, b=2)&#125;</span>"</span></div><div class="line">&gt;&gt;&gt; matched = re.match(regex, string)</div><div class="line">&gt;&gt;&gt; matched.group(1)</div><div class="line"><span class="string">'func'</span></div><div class="line">&gt;&gt;&gt; matched.group(2)</div><div class="line"><span class="string">'a=1, b=2'</span></div></pre></td></tr></table></figure>
<p>可以看出，通过如上正则表达式，如果满足匹配条件，那么<code>matched.group(1)</code>就是函数的名称，<code>matched.group(2)</code>就是函数的参数。</p>
<p>思路是完全可行的，不过我们在匹配参数部分的时候是采用<code>.*</code>的形式，也就是任意字符匹配，匹配的方式不是很严谨。考虑到正常的函数参数部分可能使用到的字符，我们可以采用如下更严谨的正则表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">r&quot;^\$\&#123;(\w+)\(([\$\w =,]*)\)\&#125;$&quot;</div></pre></td></tr></table></figure>
<p>这里限定了五种可能用到的字符，<code>\w</code>代表任意字母或数字，<code>= ,</code>代表的是等号、空格和逗号，这些都是参数中可能用到的。而<code>\$</code>符号，大家应该还记得，这也是我们设计采用的变量转义符，<code>$var</code>将不再代表的是普遍的字符串，而是<code>var</code>变量的值。</p>
<p>有了这个基础，实现如下<code>is_functon</code>函数，就可以判断某个字符串是否为函数调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function_regexp = re.compile(<span class="string">r"^\$\&#123;(\w+)\(([\$\w =,]*)\)\&#125;$"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_functon</span><span class="params">(content)</span>:</span></div><div class="line">    matched = function_regexp.match(content)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> matched <span class="keyword">else</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>不过这里还有一个问题。通过上面的正则表达式，是可以将函数名称和参数部分拆分开了，但是在参数部分，还没法区分具体的参数类型。</p>
<p>例如，在前面的例子中，从<code>${func(3, 5)}</code>解析出来的参数为<code>3, 5</code>，从<code>${func(a=1, b=2)}</code>解析出来的参数为<code>a=1, b=2</code>，我们通过肉眼可以识别出这分别对应着顺序参数和字典参数两种类型，但是程序就没法自动识别了，毕竟对于程序来说它们都只是字符串而已。</p>
<p>所以，这里还需要再做一步操作，就是将参数字符串解析为对程序友好的形式。</p>
<p>什么叫对程序友好的形式呢？这里就又要用到<a href="http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/">上一篇文章</a>讲到的可变参数和关键字参数形式了，也就是<code>func(*args, **kwargs)</code>的形式。</p>
<p>试想，如果我们可以将所有顺序参数都转换为<code>args</code>列表，将所有字典参数都转换为<code>kwargs</code>字典，那么对于任意函数类型，我们都可以采用<code>func(*args, **kwargs)</code>的调用形式。</p>
<p>于是，问题就转换为，如何将参数部分转换为<code>args</code>和<code>kwargs</code>两部分。</p>
<p>这就比较简单了。因为在函数的参数部分，顺序参数必须位于字典参数前面，并且以逗号间隔；而字典参数呢，总是以<code>key=value</code>的形式出现，并且也以逗号间隔。</p>
<p>那么我们就可以利用参数部分的这个特征，来进行字符串的处理。处理算法如下：</p>
<ul>
<li>采用逗号作为分隔符将字符串进行拆分；</li>
<li>对每一部分进行判断，如果不包含等号，那么就是顺序参数，将其加入（<code>append</code>）到<code>args</code>列表；</li>
<li>如果包含等号，那么就是字典参数，采用等号作为分隔符进行进一步拆分得到<code>key-value</code>键值对，然后再加入到<code>kwargs</code>字典。</li>
</ul>
<p>对应的<code>Python</code>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_function</span><span class="params">(content)</span>:</span></div><div class="line">    function_meta = &#123;</div><div class="line">        <span class="string">"args"</span>: [],</div><div class="line">        <span class="string">"kwargs"</span>: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    matched = function_regexp.match(content)</div><div class="line">    function_meta[<span class="string">"func_name"</span>] = matched.group(<span class="number">1</span>)</div><div class="line"></div><div class="line">    args_str = matched.group(<span class="number">2</span>).replace(<span class="string">" "</span>, <span class="string">""</span>)</div><div class="line">    <span class="keyword">if</span> args_str == <span class="string">""</span>:</div><div class="line">        <span class="keyword">return</span> function_meta</div><div class="line"></div><div class="line">    args_list = args_str.split(<span class="string">','</span>)</div><div class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args_list:</div><div class="line">        <span class="keyword">if</span> <span class="string">'='</span> <span class="keyword">in</span> arg:</div><div class="line">            key, value = arg.split(<span class="string">'='</span>)</div><div class="line">            function_meta[<span class="string">"kwargs"</span>][key] = parse_string_value(value)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            function_meta[<span class="string">"args"</span>].append(parse_string_value(arg))</div><div class="line"></div><div class="line">    <span class="keyword">return</span> function_meta</div></pre></td></tr></table></figure>
<p>可以看出，通过<code>parse_function</code>函数，可以将一个函数调用的字符串转换为函数的结构体。</p>
<p>例如，<code>${func(1, 2, a=3, b=4)}</code>字符串，经过<code>parse_function</code>转换后，就可以得到该函数的名称和参数信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function_meta = &#123;</div><div class="line">    'func_name': 'func',</div><div class="line">    'args': [1, 2],</div><div class="line">    'kwargs': &#123;'a':3, 'b':4&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这也就彻底解决了第二个需求点。</p>
<h2 id="实现函数的调用"><a href="#实现函数的调用" class="headerlink" title="实现函数的调用"></a>实现函数的调用</h2><p>在此基础上，我们再看第三个需求点，如何使用函数名称和参数实现对应函数的调用，其实也就很简单了。</p>
<p>在<a href="http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/">上一篇文章</a>中，我们实现了对函数的定义，并且将所有定义好的函数都添加到了一个字典当中，假如字典名称为<code>custom_functions_dict</code>，那么根据以上的函数信息（<code>function_meta</code>），就可以采用如下方式进行调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">func_name = function_meta[<span class="string">'func_name'</span>]</div><div class="line">args = function_meta[<span class="string">'args'</span>]</div><div class="line">kwargs = function_meta[<span class="string">'kwargs'</span>]</div><div class="line">custom_functions_dict[func_name]](*args, **kwargs)</div></pre></td></tr></table></figure>
<p>具体的，在<code>ApiTestEngine</code>中对应的<code>Python</code>代码片段如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_eval_value</span><span class="params">(self, data)</span>:</span></div><div class="line">   <span class="string">""" evaluate data recursively, each variable in data will be evaluated.</span></div><div class="line">   """</div><div class="line">   <span class="keyword">if</span> isinstance(data, (list, tuple)):</div><div class="line">       <span class="keyword">return</span> [self.get_eval_value(item) <span class="keyword">for</span> item <span class="keyword">in</span> data]</div><div class="line"></div><div class="line">   <span class="keyword">if</span> isinstance(data, dict):</div><div class="line">       evaluated_data = &#123;&#125;</div><div class="line">       <span class="keyword">for</span> key, value <span class="keyword">in</span> data.items():</div><div class="line">           evaluated_data[key] = self.get_eval_value(value)</div><div class="line"></div><div class="line">       <span class="keyword">return</span> evaluated_data</div><div class="line"></div><div class="line">   <span class="keyword">if</span> isinstance(data, (int, float)):</div><div class="line">       <span class="keyword">return</span> data</div><div class="line"></div><div class="line">   <span class="comment"># data is in string format here</span></div><div class="line">   data = <span class="string">""</span> <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> data.strip()</div><div class="line">   <span class="keyword">if</span> utils.is_variable(data):</div><div class="line">       <span class="comment"># variable marker: $var</span></div><div class="line">       variable_name = utils.parse_variable(data)</div><div class="line">       value = self.testcase_variables_mapping.get(variable_name)</div><div class="line">       <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">           <span class="keyword">raise</span> exception.ParamsError(</div><div class="line">               <span class="string">"%s is not defined in bind variables!"</span> % variable_name)</div><div class="line">       <span class="keyword">return</span> value</div><div class="line"></div><div class="line">   <span class="keyword">elif</span> utils.is_functon(data):</div><div class="line">       <span class="comment"># function marker: $&#123;func(1, 2, a=3, b=4)&#125;</span></div><div class="line">       fuction_meta = utils.parse_function(data)</div><div class="line">       func_name = fuction_meta[<span class="string">'func_name'</span>]</div><div class="line">       args = fuction_meta.get(<span class="string">'args'</span>, [])</div><div class="line">       kwargs = fuction_meta.get(<span class="string">'kwargs'</span>, &#123;&#125;)</div><div class="line">       args = self.get_eval_value(args)</div><div class="line">       kwargs = self.get_eval_value(kwargs)</div><div class="line">       <span class="keyword">return</span> self.testcase_config[<span class="string">"functions"</span>][func_name](*args, **kwargs)</div><div class="line">   <span class="keyword">else</span>:</div><div class="line">       <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<p>这里还用到了递归的概念，当参数是变量（例如<code>gen_md5($TOKEN, $json, $random)</code>），或者为列表、字典等嵌套类型时，也可以实现正常的解析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，我们就解决了测试用例（<code>YAML/JSON</code>）中实现<code>Python</code>函数定义和调用的问题。</p>
<p>还记得<a href="http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/">《探索优雅的测试用例描述方式》</a>末尾提到的用例模板引擎技术实现的三大块内容么？</p>
<ul>
<li>如何在用例描述（<code>YAML/JSON</code>）中实现函数的定义和调用</li>
<li>如何在用例描述中实现参数的定义和引用，包括用例内部和用例集之间</li>
<li>如何在用例描述中实现预期结果的描述和测试结果的校验</li>
</ul>
<p>第一块总算是讲完了，下一篇文章将开始讲解如何在用例描述中实现参数的定义和引用的问题。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/">《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/">《ApiTestEngine 演进之路（3）测试用例中实现<code>Python</code>函数的定义》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/&quot;&gt;《测试用例中实现&lt;code&gt;Python&lt;/code&gt;函数的定义》&lt;/a&gt;中，介绍了在&lt;code
    
    </summary>
    
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="自动化测试" scheme="http://debugtalk.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 演进之路（3）测试用例中实现 Python 函数的定义</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-3-define-functions-in-yaml-testcases/</id>
    <published>2017-07-10T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/">《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》</a>中，我们臆想了一种简洁优雅的用例描述方式，接下来，我们就从技术实现的角度，逐项进行深入讲解，将臆想变成现实。</p>
<p>本文先解决第一个问题，“如何在用例描述（<code>YAML/JSON</code>）中实现函数的定义和调用”。</p>
<blockquote>
<p>在写作的过程中，发现要将其中的原理阐述清楚，要写的内容实在是太多，因此将问题再拆分为“函数定义”和“函数调用”两部分，本文只讲解“函数定义”部分的内容。</p>
</blockquote>
<h2 id="实现函数的定义"><a href="#实现函数的定义" class="headerlink" title="实现函数的定义"></a>实现函数的定义</h2><p>在之前，我们假设存在<code>gen_random_string</code>这样一个生成指定位数随机字符串的函数，以及<code>gen_md5</code>这样一个计算签名校验值的函数，我们不妨先尝试通过<code>Python</code>语言进行具体的实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> string</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(</div><div class="line">        random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_md5</span><span class="params">(*args)</span>:</span></div><div class="line">    <span class="keyword">return</span> hashlib.md5(<span class="string">""</span>.join(args).encode(<span class="string">'utf-8'</span>)).hexdigest()</div><div class="line"></div><div class="line">gen_random_string(<span class="number">5</span>) <span class="comment"># =&gt; A2dEx</span></div><div class="line"></div><div class="line">TOKEN = <span class="string">"debugtalk"</span></div><div class="line">data = <span class="string">'&#123;"name": "user", "password": "123456"&#125;'</span></div><div class="line">random = <span class="string">"A2dEx"</span></div><div class="line">gen_md5(TOKEN, data, random) <span class="comment"># =&gt; a83de0ff8d2e896dbd8efb81ba14e17d</span></div></pre></td></tr></table></figure>
<p>熟悉<code>Python</code>语言的人对以上代码应该都不会有理解上的难度。可能部分新接触<code>Python</code>的同学对<code>gen_md5</code>函数的<code>*args</code>传参方式会比较陌生，我也简单地补充下基础知识。</p>
<p>在<code>Python</code>中，函数参数共有四种，必选参数、默认参数、可变参数和关键字参数。</p>
<p>必选参数和默认参数大家应该都很熟悉，绝大多数编程语言里面都有类似的概念。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y, a=<span class="number">1</span>, b=<span class="number">2</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y + a + b</div><div class="line"></div><div class="line">func(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># =&gt; 6</span></div><div class="line">func(<span class="number">1</span>, <span class="number">2</span>, b=<span class="number">3</span>) <span class="comment"># =&gt; 7</span></div></pre></td></tr></table></figure>
<p>在上面例子中，<code>x</code>和<code>y</code>是必选参数，<code>a</code>和<code>b</code>是默认参数。除了显示地定义必选参数和默认参数，我们还可以通过使用可变参数和关键字参数的形式，实现更灵活的函数参数定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">return</span> sum(args) + sum(kwargs.values())</div><div class="line"></div><div class="line">args = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">kwargs = &#123;<span class="string">'a'</span>:<span class="number">3</span>, <span class="string">'b'</span>:<span class="number">4</span>&#125;</div><div class="line">func(*args, **kwargs) <span class="comment"># =&gt; 10</span></div><div class="line"></div><div class="line">args = []</div><div class="line">kwargs = &#123;<span class="string">'a'</span>:<span class="number">3</span>, <span class="string">'b'</span>:<span class="number">4</span>, <span class="string">'c'</span>: <span class="number">5</span>&#125;</div><div class="line">func(*args, **kwargs) <span class="comment"># =&gt; 12</span></div></pre></td></tr></table></figure>
<p>之所以说更灵活，是因为当使用可变参数和关键字参数时（<code>func(*args, **kwargs)</code>），我们在调用函数时就可以传入0个或任意多个必选参数和默认参数，所有必选参数将作为<code>tuple/list</code>的形式传给可变参数（<code>args</code>），并将所有默认参数作为<code>dict</code>的形式传给关键字参数（<code>kwargs</code>）。另外，可变参数和关键字参数也并不是要同时使用，只使用一种也是可以的。</p>
<p>在前面定义的<code>gen_md5(*args)</code>函数中，我们就可以将任意多个字符串传入，然后得到拼接字符串的<code>MD5</code>值。</p>
<p>现在再回到测试用例描述文件，由于是纯文本格式（<code>YAML/JSON</code>），我们没法直接写<code>Python</code>代码，那要怎样才能定义函数呢？</p>
<p>之前接触过一些函数式编程，所以我首先想到的是借助<code>lambda</code>实现匿名函数。如果对函数式编程不了解，可以看下我之前写过的一篇文章，<a href="http://debugtalk.com/post/python-functional-programming-getting-started/">《Python的函数式编程–从入门到⎡放弃⎦》</a>。</p>
<h2 id="方法一：通过lambda实现函数定义"><a href="#方法一：通过lambda实现函数定义" class="headerlink" title="方法一：通过lambda实现函数定义"></a>方法一：通过lambda实现函数定义</h2><p>使用<code>lambda</code>有什么好处呢？</p>
<p>最简单直接的一点，通过<code>lambda</code>关键字，我们可以将函数写到一行里面。例如，同样是前面提到的<code>gen_random_string</code>函数和<code>gen_md5</code>函数，通过<code>lambda</code>的实现方式就是如下的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gen_random_string = <span class="keyword">lambda</span> str_len: <span class="string">''</span>.join(random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len))</div><div class="line">gen_md5 = <span class="keyword">lambda</span> *str_args: hashlib.md5(<span class="string">''</span>.join(str_args).encode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line">gen_random_string(<span class="number">5</span>) <span class="comment"># =&gt; A2dEx</span></div><div class="line"></div><div class="line">TOKEN = <span class="string">"debugtalk"</span></div><div class="line">data = <span class="string">'&#123;"name": "user", "password": "123456"&#125;'</span></div><div class="line">random = <span class="string">"A2dEx"</span></div><div class="line">gen_md5(TOKEN, data, random) <span class="comment"># =&gt; a83de0ff8d2e896dbd8efb81ba14e17d</span></div></pre></td></tr></table></figure>
<p>可以看出，采用<code>lambda</code>定义的函数跟之前的函数功能完全一致，调用方式相同，运算结果也完全一样。</p>
<p>然后，我们在测试用例里面，通过新增一个<code>function_binds</code>模块，就可以将函数定义与函数名称绑定了。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    function_binds:</span></div><div class="line"><span class="attr">        gen_random_string:</span> <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></div><div class="line"><span class="attr">        gen_md5:</span> <span class="string">"lambda *str_args: hashlib.md5(''.join(str_args).encode('utf-8'))</span></div><div class="line">    variables:</div><div class="line">        - TOKEN: debugtalk</div><div class="line">        - random: $&#123;gen_random_string(5)&#125;</div><div class="line">        - json: &#123;"name<span class="string">": "</span>user<span class="string">", "</span>password<span class="string">": "</span><span class="number">123456</span><span class="string">"&#125;</span></div><div class="line">        - authorization: $&#123;gen_md5($TOKEN, $json, $random)&#125;</div></pre></td></tr></table></figure>
<p>可能有些同学还是无法理解，在上面<code>YAML</code>文件中，即使将函数定义与函数名称绑定了，但是加载<code>YAML</code>文件后，函数名称对应的值也只是一个字符串而已，这还是没法运行啊。</p>
<p>这就又要用到<code>eval</code>黑科技了。通过<code>eval</code>函数，可以执行字符串表达式，并返回表达式的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gen_random_string = <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></div><div class="line"></div><div class="line">func = eval(gen_random_string)</div><div class="line"></div><div class="line">func <span class="comment"># =&gt; &lt;function &lt;lambda&gt; at 0x10e19a398&gt;</span></div><div class="line">func(<span class="number">5</span>) <span class="comment"># =&gt; "A2dEx"</span></div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>gen_random_string</code>为<code>lambda</code>字符串表达式，通过<code>eval</code>执行后，就转换为一个函数对象，然后就可以像正常定义的函数一样调用了。</p>
<p>如果你看到这里还没有疑问，那么说明你肯定没有亲自实践。事实上，上面执行<code>func(5)</code>的时候并不会返回预期结果，而是会抛出如下异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; func(5)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;string&gt;"</span>, line 1, <span class="keyword">in</span> &lt;lambda&gt;</div><div class="line">  File <span class="string">"&lt;string&gt;"</span>, line 1, <span class="keyword">in</span> &lt;genexpr&gt;</div><div class="line">NameError: global name <span class="string">'random'</span> is not defined</div></pre></td></tr></table></figure>
<p>这是因为，我们在定义的<code>lambda</code>函数中，用到了<code>random</code>库，而在<code>lambda</code>表达式中，我们并没有<code>import random</code>。</p>
<p>这下麻烦了，很多时候我们的函数都要用到标准库或者第三方库，而在调用这些库函数之前，我们必须得先<code>import</code>。想来想去，这个<code>import</code>的操作都没法塞到<code>lambda</code>表达式中。</p>
<p>为了解决这个依赖库的问题，我想到两种方式。</p>
<p>第一种方式，在加载<code>YAML/JSON</code>用例之前，先统一将测试用例依赖的所有库都<code>import</code>一遍。这个想法很快就被否决了，因为这必须要在<code>ApiTestEngine</code>框架里面去添加这部分代码，而且每个项目的依赖库不一样，需要<code>import</code>的库也不一样，总不能为了解决这个问题，在框架初始化部分将所有的库都<code>import</code>吧？而且为了适配不同项目来改动测试框架的代码，也不是通用测试框架应有的做法。</p>
<p>然后我想到了第二种方式，就是在测试用例里面，通过新增一个<code>requires</code>模块，罗列出当前测试用例所有需要引用的库，然后在加载用例的时候通过代码动态地进行导入依赖库。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    requires:</span></div><div class="line"><span class="bullet">        -</span> random</div><div class="line"><span class="bullet">        -</span> string</div><div class="line"><span class="bullet">        -</span> hashlib</div><div class="line"><span class="attr">    function_binds:</span></div><div class="line"><span class="attr">        gen_random_string:</span> <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></div><div class="line"><span class="attr">        gen_md5:</span> <span class="string">"lambda *str_args: hashlib.md5(''.join(str_args).encode('utf-8'))</span></div><div class="line">    variables:</div><div class="line">        - TOKEN: debugtalk</div><div class="line">        - random: $&#123;gen_random_string(5)&#125;</div><div class="line">        - json: &#123;"name<span class="string">": "</span>user<span class="string">", "</span>password<span class="string">": "</span><span class="number">123456</span><span class="string">"&#125;</span></div><div class="line">        - authorization: $&#123;gen_md5($TOKEN, $json, $random)&#125;</div></pre></td></tr></table></figure>
<p>动态地导入依赖库？其实也没有多玄乎，<code>Python</code>本身也支持这种特性。如果你看到这里感觉无法理解，那么我再补充点基础知识。</p>
<p>在<code>Python</code>中执行<code>import</code>时，实际上等价于执行<code>__import__</code>函数。</p>
<p>例如，<code>import random</code>等价于如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">random = __import__(<span class="string">'random'</span>, globals(), locals(), [], <span class="number">-1</span>)</div></pre></td></tr></table></figure>
<p>其中，<code>__import__</code>的函数定义为<code>__import__(name[, globals[, locals[, fromlist[, level]]]])</code>，第一个参数为库的名称，后面的参数暂不用管（可直接查看<a href="https://docs.python.org/3/library/functions.html#__import__" target="_blank" rel="external">官方文档</a>）。</p>
<p>由于后面的参数都有默认值，通常情况下我们采用默认值即可，因此我们也可以简化为如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">random = __import__(<span class="string">'random'</span>)</div></pre></td></tr></table></figure>
<p>执行这个语句的有什么效果呢？</p>
<p>可能这也是大多数<code>Python</code>初学者都忽略的一个知识点。在<code>Python</code>运行环境中，有一个全局的环境变量，当我们定义一个函数，或者引入一个依赖库时，实际上就是将其对象添加到了全局的环境变量中。</p>
<p>这个全局的环境变量就是<code>globals()</code>，它是一个字典类型的数据结构。要验证以上知识点，我们可以在<code>Python</code>的交互终端中进行如下实验。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ python</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; <span class="function"><span class="title">globals</span></span>()</div><div class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;class <span class="string">'_frozen_importlib.BuiltinImporter'</span>&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;&#125;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; import random</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; <span class="function"><span class="title">globals</span></span>()</div><div class="line">&#123;<span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: None, <span class="string">'__package__'</span>: None, <span class="string">'__loader__'</span>: &lt;class <span class="string">'_frozen_importlib.BuiltinImporter'</span>&gt;, <span class="string">'__spec__'</span>: None, <span class="string">'__annotations__'</span>: &#123;&#125;, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-in)&gt;, <span class="string">'random'</span>: &lt;module <span class="string">'random'</span> from <span class="string">'/Users/Leo/.pyenv/versions/3.6.0/lib/python3.6/random.py'</span>&gt;&#125;</div></pre></td></tr></table></figure>
<p>可以看出，在执行<code>import random</code>命令后，<code>globals()</code>中就新增了<code>random</code>函数的引用。</p>
<p>因此，导入<code>random</code>依赖库时，我们采用如下的写法也是等价的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">module_name = ”random“</div><div class="line">globals()[module_name] = __import__(module_name)</div></pre></td></tr></table></figure>
<p>更进一步，<code>__import__</code>作为<code>Python</code>的底层函数，其实是不推荐直接调用的。要实现同样的功能，推荐使用<code>importlib.import_module</code>。替换后就变成了如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">module_name = ”random“</div><div class="line">globals()[module_name] = importlib.import_module(module_name)</div></pre></td></tr></table></figure>
<p>如果理解了以上的知识点，那么再给我们一个依赖库名称（字符串形式）的列表时，我们就可以实现动态的导入（<code>import</code>）了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_requires</span><span class="params">(modules)</span>:</span></div><div class="line">   <span class="string">""" import required modules dynamicly</span></div><div class="line">   """</div><div class="line">   <span class="keyword">for</span> module_name <span class="keyword">in</span> modules:</div><div class="line">       globals()[module_name] = importlib.import_module(module_name)</div></pre></td></tr></table></figure>
<p>在实现了定义<code>lambda</code>函数的<code>function_binds</code>和导入依赖库的<code>requires</code>模块之后，我们就可以在<code>YAML/JSON</code>中灵活地描述测试用例了。</p>
<p>还是之前的例子，完整的测试用例描述形式就为如下样子。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    requires:</span></div><div class="line"><span class="bullet">        -</span> random</div><div class="line"><span class="bullet">        -</span> string</div><div class="line"><span class="bullet">        -</span> hashlib</div><div class="line"><span class="attr">    function_binds:</span></div><div class="line"><span class="attr">        gen_random_string:</span> <span class="string">"lambda str_len: ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(str_len))"</span></div><div class="line"><span class="attr">        gen_md5:</span> <span class="string">"lambda *str_args: hashlib.md5(''.join(str_args).encode('utf-8')).hexdigest()"</span></div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - TOKEN:</span> debugtalk</div><div class="line"><span class="attr">        - random:</span> $&#123;gen_random_string(<span class="number">5</span>)&#125;</div><div class="line"><span class="attr">        - data:</span> <span class="string">'&#123;"name": "user", "password": "123456"&#125;'</span></div><div class="line"><span class="attr">        - authorization:</span> $&#123;gen_md5($TOKEN, $data, $random)&#125;</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">            authorization:</span> $authorization</div><div class="line"><span class="attr">            random:</span> $random</div><div class="line"><span class="attr">        data:</span> $data</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以在<code>YAML/JSON</code>文本中⎡灵活⎦地定义函数，实现各种功能了。</p>
<p>可是，这真的是我们期望的样子么？</p>
<p>开始的时候，我们想在自动化测试中将<code>测试数据</code>与<code>代码实现</code>进行分离，于是我们引入了<code>YAML/JSON</code>格式的用例形式；为了在<code>YAML/JSON</code>文本格式中实现签名校验等计算功能，我们又引入了<code>function_binds</code>模块，并通过<code>lambda</code>定义函数并与函数名进行绑定；再然后，为了解决定义函数中的依赖库问题，我们又引入了<code>requires</code>模块，动态地加载指定的依赖库。</p>
<p>而且即使是这样，这种方式也有一定的局限性，当函数较复杂的时候，我们很难将函数内容转换为<code>lambda</code>表达式；虽然理论上所有的函数都能转换为<code>lamda</code>表达式，但是实现的难度会非常高。</p>
<p>为了不写代码而人为引入了更多更复杂的概念和技术，这已经不再符合我们的初衷了。于是，我开始重新寻找新的实现方式。</p>
<h2 id="方法二：自定义函数模块并进行导入"><a href="#方法二：自定义函数模块并进行导入" class="headerlink" title="方法二：自定义函数模块并进行导入"></a>方法二：自定义函数模块并进行导入</h2><p>让我们再回归基础概念，当我们调用一个函数的时候，究竟发生了什么？</p>
<p>简单的说，不管是调用一个函数，还是引用一个变量，都会在当前的运行环境上下文（<code>context</code>）中寻找已经定义好的函数或变量。而在<code>Python</code>中，当我们加载一个模块（<code>module</code>）的时候，就会将该模块中的所有函数、变量、类等对象加载进当前的运行环境上下文。</p>
<p>如果单纯地看这个解释还不清楚，想必大家应该都见过如下案例的形式。假设<code>moduleA</code>模块包含如下定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># moduleA</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"hello, %s"</span> % name</div><div class="line"></div><div class="line">varA = <span class="string">"I am varA"</span></div></pre></td></tr></table></figure>
<p>那么，我们就可以通过如下方式导入<code>moduleA</code>模块中所有内容，并且直接调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> moduleA <span class="keyword">import</span> *</div><div class="line"></div><div class="line">print(hello(<span class="string">"debugtalk"</span>)) <span class="comment"># =&gt; hello, debugtalk</span></div><div class="line">print(varA) <span class="comment"># =&gt; I am varA</span></div></pre></td></tr></table></figure>
<p>明确这一点后，既然我们之前都可以动态地导入（<code>import</code>）依赖库，那么我们不妨再进一步，我们同样也可以动态地导入已经定义好的函数啊。</p>
<p>只要我们先在一个<code>Python</code>模块文件中定义好测试用例所需的函数，然后在运行测试用例的时候设法将模块中的所有函数导入即可。</p>
<p>于是，问题就转换为，如何在<code>YAML/JSON</code>中实现<code>from moduleA import *</code>机制。</p>
<p>经过摸索，我发现了<code>Python</code>的<a href="https://docs.python.org/3/library/functions.html#vars" target="_blank" rel="external"><code>vars</code>函数</a>，这也是<code>Python</code>的<code>Built-in Functions</code>之一。</p>
<p>对于<code>vars</code>，官方的定义如下：</p>
<blockquote>
<p>Return the <code>__dict__</code> attribute for a module, class, instance, or any other object with a <code>__dict__</code> attribute.</p>
</blockquote>
<p>简言之，就是<code>vars()</code>可以将模块（<code>module</code>）、类（<code>class</code>）、实例（<code>instance</code>）或者任意对象的所有属性（包括但不限于定义的方法和变量），以字典的形式返回。</p>
<p>还是前面举例的<code>moduelA</code>，相信大家看完下面这个例子就清晰了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import moduleA</div><div class="line">&gt;&gt;&gt; vars(moduleA)</div><div class="line">&gt;&gt;&gt; &#123;<span class="string">'hello'</span>: &lt;<span class="keyword">function</span> hello at 0x1072fcd90&gt;, <span class="string">'varA'</span>: <span class="string">'I am varA'</span>&#125;</div></pre></td></tr></table></figure>
<p>掌握了这一层理论基础，我们就可以继续改造我们的测试框架了。</p>
<p>我采取的做法是，在测试用例中新增一个<code>import_module_functions</code>模块，里面可填写多个模块的路径。而测试用例中所有需要使用的函数，都定义在对应路径的模块中。</p>
<p>我们再回到之前的案例，在测试用例中需要用到<code>gen_random_string</code>和<code>gen_md5</code>这两个函数函数，那么就可以将其定义在一个模块中，假设模块名称为<code>custom_functions.py</code>，相对于项目根目录的路径为<code>tests/data/custom_functions.py</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> string</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_random_string</span><span class="params">(str_len)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(</div><div class="line">        random.choice(string.ascii_letters + string.digits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(str_len))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_md5</span><span class="params">(*args)</span>:</span></div><div class="line">    <span class="keyword">return</span> hashlib.md5(<span class="string">""</span>.join(args).encode(<span class="string">'utf-8'</span>)).hexdigest()</div></pre></td></tr></table></figure>
<p>需要注意的是，这里的模块文件可以放置在系统的任意路径下，但是一定要保证它可作为<code>Python</code>的模块进行访问，也就是说在该文件的所有父目录中，都包含<code>__init__.py</code>文件。这是<code>Python</code>的语法要求，如不理解可查看官方文档。</p>
<p>然后，在<code>YAML/JSON</code>测试用例描述的<code>import_module_functions</code>栏目中，我们就可以写为<code>tests.data.custom_functions</code>。</p>
<p>新的用例描述形式就变成了如下样子。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    import_module_functions:</span></div><div class="line"><span class="bullet">        -</span> tests.data.custom_functions</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - TOKEN:</span> debugtalk</div><div class="line"><span class="attr">        - json:</span> &#123;<span class="string">"name"</span>: <span class="string">"user"</span>, <span class="string">"password"</span>: <span class="string">"123456"</span>&#125;</div><div class="line"><span class="attr">        - random:</span> $&#123;gen_random_string(<span class="number">5</span>)&#125;</div><div class="line"><span class="attr">        - authorization:</span> $&#123;gen_md5($TOKEN, $json, $random)&#125;</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">            authorization:</span> $authorization</div><div class="line"><span class="attr">            random:</span> $random</div><div class="line"><span class="attr">        json:</span> $json</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>现在函数已经定义好了，那是怎样实现动态加载的呢？</p>
<p>首先，还是借助于<code>importlib.import_module</code>，实现模块的导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imported = importlib.import_module(module_name)</div></pre></td></tr></table></figure>
<p>然后，借助于<code>vars</code>函数，可以获取得到模块的所有属性，也就是其中定义的方法、变量等对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vars(imported)</div></pre></td></tr></table></figure>
<p>不过，由于我们只需要定义的函数，因此我们还可以通过进行过滤，只获取模块中的所有方法对象。当然，这一步不是必须的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imported_functions_dict = dict(filter(is_function, vars(imported).items()))</div></pre></td></tr></table></figure>
<p>其中，<code>is_function</code>是一个检测指定对象是否为方法的函数，实现形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> types</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_function</span><span class="params">(tup)</span>:</span></div><div class="line">    <span class="string">""" Takes (name, object) tuple, returns True if it is a function.</span></div><div class="line">    """</div><div class="line">    name, item = tup</div><div class="line">    <span class="keyword">return</span> isinstance(item, types.FunctionType)</div></pre></td></tr></table></figure>
<p>通过以上代码，就实现了从指定外部模块加载所有方法的功能。完整的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_module_functions</span><span class="params">(self, modules, level=<span class="string">"testcase"</span>)</span>:</span></div><div class="line">   <span class="string">""" import modules and bind all functions within the context</span></div><div class="line">   """</div><div class="line">   <span class="keyword">for</span> module_name <span class="keyword">in</span> modules:</div><div class="line">       imported = importlib.import_module(module_name)</div><div class="line">       imported_functions_dict = dict(filter(is_function, vars(imported).items()))</div><div class="line">       self.__update_context_config(level, <span class="string">"functions"</span>, imported_functions_dict)</div></pre></td></tr></table></figure>
<p>结合到实际项目，我们就可以采取这种协作模式：</p>
<ul>
<li>由测试开发或者开发人员将项目中所有依赖的逻辑实现为函数方法，统一放置到一个模块中；</li>
<li>在<code>YAML/JSON</code>测试用例中，对模块进行引用；（对于测试用例集的模式，只需要引用一次，以后再详细讲解）</li>
<li>业务测试人员只需要关注接口的业务数据字段，设计测试用例即可。</li>
</ul>
<p>可以看出，这也算是软件工程和实际项目中的一种权衡之计，但好处在于能充分发挥各岗位角色人员的职能，有助于接口测试自动化工作的顺利开展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了在<code>YAML/JSON</code>测试用例中实现<code>Python</code>函数定义的两种方法：</p>
<ul>
<li>通过<code>lambda</code>实现函数的定义：该种方式适用于函数比较简单的情况，并且函数最好没有依赖库；虽然复杂的函数也能采用这种方式进行定义，但可能会存在一定的局限性，而且看上去也比较累赘。</li>
<li>自定义函数模块并进行导入：该种方式通用性更强，所有类型的函数都可以通过这种方式进行定义和引用；但由于需要编写额外的<code>Python</code>模块文件，在函数比较简单的情况下反而会显得较为繁琐，此时采用<code>lambda</code>形式会更简洁。</li>
</ul>
<p>到现在为止，我们已经清楚了如何在<code>YAML/JSON</code>测试用例中实现函数的定义，但是在<code>YAML/JSON</code>文本中要怎样实现函数的调用和传参呢？</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">variables:</span></div><div class="line"><span class="attr">   - TOKEN:</span> debugtalk</div><div class="line"><span class="attr">   - json:</span> &#123;&#125;</div><div class="line"><span class="attr">   - random:</span> $&#123;gen_random_string(<span class="number">5</span>)&#125;</div><div class="line"><span class="attr">   - authorization:</span> $&#123;gen_md5($TOKEN, $json, $random)&#125;</div></pre></td></tr></table></figure>
<p>例如上面的例子（YAML格式），<code>gen_random_string</code>和<code>gen_md5</code>都是已经定义好的函数，但<code>${gen_random_string(5)}</code>和<code>${gen_md5($TOKEN, $json, $random)}</code>终究只是文本字符串，程序是如何将其解析为真实的函数和参数，并实现调用的呢？</p>
<p>下篇文章再详细讲解。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="http://debugtalk.com/post/python-functional-programming-getting-started/">《Python的函数式编程–从入门到⎡放弃⎦》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/">《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/&quot;&gt;《ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式》&lt;/a&gt;中，我们臆想了一种简洁优雅的用例描
    
    </summary>
    
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="自动化测试" scheme="http://debugtalk.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="lambda" scheme="http://debugtalk.com/tags/lambda/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 演进之路（2）探索优雅的测试用例描述方式</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-2-best-testcase-description/</id>
    <published>2017-07-06T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/">《ApiTestEngine 演进之路（1）搭建基础框架》</a>一文中，我们完成了<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>基础框架的搭建，并实现了简单接口的测试功能。</p>
<p>接下来，我们就针对复杂类型的接口（例如包含签名校验等机制），通过对接口的业务参数和技术细节进行分离，实现简洁优雅的接口测试用例描述。</p>
<h2 id="传统的测试用例编写方式"><a href="#传统的测试用例编写方式" class="headerlink" title="传统的测试用例编写方式"></a>传统的测试用例编写方式</h2><p>对于在自动化测试中将<code>测试数据</code>与<code>代码实现</code>进行分离的好处，我之前已经讲过多次，这里不再重复。</p>
<p>测试数据与代码实现分离后，简单的接口还好，测试用例编写不会有什么问题；但是当面对复杂一点的接口（例如包含签名校验等机制）时，我们编写自动化测试用例还是会比较繁琐。</p>
<p>我们从一个最常见的案例入手，看下编写自动化测试用例的过程，相信大家看完后就会对上面那段话有很深的感受。</p>
<p>以API接口服务（<code>Mock Server</code>）的创建新用户功能为例，该接口描述如下：</p>
<blockquote>
<p>请求数据：<br>Url: <a href="http://127.0.0.1:5000/api/users/1000" target="_blank" rel="external">http://127.0.0.1:5000/api/users/1000</a><br>Method: POST<br>Headers: {“content-type”: “application/json”, “Random”: “A2dEx”, “Authorization”: “47f135c33e858f2e3f55156ae9f78ee1”}<br>Body: {“name”: “user1”, “password”: “123456”}</p>
<p>预期的正常响应数据：<br>Status_Code: 201<br>Headers: {‘Date’: ‘Fri, 23 Jun 2017 07:05:41 GMT’, ‘Content-Length’: ‘54’, ‘Content-Type’: ‘application/json’, ‘Server’: ‘Werkzeug/0.12.2 Python/2.7.13’}<br>Body: {“msg”: “user created successfully.”, “success”: true, “uuid”: “JsdfwerL”}</p>
</blockquote>
<p>其中，请求<code>Headers</code>中的<code>Random</code>字段是一个5位长的随机字符串，<code>Authorization</code>字段是一个签名值，签名方式为<code>TOKEN+RequestBody+Random</code>拼接字符串的<code>MD5</code>值。更具体的，<code>RequestBody</code>要求字典的<code>Key</code>值按照由小到大的排序方式。接口请求成功后，返回的是一个<code>JSON</code>结构，里面的<code>success</code>字段标识请求成功与否的状态，如果成功，<code>uuid</code>字段标识新创建用户的唯一ID。</p>
<p>相信只要是接触过接口测试的同学对此应该都会很熟悉，这也是后台系统普遍采用的签名校验方式。在具体的系统中，可能字符串拼接方式或签名算法存在差异，但是模式基本上都是类似的。</p>
<p>那么面对这样一个接口，我们会怎样编写接口测试用例呢？</p>
<p>首先，请求的数据是要有的，我们会先准备一个可用的账号，例如<code>{&quot;password&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;user1&quot;}</code>。</p>
<p>然后，由于接口存在签名校验机制，因此我们除了要知道服务器端使用的TOKEN（假设为<code>debugtalk</code>）外，还要准备好<code>Random</code>字段和<code>Authorization</code>字段。<code>Random</code>字段好说，我们随便生成一个，例如<code>A2dEx</code>；<code>Authorization</code>字段就会复杂不少，需要我们按照规定先将<code>RequestBody</code>根据字典的<code>Key</code>值进行排序，得到<code>{&quot;name&quot;: &quot;user1&quot;, &quot;password&quot;: &quot;123456&quot;}</code>，然后与<code>TOKEN</code>和<code>Random</code>字段拼接字符串得到<code>debugtalk{&quot;password&quot;: &quot;123456&quot;, &quot;name&quot;: &quot;user1&quot;}A2dEx</code>，接着再找一个<code>MD5</code>工具，计算得到签名值<code>a83de0ff8d2e896dbd8efb81ba14e17d</code>。</p>
<p>最后，我们才可以完成测试用例的编写。假如我们采用<code>YAML</code>编写测试用例，那么用例写好后应该就是如下样子。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">-</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">            authorization:</span> a83de0ff8d2e896dbd8efb81ba14e17d</div><div class="line"><span class="attr">            random:</span> A2dEx</div><div class="line"><span class="attr">    data:</span></div><div class="line"><span class="attr">        name:</span> user1</div><div class="line"><span class="attr">        password:</span> <span class="number">123456</span></div><div class="line"><span class="attr">    response:</span></div><div class="line"><span class="attr">        status_code:</span> <span class="number">201</span></div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">        body:</span></div><div class="line"><span class="attr">            success:</span> <span class="literal">true</span></div><div class="line"><span class="attr">            msg:</span> user created successfully.</div><div class="line"><span class="attr">            uuid:</span> JsdfwerL</div></pre></td></tr></table></figure>
<p>该测试用例可以在<code>ApiTestEngine</code>中正常运行，我们也可以采用同样的方式，对系统的所有接口编写测试用例，以此实现项目的接口自动化测试覆盖。</p>
<p>但问题在于，每个接口通常会对应多条测试用例，差异只是在于请求的数据会略有不同，而测试用例量越大，我们人工去准备测试数据的工作量也就越大。更令人抓狂的是，我们的系统接口不是一直不变的，有时候会根据业务需求的变化进行一些调整，相应地，我们的测试数据也需要进行同步更新，这样一来，所有相关的测试用例数据就又得重新计算一遍（任意字段数据产生变化，签名值就会大不相同）。</p>
<p>可以看出，如果是采用这种方式编写维护接口测试用例，人力和时间成本都会非常高，最终的结果必然是接口自动化测试难以在实际项目中得以开展。</p>
<h2 id="理想的用例描述方式"><a href="#理想的用例描述方式" class="headerlink" title="理想的用例描述方式"></a>理想的用例描述方式</h2><p>在上面案例中，编写接口测试用例时之所以会很繁琐，主要是因为接口存在签名校验机制，导致我们在准备测试数据时耗费了太多时间在这上面。</p>
<p>然而，对于测试人员来说，接口的业务功能才是需要关注的，至于接口采用什么签名校验机制这类技术细节，的确不应耗费过多时间和精力。所以，我们的接口测试框架应该设法将接口的技术细节实现和业务参数进行拆分，并能自动处理与技术细节相关的部分，从而让业务测试人员只需要关注业务参数部分。</p>
<p>那要怎么实现呢？</p>
<p>在开始实现之前，我们不妨借鉴<code>BDD</code>（行为驱动开发）的思想，先想下如何编写接口测试用例的体验最友好，换句话说，就是让业务测试人员写用例写得最爽。</p>
<p>还是上面案例的接口测试用例，可以看出，最耗时的地方主要是计算签名校验值部分。按理说，签名校验算法我们是已知的，要是可以在测试用例中直接调用签名算法函数就好了。</p>
<p>事实上，这也是各种模板语言普遍采用的方式，例如<code>Jinja2</code>模板语言，可以在<code>{% %}</code>中执行函数语句，在<code>{{ }}</code>中可以调用变量参数。之前我在设计[<code>AppiumBooster</code>][AppiumBooster]时也采用了类似的思想，可以通过<code>${config.TestEnvAccount.UserName}</code>的方式在测试用例中引用预定义的全局变量。</p>
<p>基于该思路，假设我们已经实现了<code>gen_random_string</code>这样一个生成指定位数的随机字符串的函数，以及<code>gen_md5</code>这样一个计算签名校验值的函数，那么我们就可以尝试采用如下方式来描述我们的测试用例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="attr">- test:</span></div><div class="line"><span class="attr">    name:</span> create user which does not exist</div><div class="line"><span class="attr">    variables:</span></div><div class="line"><span class="attr">        - TOKEN:</span> debugtalk</div><div class="line"><span class="attr">        - random:</span> $&#123;gen_random_string(<span class="number">5</span>)&#125;</div><div class="line"><span class="attr">        - json:</span> &#123;<span class="string">"name"</span>: <span class="string">"user"</span>, <span class="string">"password"</span>: <span class="string">"123456"</span>&#125;</div><div class="line"><span class="attr">        - authorization:</span> $&#123;gen_md5($TOKEN, $json, $random)&#125;</div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">        url:</span> http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span>/api/users/<span class="number">1000</span></div><div class="line"><span class="attr">        method:</span> POST</div><div class="line"><span class="attr">        headers:</span></div><div class="line"><span class="attr">            Content-Type:</span> application/json</div><div class="line"><span class="attr">            authorization:</span> $authorization</div><div class="line"><span class="attr">            random:</span> $random</div><div class="line"><span class="attr">        json:</span> $json</div><div class="line"><span class="attr">    extractors:</span></div><div class="line"><span class="attr">        user_uuid:</span> content.uuid</div><div class="line"><span class="attr">    validators:</span></div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"status_code"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="number">201</span>&#125;</div><div class="line"><span class="bullet">        -</span> &#123;<span class="string">"check"</span>: <span class="string">"content.success"</span>, <span class="string">"comparator"</span>: <span class="string">"eq"</span>, <span class="string">"expected"</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>在如上用例中，用到了两种转义符：</p>
<ul>
<li><code>$</code>作为变量转义符，<code>$var</code>将不再代表的是普遍的字符串，而是<code>var</code>变量的值；</li>
<li><code>${}</code>作为函数的转义符，<code>${}</code>内可以直接填写函数名称及调用参数，甚至可以包含变量。</li>
</ul>
<p>为什么会选择采用这种描述方式？（<code>Why？</code>）</p>
<p>其实这也是我经过大量思考和实践之后，才最终确定的描述方式。如果真要讲述这个思路历程。。。还是不细说了，此处可省下一万字。（主要的思路无非就是要实现转义的效果，并且表达要简洁清晰，因此必然会用到特殊字符；而特殊字符在<code>YAML</code>中大多都已经有了特定的含义，排除掉不可用的之后，剩下的真没几个了，然后再借鉴其它框架常用的符号，所以说最终选择<code>$</code>和<code>${}</code>也算是必然。）</p>
<p>可以确定的是，这种描述方式的好处非常明显，不仅可以实现复杂计算逻辑的函数调用，还可以实现变量的定义和引用。</p>
<p>除了转义符，由于接口测试中经常需要对结果中的特定字段进行提取，作为后续接口请求的参数，因此我们实现了<code>extractors</code>这样一个结果提取器，只要返回结果是JSON类型，就可以将其中的任意字段进行提取，并保存到一个变量中，方便后续接口请求进行引用。</p>
<p>另外，为了更好地实现对接口响应结果的校验，我们废弃了先前的方式，实现了独立的结果校验器<code>validators</code>。这是因为，很多时候在比较响应结果时，并不能简单地按照字段值是否相等来进行校验，除此之外，我们可能还需要检查某个字段的长度是否为指定位数，元素列表个数是否大于某个数值，甚至某个字符串是否满足正则匹配等等。</p>
<p>相信你们肯定会想，以上这些描述方式的确是很简洁，但更多地感觉是在臆想，就像开始说的<code>gen_random_string</code>和<code>gen_md5</code>函数，我们只是假设已经定义好了。就算描述得再优雅再完美，终究也还只是<code>YAML/JSON</code>文本格式而已，要怎样才能转换为执行的代码呢？</p>
<p>这就要解决<code>How？</code>的问题了。</p>
<p>嗯，这就是用例模板引擎的核心了，也算是<code>ApiTestEngine</code>最核心的功能特性。</p>
<p>更具体的，从技术实现角度，主要分为三大块：</p>
<ul>
<li>如何在用例描述（<code>YAML/JSON</code>）中实现函数的定义和调用</li>
<li>如何在用例描述中实现参数的定义和引用，包括用例内部和用例集之间</li>
<li>如何在用例描述中实现预期结果的描述和测试结果的校验</li>
</ul>
<p>这三大块内容涉及到较多的技术实现细节，我们将在后续的文章中结合代码逐个深入进行讲解。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/">《ApiTestEngine 演化之路（0）开发未动，测试先行》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/">《ApiTestEngine 演进之路（1）搭建基础框架》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/&quot;&gt;《ApiTestEngine 演进之路（1）搭建基础框架》&lt;/a&gt;一文中，我们完成了&lt;a href=&quot;https://gi
    
    </summary>
    
    
      <category term="自动化测试" scheme="http://debugtalk.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="测试用例" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>300行Python代码打造实用接口测试框架</title>
    <link href="http://debugtalk.com/post/300-lines-python-code-api-test-framework/"/>
    <id>http://debugtalk.com/post/300-lines-python-code-api-test-framework/</id>
    <published>2017-06-27T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在刚开始实现<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的时候，<a href="https://testerhome.com/kasi" target="_blank" rel="external"><code>卡斯（kasi）</code></a>提议做一个Java版的。对于这样的建议，我当然是拒绝的，瞬即回复了他，“人生苦短，回头是岸啊”。</p>
<p>当然，我没好意思跟他说的是，我不会Java啊。不过最主要的原因嘛，还是因为Python的语法简洁，可以采用很少的代码量实现丰富的功能。</p>
<p>有多简洁呢？</p>
<p>刚在<code>coveralls</code>上看了下<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>框架的<a href="https://coveralls.io/github/debugtalk/ApiTestEngine?branch=master" target="_blank" rel="external">代码统计行数</a>，总行数只有268行，还不足300行。</p>
<p><img src="/images/ApiTestEngine-stat-ate.jpg" alt=""></p>
<p>当然，这个行数指的是框架本身的<code>Python</code>代码行数，不包括示例注释的行数。从上图可以看出来，<code>LINES</code>列是文件总行数，<code>RELEVANT</code>列是实际的<code>Python</code>代码行数。例如<code>ate/runner.py</code>文件，注释的行数是远多于实际代码行数的。</p>
<p>最极端的一个例子是，<code>ate/testcase.py</code>文件中的<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/ate/testcase.py" target="_blank" rel="external"><code>parse</code>函数</a>，示例注释行数35行，<code>Python</code>代码只有2行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, testcase_template)</span>:</span></div><div class="line">   <span class="string">""" parse testcase_template, replace all variables with bind value.</span></div><div class="line">   variables marker: $&#123;variable&#125;.</div><div class="line">   @param (dict) testcase_template</div><div class="line">       &#123;</div><div class="line">           "request": &#123;</div><div class="line">               "url": "http://127.0.0.1:5000/api/users/$&#123;uid&#125;",</div><div class="line">               "method": "POST",</div><div class="line">               "headers": &#123;</div><div class="line">                   "Content-Type": "application/json",</div><div class="line">                   "authorization": "$&#123;authorization&#125;",</div><div class="line">                   "random": "$&#123;random&#125;"</div><div class="line">               &#125;,</div><div class="line">               "body": "$&#123;data&#125;"</div><div class="line">           &#125;,</div><div class="line">           "response": &#123;</div><div class="line">               "status_code": "$&#123;expected_status&#125;"</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   @return (dict) parsed testcase with bind values</div><div class="line">       &#123;</div><div class="line">           "request": &#123;</div><div class="line">               "url": "http://127.0.0.1:5000/api/users/1000",</div><div class="line">               "method": "POST",</div><div class="line">               "headers": &#123;</div><div class="line">                   "Content-Type": "application/json",</div><div class="line">                   "authorization": "a83de0ff8d2e896dbd8efb81ba14e17d",</div><div class="line">                   "random": "A2dEx"</div><div class="line">               &#125;,</div><div class="line">               "body": '&#123;"name": "user", "password": "123456"&#125;'</div><div class="line">           &#125;,</div><div class="line">           "response": &#123;</div><div class="line">               "status_code": 201</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   """</div><div class="line">   <span class="keyword">return</span> self.substitute(testcase_template)</div></pre></td></tr></table></figure>
<p>另外，如果算上单元测试用例的行数（731行），总的<code>Python</code>代码行数能达到1000行的样子。嗯，代码可以精简，但是单元测试覆盖率还是要保证的，不达到90%以上的单元测试覆盖率，真不好意思说自己做了开源项目啊。</p>
<p><img src="/images/ApiTestEngine-stat-all.jpg" alt=""></p>
<p>那这不足300行的Python代码，实际实现了哪些功能呢？</p>
<p>对比下<a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>中规划的特性，已经实现了大半（前六项），至少已经算是一个有模有样的接口测试框架了。</p>
<ul>
<li>支持API接口的多种请求方法，包括 GET/POST/HEAD/PUT/DELETE 等</li>
<li>测试用例与代码分离，测试用例维护方式简洁优雅，支持<code>YAML/JSON</code></li>
<li>测试用例描述方式具有表现力，可采用简洁的方式描述输入参数和预期输出结果</li>
<li>接口测试用例具有可复用性，便于创建复杂测试场景</li>
<li>测试执行方式简单灵活，支持单接口调用测试、批量接口调用测试、定时任务执行测试</li>
<li>具有可扩展性，便于扩展实现Web平台化</li>
<li>测试结果统计报告简洁清晰，附带详尽日志记录，包括接口请求耗时、请求响应数据等</li>
<li>身兼多职，同时实现接口管理、接口自动化测试、接口性能测试（结合Locust）</li>
</ul>
<p>后面剩下的特性还在实现的过程中，但是可以预见得到，最后框架本身总的<code>Python</code>代码行数也不会超过500行。</p>
<p>当然，单纯地比代码行数的确是没有什么意义，写得爽写得开心才是最重要的。</p>
<p>最后引用下<code>Guido van Rossum</code>的语录：</p>
<blockquote>
<p>Life is short, go Pythonic!</p>
</blockquote>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/">《ApiTestEngine 演化之路（0）开发未动，测试先行》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/">《ApiTestEngine 演进之路（1）搭建基础框架》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p><a href="http://debugtalk.com/tags/ApiTestEngine">《ApiTestEngine 演进之路》</a>系列文章还在继续写，只是前几天主要精力在编码实现上，博客方面没有同步更新，接下来我会整理好思路，继续完成余下的部分。</p>
<p>另外，如果大家对Python编程感兴趣，给大家推荐一个专注Python原创技术分享的公众号，⎡Python之禅⎦（VTtalk），里面关于Python的干货非常多，讲解也很通俗易懂，现在我如果有理解得不够透彻的概念，基本都会先到这个公众号里面去搜索下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在刚开始实现&lt;a href=&quot;https://github.com/debugtalk/ApiTestEngine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;ApiTestEngine&lt;/code&gt;&lt;/a&gt;的时候，&lt;a href=&quot;http
    
    </summary>
    
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="接口测试" scheme="http://debugtalk.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 演进之路（1）搭建基础框架</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-1-setup-basic-framework/</id>
    <published>2017-06-21T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/">《ApiTestEngine 演进之路（0）开发未动，测试先行》</a>一文中，我对<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>项目正式开始前的准备工作进行了介绍，包括构建API接口服务（<code>Mock Server</code>）、搭建项目单元测试框架、实现持续集成构建检查机制（<a href="https://travis-ci.org/" target="_blank" rel="external"><code>Travis CI</code></a>）等。</p>
<p>接下来，我们就开始构建<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>项目的基础框架，实现基本功能吧。</p>
<h2 id="接口测试的核心要素"><a href="#接口测试的核心要素" class="headerlink" title="接口测试的核心要素"></a>接口测试的核心要素</h2><p>既然是从零开始，那我们不妨先想下，对于接口测试来说，最基本最核心的要素有哪些？</p>
<p>事实上，不管是手工进行接口测试，还是自动化测试平台执行接口测试，接口测试的核心要素都可以概括为如下三点：</p>
<ul>
<li>发起接口请求（Request）</li>
<li>解析接口响应（Response）</li>
<li>检查接口测试结果</li>
</ul>
<p>这对于任意类型的接口测试也都是适用的。</p>
<p>在本系列文章中，我们关注的是API接口的测试，更具体地，是基于HTTP协议的API接口的测试。所以我们的问题就进一步简化了，只需要关注<code>HTTP</code>协议层面的请求和响应即可。</p>
<p>好在对于绝大多数接口系统，都有明确的API接口文档，里面会定义好接口请求的参数（包括Headers和Body），并同时描述好接口响应的内容（包括Headers和Body）。而我们需要做的，就是根据接口文档的描述，在<code>HTTP</code>请求中按照接口规范填写请求的参数，然后读取接口的<code>HTTP</code>响应内容，将接口的实际响应内容与我们的预期结果进行对比，以此判断接口功能是否正常。这里的预期结果，应该是包含在接口测试用例里面的。</p>
<p>由此可知，实现接口测试框架的第一步是完成对<code>HTTP</code>请求响应处理的支持。</p>
<h2 id="HTTP客户端的最佳选择"><a href="#HTTP客户端的最佳选择" class="headerlink" title="HTTP客户端的最佳选择"></a>HTTP客户端的最佳选择</h2><p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>项目选择<code>Python</code>作为编程语言，而在<code>Python</code>中实现<code>HTTP</code>请求，毫无疑问，<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>库是最佳选择，简洁优雅，功能强大，可轻松支持<code>API</code>接口的多种请求方法，包括<code>GET/POST/HEAD/PUT/DELETE</code>等。</p>
<p>并且，更赞的地方在于，<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>库针对所有的<code>HTTP</code>请求方法，都可以采用一套统一的接口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requests.request(method, url, **kwargs)</div></pre></td></tr></table></figure>
<p>其中，<code>kwargs</code>中可以包含<code>HTTP</code>请求的所有可能需要用到的信息，例如<code>headers</code>、<code>cookies</code>、<code>params</code>、<code>data</code>、<code>auth</code>等。</p>
<p>这有什么好处呢？</p>
<p>好处在于，这可以帮助我们轻松实现测试数据与框架代码的分离。我们只需要遵循<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>库的参数规范，在接口测试用例中复用<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>参数的概念即可。而对于框架的测试用例执行引擎来说，处理逻辑就异常简单了，直接读取测试用例中的参数，传参给<code>Requests</code>发起请求即可。</p>
<p>如果还感觉不好理解，没关系，直接看案例。</p>
<h2 id="测试用例描述"><a href="#测试用例描述" class="headerlink" title="测试用例描述"></a>测试用例描述</h2><p>在我们搭建的API接口服务（<code>Mock Server</code>）中，我们想测试“创建一个用户，该用户之前不存在”的场景</p>
<p>在上一篇文章中，我们也在<code>unittest</code>中对该测试场景实现了测试脚本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_create_user_not_existed</span><span class="params">(self)</span>:</span></div><div class="line">   self.clear_users()</div><div class="line"></div><div class="line">   url = <span class="string">"%s/api/users/%d"</span> % (self.host, <span class="number">1000</span>)</div><div class="line">   data = &#123;</div><div class="line">       <span class="string">"name"</span>: <span class="string">"user1"</span>,</div><div class="line">       <span class="string">"password"</span>: <span class="string">"123456"</span></div><div class="line">   &#125;</div><div class="line">   resp = self.api_client.post(url, json=data)</div><div class="line"></div><div class="line">   self.assertEqual(<span class="number">201</span>, resp.status_code)</div><div class="line">   self.assertEqual(<span class="keyword">True</span>, resp.json()[<span class="string">"success"</span>])</div></pre></td></tr></table></figure>
<p>在该用例中，我们实现了<code>HTTP POST</code>请求，<code>api_client.post(url, json=data)</code>，然后对响应结果进行解析，并检查<code>resp.status_code</code>、<code>resp.json()[&quot;success&quot;]</code>是否满足预期。</p>
<p>可以看出，采用代码编写测试用例时会用到许多编程语言的语法，对于不会编程的人来说上手难度较大。更大的问题在于，当我们编写大量测试用例之后，因为模式基本都是固定的，所以会发现存在大量相似或重复的脚本，这给脚本的维护带来了很大的问题。</p>
<p>那如何将测试用例与脚本代码进行分离呢？</p>
<p>考虑到<code>JSON</code>格式在编程语言中处理是最方便的，分离后的测试用例可采用<code>JSON</code>描述如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"name"</span>: <span class="string">"create user which does not exist"</span>,</div><div class="line">   <span class="attr">"request"</span>: &#123;</div><div class="line">       <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:5000/api/users/1000"</span>,</div><div class="line">       <span class="attr">"method"</span>: <span class="string">"POST"</span>,</div><div class="line">       <span class="attr">"headers"</span>: &#123;</div><div class="line">           <span class="attr">"content-type"</span>: <span class="string">"application/json"</span></div><div class="line">       &#125;,</div><div class="line">       <span class="attr">"json"</span>: &#123;</div><div class="line">           <span class="attr">"name"</span>: <span class="string">"user1"</span>,</div><div class="line">           <span class="attr">"password"</span>: <span class="string">"123456"</span></div><div class="line">       &#125;</div><div class="line">   &#125;,</div><div class="line">   <span class="attr">"response"</span>: &#123;</div><div class="line">       <span class="attr">"status_code"</span>: <span class="number">201</span>,</div><div class="line">       <span class="attr">"headers"</span>: &#123;</div><div class="line">           <span class="attr">"Content-Type"</span>: <span class="string">"application/json"</span></div><div class="line">       &#125;,</div><div class="line">       <span class="attr">"body"</span>: &#123;</div><div class="line">           <span class="attr">"success"</span>: <span class="literal">true</span>,</div><div class="line">           <span class="attr">"msg"</span>: <span class="string">"user created successfully."</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不难看出，如上<code>JSON</code>结构体包含了测试用例的完整描述信息。</p>
<p>需要特别注意的是，这里使用了一个讨巧的方式，就是在请求的参数中充分复用了<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>的参数规范。例如，我们要<code>POST</code>一个<code>JSON</code>的结构体，那么我们就直接将<code>json</code>作为<code>request</code>的参数名，这和前面写脚本时用的<code>api_client.post(url, json=data)</code>是一致的。</p>
<h2 id="测试用例执行引擎"><a href="#测试用例执行引擎" class="headerlink" title="测试用例执行引擎"></a>测试用例执行引擎</h2><p>在如上测试用例描述的基础上，测试用例执行引擎就很简单了，以下几行代码就足够了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_single_testcase</span><span class="params">(testcase)</span>:</span></div><div class="line">   req_kwargs = testcase[<span class="string">'request'</span>]</div><div class="line"></div><div class="line">   <span class="keyword">try</span>:</div><div class="line">       url = req_kwargs.pop(<span class="string">'url'</span>)</div><div class="line">       method = req_kwargs.pop(<span class="string">'method'</span>)</div><div class="line">   <span class="keyword">except</span> KeyError:</div><div class="line">       <span class="keyword">raise</span> exception.ParamsError(<span class="string">"Params Error"</span>)</div><div class="line"></div><div class="line">   resp_obj = requests.request(url=url, method=method, **req_kwargs)</div><div class="line">   diff_content = utils.diff_response(resp_obj, testcase[<span class="string">'response'</span>])</div><div class="line">   success = <span class="keyword">False</span> <span class="keyword">if</span> diff_content <span class="keyword">else</span> <span class="keyword">True</span></div><div class="line">   <span class="keyword">return</span> success, diff_content</div></pre></td></tr></table></figure>
<p>可以看出，不管是什么<code>HTTP</code>请求方法的用例，该执行引擎都是适用的。</p>
<p>只需要先从测试用例中获取到HTTP接口请求参数，<code>testcase[&#39;request&#39;]</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"url"</span>: <span class="string">"http://127.0.0.1:5000/api/users/1000"</span>,</div><div class="line">  <span class="attr">"method"</span>: <span class="string">"POST"</span>,</div><div class="line">  <span class="attr">"headers"</span>: &#123;</div><div class="line">      <span class="attr">"content-type"</span>: <span class="string">"application/json"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"json"</span>: &#123;</div><div class="line">      <span class="attr">"name"</span>: <span class="string">"user1"</span>,</div><div class="line">      <span class="attr">"password"</span>: <span class="string">"123456"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后发起<code>HTTP</code>请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requests.request(url=url, method=method, **req_kwargs)</div></pre></td></tr></table></figure>
<p>最后再检查测试结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">utils.diff_response(resp_obj, testcase[<span class="string">'response'</span>])</div></pre></td></tr></table></figure>
<p>在测试用例执行引擎完成后，执行测试用例的方式也很简单。同样是在<code>unittest</code>中调用执行测试用例，就可以写成如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_run_single_testcase_success</span><span class="params">(self)</span>:</span></div><div class="line">   testcase_file_path = os.path.join(os.getcwd(), <span class="string">'tests/data/demo.json'</span>)</div><div class="line">   testcases = utils.load_testcases(testcase_file_path)</div><div class="line">   success, _ = self.test_runner.run_single_testcase(testcases[<span class="number">0</span>])</div><div class="line">   self.assertTrue(success)</div></pre></td></tr></table></figure>
<p>可以看出，模式还是很固定：加载用例、执行用例、判断用例执行是否成功。如果每条测试用例都要在<code>unittest.TestCase</code>分别写一个单元测试进行调用，还是会存在大量重复工作。</p>
<p>所以比较好的做法是，再实现一个单元测试用例生成功能；这部分先不展开，后面再进行详细描述。</p>
<h2 id="结果判断处理逻辑"><a href="#结果判断处理逻辑" class="headerlink" title="结果判断处理逻辑"></a>结果判断处理逻辑</h2><p>这里再单独讲下对结果的判断逻辑处理，也就是<code>diff_response</code>函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def diff_response(resp_obj, expected_resp_json)</div><div class="line">    diff_content = &#123;&#125;</div><div class="line">    resp_info = parse_response_object(resp_obj)</div><div class="line"></div><div class="line">    # 对比 status_code，将差异存入 diff_content</div><div class="line">    # 对比 Headers，将差异存入 diff_content</div><div class="line">    # 对比 Body，将差异存入 diff_content</div><div class="line"></div><div class="line">    return diff_content</div></pre></td></tr></table></figure>
<p>其中，<code>expected_resp_json</code>参数就是我们在测试用例中描述的<code>response</code>部分，作为测试用例的预期结果描述信息，是判断实际接口响应是否正常的参考标准。</p>
<p>而<code>resp_obj</code>参数，就是实际接口响应的<code>Response</code>实例，详细的定义可以参考<code>requests.Response</code><a href="http://docs.python-requests.org/en/master/api/#requests.Response" target="_blank" rel="external">描述文档</a>。</p>
<p>为了更好地实现结果对比，我们也将<code>resp_obj</code>解析为与<code>expected_resp_json</code>相同的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_response_object</span><span class="params">(resp_obj)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        resp_body = resp_obj.json()</div><div class="line">    <span class="keyword">except</span> ValueError:</div><div class="line">        resp_body = resp_obj.text</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'status_code'</span>: resp_obj.status_code,</div><div class="line">        <span class="string">'headers'</span>: resp_obj.headers,</div><div class="line">        <span class="string">'body'</span>: resp_body</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>那么最后再进行对比就很好实现了，只需要编写一个通用的<code>JSON</code>结构体比对函数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff_json</span><span class="params">(current_json, expected_json)</span>:</span></div><div class="line">    json_diff = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> key, expected_value <span class="keyword">in</span> expected_json.items():</div><div class="line">        value = current_json.get(key, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> str(value) != str(expected_value):</div><div class="line">            json_diff[key] = &#123;</div><div class="line">                <span class="string">'value'</span>: value,</div><div class="line">                <span class="string">'expected'</span>: expected_value</div><div class="line">            &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> json_diff</div></pre></td></tr></table></figure>
<p>这里只罗列了核心处理流程的代码实现，其它的辅助功能，例如加载<code>JSON/YAML</code>测试用例等功能，请直接阅读阅读<a href="https://github.com/debugtalk/ApiTestEngine/tree/master/ate" target="_blank" rel="external">项目源码</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过本文中的工作，我们已经完成了<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>基础框架的搭建，并实现了两项最基本的功能：</p>
<ul>
<li>支持API接口的多种请求方法，包括 GET/POST/HEAD/PUT/DELETE 等</li>
<li>测试用例与代码分离，测试用例维护方式简洁优雅，支持<code>YAML/JSON</code></li>
</ul>
<p>然而，在实际项目中的接口通常比较复杂，例如包含签名校验等机制，这使得我们在配置接口测试用例时还是会比较繁琐。</p>
<p>在下一篇文章中，我们将着手解决这个问题，通过对框架增加模板配置功能，实现接口业务参数和技术细节的分离。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/">《ApiTestEngine 演进之路（0）开发未动，测试先行》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/&quot;&gt;《ApiTestEngine 演进之路（0）开发未动，测试先行》&lt;/a&gt;一文中，我对&lt;a href=&quot;https://github.com
    
    </summary>
    
    
      <category term="HTTP" scheme="http://debugtalk.com/tags/HTTP/"/>
    
      <category term="自动化测试" scheme="http://debugtalk.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>ApiTestEngine 演进之路（0）开发未动，测试先行</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-0-setup-CI-test/</id>
    <published>2017-06-19T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a>一文中，我详细介绍了<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>诞生的背景，并对其核心特性进行了详尽的剖析。</p>
<p>接下来，我将在《ApiTestEngine演进之路》系列文章中讲解<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>是如何从第一行代码开始，逐步实现接口自动化测试框架的核心功能特性的。</p>
<p>相信大家都有听说过<code>TDD</code>（<code>测试驱动开发</code>）这种开发模式，虽然网络上对该种开发模式存在异议，但我个人是非常推荐使用该种开发方式的。关于<code>TDD</code>的优势，我就不在此赘述了，我就只说下自己受益最深的两个方面。</p>
<ul>
<li>测试驱动，其实也是需求驱动。在开发正式代码之前，可以先将需求转换为单元测试用例，然后再逐步实现正式代码，直至将所有单元测试用例跑通。这可以帮助我们总是聚焦在要实现的功能特性上，避免跑偏。特别是像我们做测试开发的，通常没有需求文档和设计文档，如果没有清晰的思路，很可能做着做着就不知道自己做到哪儿了。</li>
<li>高覆盖率的单元测试代码，对项目质量有充足的信心。因为是先写测试再写实现，所以正常情况下，所有的功能特性都应该能被单元测试覆盖到。再结合持续集成的手段，我们可以轻松保证每个版本都是高质量并且可用的。</li>
</ul>
<p>所以，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>项目也将采用<code>TDD</code>的开发模式。本篇文章就重点介绍下采用<code>TDD</code>之前需要做的一些准备工作。</p>
<h2 id="搭建API接口服务（Mock-Server）"><a href="#搭建API接口服务（Mock-Server）" class="headerlink" title="搭建API接口服务（Mock Server）"></a>搭建API接口服务（Mock Server）</h2><p>接口测试框架要运行起来，必然需要有可用的API接口服务。因此，在开始构建我们的接口测试框架之前，最好先搭建一套简单的API接口服务，也就是<code>Mock Server</code>，然后我们在采用<code>TDD</code>开发模式的时候，就可以随时随地将框架代码跑起来，开发效率也会大幅提升。</p>
<p>为什么不直接采用已有的业务系统API接口服务呢？</p>
<p>这是因为通常业务系统的接口比较复杂，并且耦合了许多业务逻辑，甚至还可能涉及到和其它业务系统的交互，搭建或维护一套测试环境的成本可能会非常高。另一方面，接口测试框架需要具有一定的通用性，其功能特性很难在一个特定的业务系统中找到所有合适的接口。就拿最简单的接口请求方法来说，测试框架需要支持<code>GET/POST/HEAD/PUT/DELETE</code>方法，但是可能在我们已有的业务系统中只有<code>GET/POST</code>接口。</p>
<p>自行搭建API接口服务的另一个好处在于，我们可以随时调整接口的实现方式，来满足接口测试框架特定的功能特性，从而使我们总是能将注意力集中在测试框架本身。比较好的做法是，先搭建最简单的接口服务，在此基础上将接口测试框架搭建起来，实现最基本的功能；后面在实现框架的高级功能特性时，我们再对该接口服务进行拓展升级，例如增加签名校验机制等，来适配测试框架的高级功能特性。</p>
<p>幸运的是，使用<code>Python</code>搭建API接口服务十分简单，特别是在结合使用<a href="http://flask.pocoo.org/" target="_blank" rel="external"><code>Flask</code></a>框架的情况下。</p>
<p>例如，我们想实现一套可以对用户账号进行增删改查（<code>CRUD</code>）功能的接口服务，用户账号的存储结构大致如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">users_dict = &#123;</div><div class="line">   'uid1': &#123;</div><div class="line">       'name': 'name1',</div><div class="line">       'password': 'pwd1'</div><div class="line">   &#125;,</div><div class="line">   'uid2': &#123;</div><div class="line">       'name': 'name2',</div><div class="line">       'password': 'pwd2'</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，新增（Create）和更新（Update）功能的接口就可以通过如下方式实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, make_response</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">users_dict = &#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@app.route('/api/users/&lt;int:uid&gt;', methods=['POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(uid)</span>:</span></div><div class="line">    user = request.get_json()</div><div class="line">    <span class="keyword">if</span> uid <span class="keyword">not</span> <span class="keyword">in</span> users_dict:</div><div class="line">        result = &#123;</div><div class="line">            <span class="string">'success'</span>: <span class="keyword">True</span>,</div><div class="line">            <span class="string">'msg'</span>: <span class="string">"user created successfully."</span></div><div class="line">        &#125;</div><div class="line">        status_code = <span class="number">201</span></div><div class="line">        users_dict[uid] = user</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        result = &#123;</div><div class="line">            <span class="string">'success'</span>: <span class="keyword">False</span>,</div><div class="line">            <span class="string">'msg'</span>: <span class="string">"user already existed."</span></div><div class="line">        &#125;</div><div class="line">        status_code = <span class="number">500</span></div><div class="line"></div><div class="line">    response = make_response(json.dumps(result), status_code)</div><div class="line">    response.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></div><div class="line">    <span class="keyword">return</span> response</div><div class="line"></div><div class="line"><span class="meta">@app.route('/api/users/&lt;int:uid&gt;', methods=['PUT'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_user</span><span class="params">(uid)</span>:</span></div><div class="line">    user = users_dict.get(uid, &#123;&#125;)</div><div class="line">    <span class="keyword">if</span> user:</div><div class="line">        user = request.get_json()</div><div class="line">        success = <span class="keyword">True</span></div><div class="line">        status_code = <span class="number">200</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        success = <span class="keyword">False</span></div><div class="line">        status_code = <span class="number">404</span></div><div class="line"></div><div class="line">    result = &#123;</div><div class="line">        <span class="string">'success'</span>: success,</div><div class="line">        <span class="string">'data'</span>: user</div><div class="line">    &#125;</div><div class="line">    response = make_response(json.dumps(result), status_code)</div><div class="line">    response.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></div><div class="line">    <span class="keyword">return</span> response</div></pre></td></tr></table></figure>
<p>限于篇幅，其它类型的接口实现就不在此赘述，完整的接口实现可以参考<a href="https://github.com/debugtalk/ApiTestEngine/blob/master/tests/api_server.py" target="_blank" rel="external">项目源码</a>。</p>
<p>接口服务就绪后，按照<code>Flask</code>官方文档，可以通过如下方式进行启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ export FLASK_APP=tests/api_server.py</div><div class="line">$ flask run</div><div class="line"> * Serving Flask app &quot;tests.api_server&quot;</div><div class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</div></pre></td></tr></table></figure>
<p>启动后，我们就可以通过请求接口来调用已经实现的接口功能了。例如，先创建一个用户，然后查看所有用户的信息，在<code>Python</code>终端中的调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ python</div><div class="line">Python 3.6.0 (default, Mar 24 2017, 16:58:25)</div><div class="line">&gt;&gt;&gt; import requests</div><div class="line">&gt;&gt;&gt; requests.post(&apos;http://127.0.0.1:5000/api/users/1000&apos;, json=&#123;&apos;name&apos;: &apos;user1&apos;, &apos;password&apos;: &apos;123456&apos;&#125;)</div><div class="line">&lt;Response [201]&gt;</div><div class="line">&gt;&gt;&gt; resp = requests.get(&apos;http://127.0.0.1:5000/api/users&apos;)</div><div class="line">&gt;&gt;&gt; resp.content</div><div class="line">b&apos;&#123;&quot;success&quot;: true, &quot;count&quot;: 1, &quot;items&quot;: [&#123;&quot;name&quot;: &quot;user1&quot;, &quot;password&quot;: &quot;123456&quot;&#125;]&#125;&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>通过接口请求结果可见，接口服务运行正常。</p>
<h2 id="在单元测试用例中使用-Mock-Server"><a href="#在单元测试用例中使用-Mock-Server" class="headerlink" title="在单元测试用例中使用 Mock Server"></a>在单元测试用例中使用 Mock Server</h2><p>API接口服务（<code>Mock Server</code>）已经有了，但是如果每次运行单元测试时都要先在外部手工启动API接口服务的话，做法实在是不够优雅。</p>
<p>推荐的做法是，制作一个<code>ApiServerUnittest</code>基类，在其中添加<code>setUpClass</code>类方法，用于启动API接口服务（<code>Mock Server</code>）；添加<code>tearDownClass</code>类方法，用于停止API接口服务。由于<code>setUpClass</code>会在单元测试用例集初始化的时候执行一次，所以可以保证单元测试用例在运行的时候API服务处于可用状态；而<code>tearDownClass</code>会在单元测试用例集执行完毕后运行一次，停止API接口服务，从而避免对下一次启动产生影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tests/base.py</span></div><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">from</span> . <span class="keyword">import</span> api_server</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiServerUnittest</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Test case class that sets up an HTTP server which can be used within the tests</div><div class="line">    """</div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span>:</span></div><div class="line">        cls.api_server_process = multiprocessing.Process(</div><div class="line">            target=api_server.app.run</div><div class="line">        )</div><div class="line">        cls.api_server_process.start()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span>:</span></div><div class="line">        cls.api_server_process.terminate()</div></pre></td></tr></table></figure>
<p>这里采用的是多进程的方式（<code>multiprocessing</code>），所以我们的单元测试用例可以和API接口服务（<code>Mock Server</code>）同时运行。除了多进程的方式，我看到<code>locust</code>项目采用的是<a href="https://github.com/locustio/locust/blob/master/locust/test/test_web.py" target="_blank" rel="external"><code>gevent.pywsgi.WSGIServer</code></a>的方式，不过由于在<code>gevent</code>中要实现异步需要先<code>monkey.patch_all()</code>，感觉比较麻烦，而且还需要引入<code>gevent</code>这么一个第三方依赖库，所以还是决定采用<code>multiprocessing</code>的方式了。至于为什么没有选择多线程模型（<code>threading</code>），是因为线程至不支持显式终止的（<code>terminate</code>），要实现终止服务会比使用<code>multiprocessing</code>更为复杂。</p>
<p>不过需要注意的是，由于启动<code>Server</code>存在一定的耗时，因此在启动完毕后必须要等待一段时间（本例中<code>0.1秒</code>就足够了），否则在执行单元测试用例时，调用的API接口可能还处于不可用状态。</p>
<p><code>ApiServerUnittest</code>基类就绪后，对于需要用到<code>Mock Server</code>的单元测试用例集，只需要继承<code>ApiServerUnittest</code>即可；其它的写法跟普通的单元测试完全一致。</p>
<p>例如，下例包含一个单元测试用例，测试“创建一个用户，该用户之前不存在”的场景。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tests/test_apiserver.py</span></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">from</span> .base <span class="keyword">import</span> ApiServerUnittest</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApiServer</span><span class="params">(ApiServerUnittest)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        super(TestApiServer, self).setUp()</div><div class="line">        self.host = <span class="string">"http://127.0.0.1:5000"</span></div><div class="line">        self.api_client = requests.Session()</div><div class="line">        self.clear_users()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        super(TestApiServer, self).tearDown()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_create_user_not_existed</span><span class="params">(self)</span>:</span></div><div class="line">        self.clear_users()</div><div class="line"></div><div class="line">        url = <span class="string">"%s/api/users/%d"</span> % (self.host, <span class="number">1000</span>)</div><div class="line">        data = &#123;</div><div class="line">            <span class="string">"name"</span>: <span class="string">"user1"</span>,</div><div class="line">            <span class="string">"password"</span>: <span class="string">"123456"</span></div><div class="line">        &#125;</div><div class="line">        resp = self.api_client.post(url, json=data)</div><div class="line"></div><div class="line">        self.assertEqual(<span class="number">201</span>, resp.status_code)</div><div class="line">        self.assertEqual(<span class="keyword">True</span>, resp.json()[<span class="string">"success"</span>])</div></pre></td></tr></table></figure>
<h2 id="为项目添加持续集成构建检查（Travis-CI）"><a href="#为项目添加持续集成构建检查（Travis-CI）" class="headerlink" title="为项目添加持续集成构建检查（Travis CI）"></a>为项目添加持续集成构建检查（Travis CI）</h2><p>当我们的项目具有单元测试之后，我们就可以为项目添加持续集成构建检查，从而在每次提交代码至<code>GitHub</code>时都运行测试，确保我们每次提交的代码都是可正常部署及运行的。</p>
<p>要实现这个功能，推荐使用<a href="https://travis-ci.org/" target="_blank" rel="external"><code>Travis CI</code></a>提供的服务，该服务对于GitHub公有仓库是免费的。要完成配置，操作也很简单，基本上只有三步：</p>
<ul>
<li>在<a href="https://travis-ci.org/" target="_blank" rel="external"><code>Travis CI</code></a>使用GitHub账号授权登录；</li>
<li>在<a href="https://travis-ci.org/" target="_blank" rel="external"><code>Travis CI</code></a>的个人<code>profile</code>页面开启需要持续集成的项目；</li>
<li>在<code>Github</code>项目的根目录下添加<code>.travis.yml</code>配置文件。</li>
</ul>
<p>大多数情况下，<code>.travis.yml</code>配置文件可以很简单，例如<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的配置就只有如下几行：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">sudo:</span> <span class="literal">false</span></div><div class="line"><span class="attr">language:</span> python</div><div class="line"><span class="attr">python:</span></div><div class="line"><span class="bullet">  -</span> <span class="number">2.7</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.3</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.4</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.5</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.6</span></div><div class="line"><span class="attr">install:</span></div><div class="line"><span class="bullet">  -</span> pip install -r requirements.txt</div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> python -m unittest discover</div></pre></td></tr></table></figure>
<p>具体含义不用解释也可以很容易看懂，其中<code>install</code>中包含我们项目的依赖库安装命令，<code>script</code>中包含执行构建测试的命令。</p>
<p>配置完毕后，后续每次提交代码时，<code>GitHub</code>就会调用<code>Travis CI</code>实现构建检查；并且更赞的在于，构建检查可以同时在多个指定的<code>Python</code>版本环境中进行。</p>
<p>下图是某次提交代码时的构建结果。</p>
<p><img src="/images/travis-check-result.jpg" alt=""></p>
<p>另外，我们还可以在<code>GitHub</code>项目的<code>README.md</code>中添加一个<code>Status Image</code>，实时显示项目的构建状态，就像下图显示的样子。</p>
<p><img src="/images/github-readme-travis-status-image.jpg" alt=""></p>
<p>配置方式也是很简单，只需要先在<code>Travis CI</code>中获取到项目<code>Status Image</code>的URL地址，然后添加到<code>README.md</code>即可。</p>
<p><img src="/images/travis-status-image-url.jpg" alt=""></p>
<h2 id="为项目添加单元测试覆盖率检查（coveralls）"><a href="#为项目添加单元测试覆盖率检查（coveralls）" class="headerlink" title="为项目添加单元测试覆盖率检查（coveralls）"></a>为项目添加单元测试覆盖率检查（coveralls）</h2><p>对项目添加持续集成构建检查以后，就能完全保证我们提交的代码运行没问题么？</p>
<p>答案是并不能。试想，假如我们整个项目中就只有一条单元测试用例，甚至这一条单元测试用例还是个假用例，即没有调用任何代码，那么可想而知，我们的持续集成构建检查总是成功的，并没有起到检查的作用。</p>
<p>因此，这里还涉及到一个单元测试覆盖率的问题。</p>
<p>怎么理解单元测试覆盖率呢？简单地说，就是我们在执行单元测试时运行代码的行数，与项目总代码数的比值。</p>
<p>对于主流的编程语言，都存在大量的覆盖率检查工具，可以帮助我们快速统计单元测试覆盖率。在Python中，用的最多的覆盖率检查工具是<a href="https://coverage.readthedocs.io" target="_blank" rel="external"><code>coverage</code></a>。</p>
<p>要使用<a href="https://coverage.readthedocs.io" target="_blank" rel="external"><code>coverage</code></a>，需要先进行安装，采用<code>pip</code>的安装方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install coverage</div></pre></td></tr></table></figure>
<p>然后，我们就可以采用如下命令执行单元测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ coverage run --source=ate -m unittest discover</div></pre></td></tr></table></figure>
<p>这里需要说明的是，<code>--source</code>参数的作用是指定统计的目录，如果不指定该参数，则会将所有依赖库也计算进去，但由于很多依赖库在安装时是没有包含测试代码的，因此会造成统计得到的单元测试覆盖率远低于实际的情况。在上面的命令中，就只统计了<code>ate</code>目录下的单元测试覆盖率；如果要统计当前项目的覆盖率，那么可以指定<code>--source=.</code>（即当前目录下的所有子文夹）。</p>
<p>采用上述命令执行完单元测试后，会在当前目录下生成一个统计结果文件，<code>.coverage</code>，里面包含了详细的统计结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat .coverage</div><div class="line">!coverage.py: This is a private format, don&apos;t read it directly!&#123;&quot;lines&quot;:&#123;&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/__init__.py&quot;:[1],&quot;/Users/Leo/MyProjects/</div><div class="line">ApiTestEngine/ate/testcase.py&quot;:[1,2,4,6,9,15,42,7,12,40,46,64,67,68,69,70,48,49,62,72,74,13,65,51,52,53,56,60,58,54,55],&quot;/Users/Leo/MyProjects/ApiTestEngi</div><div class="line">ne/ate/exception.py&quot;:[2,4,5,9,12,15,16,6,7],&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/utils.py&quot;:[1,2,3,4,5,7,9,11,12,14,15,18,22,25,47,51,55,65,77,90,129,1</div><div class="line">41,27,31,32,19,20,23,34,41,43,45,56,57,59,60,48,49,154,163,166,170,172,173,174,176,177,181,182,183,186,187,189,91,92,66,67,72,73,74,94,95,97,98,101,102,78</div><div class="line">,80,81,82,84,85,88,103,104,106,108,110,115,121,122,124,125,127,58,52,53,184,185,109,116,118,119,112,113,132,134,135,136,137,139,63,164,155,157,158,159,161</div><div class="line">,167,168,192,68,69],&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/context.py&quot;:[1,3,5,6,10,16,30,45,7,8,25,26,28,41,42,43,49,55,58,59,63,64,56,74,65,68,69,72,66</div><div class="line">,27,13,14,50,53,52,70],&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/main.py&quot;:[1,2,4,7,9,10,15,21,38,51,25,27,28,29,30,32,33,11,12,13,34,36,42,43,45,46,47,49],</div><div class="line">&quot;/Users/Leo/MyProjects/ApiTestEngine/ate/runner.py&quot;:[1,3,4,5,8,10,15,46,68,97,135,11,12,13,35,36,38,39,41,42,44,82,63,65,66,84,86,87,88,92,93,94,95,124,12</div><div class="line">6,127,128,129,130,131,133,154]&#125;&#125;%</div></pre></td></tr></table></figure>
<p>但是，这个结果就不是给人看的。要想直观地看到统计报告，需要再执行命令<code>coverage report -m</code>，执行完后，就可以看到详细的统计数据了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  ApiTestEngine git:(master) ✗ coverage report -m</div><div class="line">Name               Stmts   Miss  Cover   Missing</div><div class="line">------------------------------------------------</div><div class="line">ate/__init__.py        0      0   100%</div><div class="line">ate/context.py        35      0   100%</div><div class="line">ate/exception.py      11      2    82%   10, 13</div><div class="line">ate/main.py           34      7    79%   18-19, 54-62</div><div class="line">ate/runner.py         44      2    95%   89-90</div><div class="line">ate/testcase.py       30      0   100%</div><div class="line">ate/utils.py         112      8    93%   13, 29, 36-39, 178-179</div><div class="line">------------------------------------------------</div><div class="line">TOTAL                266     19    93%</div></pre></td></tr></table></figure>
<p>通过这个报告，可以看到项目整体的单元测试覆盖率为<code>93%</code>，并清晰地展示了每个源代码文件的具体覆盖率数据，以及没有覆盖到的代码行数。</p>
<p>那要怎么将覆盖率检查添加到我们的持续集成（Travis CI）中呢？</p>
<p>事实上，当前存在多个可选服务，可以与<code>Travis CI</code>配合使用。当前，使用得比较广泛的是<a href="https://coveralls.io" target="_blank" rel="external"><code>coveralls</code></a>，针对Public类型的GitHub仓库，这也是一个免费服务。</p>
<p><a href="https://coveralls.io" target="_blank" rel="external"><code>coveralls</code></a>的使用方式与<a href="https://travis-ci.org/" target="_blank" rel="external"><code>Travis CI</code></a>类似，也需要先在<a href="https://coveralls.io" target="_blank" rel="external"><code>coveralls</code></a>网站上采用GitHub账号授权登录，然后开启需要进行检查的GitHub仓库。而要执行的命令，也可以在<code>.travis.yml</code>配置文件中指定。</p>
<p>增加覆盖率检查后的<code>.travis.yml</code>配置文件内容如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">sudo:</span> <span class="literal">false</span></div><div class="line"><span class="attr">language:</span> python</div><div class="line"><span class="attr">python:</span></div><div class="line"><span class="bullet">  -</span> <span class="number">2.7</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.3</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.4</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.5</span></div><div class="line"><span class="bullet">  -</span> <span class="number">3.6</span></div><div class="line"><span class="attr">install:</span></div><div class="line"><span class="bullet">  -</span> pip install -r requirements.txt</div><div class="line"><span class="bullet">  -</span> pip install coverage</div><div class="line"><span class="bullet">  -</span> pip install coveralls</div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> coverage run --source=. -m unittest discover</div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> coveralls</div></pre></td></tr></table></figure>
<p>如上配置应该也很好理解，要使用<code>coveralls</code>的服务，需要先安装<code>coveralls</code>。在采用<code>coverage</code>执行完单元测试后，要将结果上报到<a href="https://coveralls.io" target="_blank" rel="external"><code>coveralls</code></a>网站，需要再执行<code>coveralls</code>命令。由于<code>coveralls</code>命令只有在测试覆盖率检查成功以后运行才有意义，因此可将其放在<code>after_success</code>部分。</p>
<p>配置完毕后，后续每次提交代码时，<code>GitHub</code>就会调用<code>Travis CI</code>实现构建检查，并同时统计得到单元测试覆盖率。</p>
<p>下图是某次提交代码时的覆盖率检查。</p>
<p><img src="/images/coveralls-result.jpg" alt=""></p>
<p>另外，我们在<code>GitHub</code>项目的<code>README.md</code>中也同样可以添加一个<code>Status Image</code>，实时显示项目的单元测试覆盖率。</p>
<p><img src="/images/github-coveralls-badge.jpg" alt=""></p>
<p>配置方式也跟之前类似，在<a href="https://coveralls.io" target="_blank" rel="external"><code>coveralls</code></a>中获取到项目<code>Status Image</code>的URL地址，然后添加到<code>README.md</code>即可。</p>
<p><img src="/images/coveralls-image-url.jpg" alt=""></p>
<p>最后需要说明的是，项目的单元测试覆盖率只能起到参考作用，没有被单元测试覆盖到的代码我们不能说它肯定有问题，100%覆盖率的代码也并不能保证它肯定没有问题。归根结底，这还是要依赖于单元测试的策略实现，因此我们在写单元测试的时候也要尽可能多地覆盖到各种逻辑路径，以及兼顾到各种异常情况。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>通过本文中的工作，我们就对项目搭建好了测试框架，并实现了持续集成构建检查机制。从下一篇开始，我们就将开始逐步实现接口自动化测试框架的核心功能特性了。</p>
<h2 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h2><ul>
<li><a href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/">《接口自动化测试的最佳工程实践（ApiTestEngine）》</a></li>
<li><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code> GitHub源码</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/&quot;&gt;《接口自动化测试的最佳工程实践（ApiTestEngine）》&lt;/a&gt;一文中，我详细介绍了&lt;a href=&quot;https://
    
    </summary>
    
    
      <category term="自动化测试" scheme="http://debugtalk.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Mock" scheme="http://debugtalk.com/tags/Mock/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>接口自动化测试的最佳工程实践（ApiTestEngine）</title>
    <link href="http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/"/>
    <id>http://debugtalk.com/post/ApiTestEngine-api-test-best-practice/</id>
    <published>2017-06-17T16:00:00.000Z</published>
    <updated>2017-12-23T07:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当前市面上存在的接口测试工具已经非常多，常见的如<code>Postman</code>、<code>JMeter</code>、<code>RobotFramework</code>等，相信大多数测试人员都有使用过，至少从接触到的大多数简历的描述上看是这样的。除了这些成熟的工具，也有很多有一定技术能力的测试（开发）人员自行开发了一些接口测试框架，质量也是参差不齐。</p>
<p>但是，当我打算在项目组中推行接口自动化测试时，搜罗了一圈，也没有找到一款特别满意的工具或框架，总是与理想中的构想存在一定的差距。</p>
<p>那么理想中的接口自动化测试框架应该是怎样的呢？</p>
<p>测试工具（框架）脱离业务使用场景都是耍流氓！所以我们不妨先来看下日常工作中的一些常见场景。</p>
<ul>
<li>测试或开发人员在定位问题的时候，想调用某个接口查看其是否响应正常；</li>
<li>测试人员在手工测试某个功能点的时候，需要一个订单号，而这个订单号可以通过顺序调用多个接口实现下单流程；</li>
<li>测试人员在开始版本功能测试之前，可以先检测下系统的所有接口是否工作正常，确保接口正常后再开始手工测试；</li>
<li>开发人员在提交代码前需要检测下新代码是否对系统的已有接口产生影响；</li>
<li>项目组需要每天定时检测下测试环境所有接口的工作情况，确保当天的提交代码没有对主干分支的代码造成破坏；</li>
<li>项目组需要定时（30分钟）检测下生产环境所有接口的工作情况，以便及时发现生产环境服务不可用的情况；</li>
<li>项目组需要不定期对核心业务场景进行性能测试，期望能减少人力投入，直接复用接口测试中的工作成果。</li>
</ul>
<p>可以看到，以上罗列的场景大家应该都很熟悉，这都是我们在日常工作中经常需要去做的事情。但是在没有一款合适工具的情况下，效率往往十分低下，或者就是某些重要工作压根就没有开展，例如接口回归测试、线上接口监控等。</p>
<p>先说下最简单的手工调用接口测试。可能有人会说，<code>Postman</code>就可以满足需求啊。的确，<code>Postman</code>作为一款通用的接口测试工具，它可以构造接口请求，查看接口响应，从这个层面上来说，它是满足了接口测试的功能需求。但是在具体的项目中，使用<code>Postman</code>并不是那么高效。</p>
<p>不妨举个最常见的例子。</p>
<blockquote>
<p>某个接口的请求参数非常多，并且接口请求要求有<code>MD5</code>签名校验；签名的方式为在Headers中包含一个<code>sign</code>参数，该参数值通过对<code>URL</code>、<code>Method</code>、<code>Body</code>的拼接字符串进行<code>MD5</code>计算后得到。</p>
</blockquote>
<p>回想下我们要对这个接口进行测试时是怎么做的。首先，我们需要先参照接口文档的描述，手工填写完所有接口参数；然后，按照签名校验方式，对所有参数值进行拼接得到一个字符串，在另一个MD5计算工具计算得到其MD5值，将签名值填入<code>sign</code>参数；最后，才是发起接口请求，查看接口响应，并人工检测响应是否正常。最坑爹的是，我们每次需要调用这个接口的时候，以上工作就得重新来一遍。这样的实际结果是，面对参数较多或者需要签名验证的接口时，测试人员可能会选择忽略不进行接口测试。</p>
<p>除了单个接口的调用，很多时候我们也需要组合多个接口进行调用。例如测试人员在测试物流系统时，经常需要一个特定组合条件下生成的订单号。而由于订单号关联的业务较多，很难直接在数据库中生成，因此当前业务测试人员普遍采取的做法，就是每次需要订单号时模拟下单流程，顺序调用多个相应的接口来生成需要的订单号。可以想象，在手工调用单个接口都如此麻烦的情况下，每次都要手工调用多个接口会有多么的费时费力。</p>
<p>再说下接口自动化调用测试。这一块儿大多接口测试框架都支持，普遍的做法就是通过代码编写接口测试用例，或者采用数据驱动的方式，然后在支持命令行（CLI）调用的情况下，就可以结合<code>Jenkins</code>或者<code>crontab</code>实现持续集成，或者定时接口监控的功能。</p>
<p>思路是没有问题的，问题在于实际项目中的推动落实情况。要说自动化测试用例最靠谱的维护方式，还是直接通过代码编写测试用例，可靠且不失灵活性，这也是很多经历过惨痛教训的老手的感悟，甚至网络上还出现了一些反测试框架的言论。但问题在于项目中的测试人员并不是都会写代码，也不是对其强制要求就能马上学会的。这种情况下，要想在具体项目中推动接口自动化测试就很难，就算我可以帮忙写一部分，但是很多时候接口测试用例也是要结合业务逻辑场景的，我也的确是没法在这方面投入太多时间，毕竟对接的项目实在太多。所以也是基于这类原因，很多测试框架提倡采用数据驱动的方式，将业务测试用例和执行代码分离。不过由于很多时候业务场景比较复杂，大多数框架测试用例模板引擎的表达能力不足，很难采用简洁的方式对测试场景进行描述，从而也没法很好地得到推广使用。</p>
<p>可以列举的问题还有很多，这些也的确都是在互联网企业的日常测试工作中真实存在的痛点。</p>
<p>基于以上背景，我产生了开发<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的想法。</p>
<p>对于<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的定位，与其说它是一个工具或框架，它更多的应该是一套接口自动化测试的最佳工程实践，而<code>简洁优雅实用</code>应该是它最核心的特点。</p>
<p>当然，每位工程师对<code>最佳工程实践</code>的理念或多或少都会存在一些差异，也希望大家能多多交流，在思维的碰撞中共同进步。</p>
<h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><p><a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>的核心特性概述如下：</p>
<ul>
<li>支持API接口的多种请求方法，包括 GET/POST/HEAD/PUT/DELETE 等</li>
<li>测试用例与代码分离，测试用例维护方式简洁优雅，支持<code>YAML</code></li>
<li>测试用例描述方式具有表现力，可采用简洁的方式描述输入参数和预期输出结果</li>
<li>接口测试用例具有可复用性，便于创建复杂测试场景</li>
<li>测试执行方式简单灵活，支持单接口调用测试、批量接口调用测试、定时任务执行测试</li>
<li>测试结果统计报告简洁清晰，附带详尽日志记录，包括接口请求耗时、请求响应数据等</li>
<li>身兼多职，同时实现接口管理、接口自动化测试、接口性能测试（结合Locust）</li>
<li>具有可扩展性，便于扩展实现Web平台化</li>
</ul>
<h2 id="特性拆解介绍"><a href="#特性拆解介绍" class="headerlink" title="特性拆解介绍"></a>特性拆解介绍</h2><blockquote>
<p>支持API接口的多种请求方法，包括 GET/POST/HEAD/PUT/DELETE 等</p>
</blockquote>
<p>个人偏好，编程语言选择Python。而采用Python实现HTTP请求，最好的方式就是采用<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>库了，简洁优雅，功能强大。</p>
<blockquote>
<p>测试用例与代码分离，测试用例维护方式简洁优雅，支持<code>YAML</code></p>
</blockquote>
<p>要实现测试用例与代码的分离，最好的做法就是做一个测试用例加载引擎和一个测试用例执行引擎，这也是之前在做<a href="https://github.com/debugtalk/AppiumBooster" target="_blank" rel="external"><code>AppiumBooster</code></a>框架的时候总结出来的最优雅的实现方式。当然，这里需要事先对测试用例制定一个标准的数据结构规范，作为测试用例加载引擎和测试用例执行引擎的桥梁。</p>
<p>需要说明的是，测试用例数据结构必须包含接口测试用例完备的信息要素，包括接口请求的信息内容（URL、Headers、Method等参数），以及预期的接口请求响应结果（StatusCode、ResponseHeaders、ResponseContent）。</p>
<p>这样做的好处在于，不管测试用例采用什么形式进行描述（<a href="http://pyyaml.org/" target="_blank" rel="external"><code>YAML</code></a>、JSON、CSV、Excel、XML等），也不管测试用例是否采用了业务分层的组织思想，只要在测试用例加载引擎中实现对应的转换器，都可以将业务测试用例转换为标准的测试用例数据结构。而对于测试用例执行引擎而言，它无需关注测试用例的具体描述形式，只需要从标准的测试用例数据结构中获取到测试用例信息要素，包括接口请求信息和预期接口响应信息，然后构造并发起HTTP请求，再将HTTP请求的响应结果与预期结果进行对比判断即可。</p>
<p>至于为什么明确说明支持<a href="http://pyyaml.org/" target="_blank" rel="external"><code>YAML</code></a>，这是因为个人认为这是最佳的测试用例描述方式，表达简洁不累赘，同时也能包含非常丰富的信息。当然，这只是个人喜好，如果喜欢采用别的方式，只需要扩展实现对应的转换器即可。</p>
<blockquote>
<p>测试用例描述方式具有表现力，可采用简洁的方式描述输入参数和预期输出结果</p>
</blockquote>
<p>测试用例与框架代码分离以后，对业务逻辑测试场景的描述重任就落在测试用例上了。比如我们选择采用<a href="http://pyyaml.org/" target="_blank" rel="external"><code>YAML</code></a>来描述测试用例，那么我们就应该能在<a href="http://pyyaml.org/" target="_blank" rel="external"><code>YAML</code></a>中描述各种复杂的业务场景。</p>
<p>那么怎么理解这个“表现力”呢？</p>
<p>简单的参数值传参应该都容易理解，我们举几个相对复杂但又比较常见的例子。</p>
<ul>
<li>接口请求参数中要包含当前的时间戳；</li>
<li>接口请求参数中要包含一个16位的随机字符串；</li>
<li>接口请求参数中包含签名校验，需要对多个请求参数进行拼接后取md5值；</li>
<li>接口响应头（Headers）中要包含一个<code>X-ATE-V</code>头域，并且需要判断该值是否大于100；</li>
<li>接口响应结果中包含一个字符串，需要校验字符串中是否包含10位长度的订单号；</li>
<li>接口响应结果为一个多层嵌套的json结构体，需要判断某一层的某一个元素值是否为True。</li>
</ul>
<p>可以看出，以上几个例子都是没法直接在测试用例里面描述参数值的。如果是采用Python脚本来编写测试用例还好解决，只需要通过Python函数实现即可。但是现在测试用例和框架代码分离了，我们没法在<a href="http://pyyaml.org/" target="_blank" rel="external"><code>YAML</code></a>里面执行Python函数，这该怎么办呢？</p>
<p>答案就是，定义函数转义符，实现自定义模板。</p>
<p>这种做法其实也不难理解，也算是模板语言通用的方式。例如，我们将<code>${}</code>定义为转义符，那么在<code>{}</code>内的内容就不再当做是普通的字符串，而应该转义为变量值，或者执行函数得到实际结果。当然，这个需要我们在测试用例执行引擎进行适配实现，最简单方式就是提取出<code>${}</code>中的字符串，通过<code>eval</code>计算得到表达式的值。如果要实现更复杂的功能，我们也可以将接口测试中常用的一些功能封装为一套关键字，然后在编写测试用例的时候使用这些关键字。</p>
<blockquote>
<p>接口测试用例具有可复用性，便于创建复杂测试场景</p>
</blockquote>
<p>很多情况下，系统的接口都是有业务逻辑关联的。例如，要请求调用登录接口，需要先请求获取验证码的接口，然后在登录请求中带上获取到的验证码；而要请求数据查询的接口，又要在请求参数中包含登录接口返回的session值。这个时候，我们如果针对每一个要测的业务逻辑，都单独描述要请求的接口，那么就会造成大量的重复描述，测试用例的维护也十分臃肿。</p>
<p>比较好的做法是，将每一个接口调用单独封装为一条测试用例，然后在描述业务测试场景时，选择对应的接口，按照顺序拼接为业务场景测试用例，就像搭积木一般。如果你之前读过<a href="https://github.com/debugtalk/AppiumBooster" target="_blank" rel="external"><code>AppiumBooster</code></a>的介绍，应该还会联想到，我们可以将常用的功能组成模块用例集，然后就可以在更高的层面对模块用例集进行组装，实现更复杂的测试场景。</p>
<p>不过，这里有一个非常关键的问题需要解决，就是如何在接口测试用例之前传参的问题。其实实现起来也不复杂，我们可以在接口请求响应结果中指定一个变量名，然后将接口返回关键值提取出来后赋值给那个变量；然后在其它接口请求参数中，传入这个<code>${变量名}</code>即可。</p>
<blockquote>
<p>测试执行方式简单灵活，支持单接口调用测试、批量接口调用测试、定时任务执行测试</p>
</blockquote>
<p>通过背景中的例子可以看出，需要使用接口测试工具的场景很多，除了定时地对所有接口进行自动化测试检测外，很多时候在手工测试的时候也需要采用接口测试工具进行辅助，也就是<code>半手工+半自动化</code>的模式。</p>
<p>而业务测试人员在使用测试工具的时候，遇到的最大问题在于除了需要关注业务功能本身，还需要花费很多时间去处理技术实现细节上的东西，例如签名校验这类情况，而且往往后者在重复操作中占用的时间更多。</p>
<p>这个问题的确是没法避免的，毕竟不同系统的接口千差万别，不可能存在一款工具可以自动处理所有情况。但是我们可以尝试将接口的技术细节实现和业务参数进行拆分，让业务测试人员只需要关注业务参数部分。</p>
<p>具体地，我们可以针对每一个接口配置一个模板，将其中与业务功能无关的参数以及技术细节封装起来，例如签名校验、时间戳、随机值等，而与业务功能相关的参数配置为可传参的模式。</p>
<p>这样做的好处在于，与业务功能无关的参数以及技术细节我们只需要封装配置一次，而且这个工作可以由开发人员或者测试开发人员来实现，减轻业务测试人员的压力；接口模板配置好后，测试人员只需要关注与业务相关的参数即可，结合业务测试用例，就可以在接口模板的基础上很方便地配置生成多个接口测试用例。</p>
<blockquote>
<p>测试结果统计报告简洁清晰，附带详尽日志记录，包括接口请求耗时、请求响应数据等</p>
</blockquote>
<p>测试结果统计报告，应该遵循简洁而不简单的原则。“简洁”，是因为大多数时候我们只需要在最短的时间内判断所有接口是否运行正常即可。而“不简单”，是因为当存在执行失败的测试用例时，我们期望能获得接口测试时尽可能详细的数据，包括测试时间、请求参数、响应内容、接口响应耗时等。</p>
<p>之前在读<code>locust</code>源码时，其对<a href="https://github.com/locustio/locust/blob/master/locust/clients.py" target="_blank" rel="external"><code>HTTP</code>客户端</a>的封装方式给我留下了深刻的印象。它采用的做法是，继承<code>requests.Session</code>类，在子类<code>HttpSession</code>中重写覆盖了<code>request</code>方法，然后在<code>request</code>方法中对<code>requests.Session.request</code>进行了一层封装。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">request_meta = &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment"># set up pre_request hook for attaching meta data to the request object</span></div><div class="line">request_meta[<span class="string">"method"</span>] = method</div><div class="line">request_meta[<span class="string">"start_time"</span>] = time.time()</div><div class="line"></div><div class="line">response = self._send_request_safe_mode(method, url, **kwargs)</div><div class="line"></div><div class="line"><span class="comment"># record the consumed time</span></div><div class="line">request_meta[<span class="string">"response_time"</span>] = int((time.time() - request_meta[<span class="string">"start_time"</span>]) * <span class="number">1000</span>)</div><div class="line"></div><div class="line">request_meta[<span class="string">"content_size"</span>] = int(response.headers.get(<span class="string">"content-length"</span>) <span class="keyword">or</span> <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>而<code>HttpLocust</code>的每一个虚拟用户（client）都是一个<code>HttpSession</code>实例，这样每次在执行<code>HTTP</code>请求的时候，既可充分利用<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>库的强大功能，同时也能将请求的响应时间、响应体大小等原始性能数据进行保存，实现可谓十分优雅。</p>
<p>受到该处启发，要保存接口的详细请求响应数据也可采用同样的方式。例如，要保存<code>Response</code>的<code>Headers</code>、<code>Body</code>只需要增加如下两行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">request_meta[<span class="string">"response_headers"</span>] = response.headers</div><div class="line">request_meta[<span class="string">"response_content"</span>] = response.content</div></pre></td></tr></table></figure>
<blockquote>
<p>身兼多职，同时实现接口管理、接口自动化测试、接口性能测试（结合Locust）</p>
</blockquote>
<p>其实像接口性能测试这样的需求，不应该算到接口自动化测试框架的职责范围之内。但是在实际项目中需求就是这样，又要做接口自动化测试，又要做接口性能测试，而且还不想同时维护两套代码。</p>
<p>多亏有了<code>locust</code>性能测试框架，接口自动化和性能测试脚本还真能合二为一。</p>
<p>前面也讲了，<code>HttpLocust</code>的每一个虚拟用户（client）都是一个<code>HttpSession</code>实例，而<code>HttpSession</code>又继承自<code>requests.Session</code>类，所以<code>HttpLocust</code>的每一个虚拟用户（client）也是<code>requests.Session</code>类的实例。</p>
<p>同样的，我们在用<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="external"><code>Requests</code></a>库做接口测试时，请求客户端其实也是<code>requests.Session</code>类的实例，只是我们通常用的是<code>requests</code>的简化用法。</p>
<p>以下两种用法是等价的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">resp = requests.get(<span class="string">'http://debugtalk.com'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 等价于</span></div><div class="line">client = requests.Session()</div><div class="line">resp = client.get(<span class="string">'http://debugtalk.com'</span>)</div></pre></td></tr></table></figure>
<p>有了这一层关系以后，要在接口自动化测试和性能测试之间切换就很容易了。在接口测试框架内，可以通过如下方式初始化<code>HTTP</code>客户端。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, origin, kwargs, http_client_session=None)</span>:</span></div><div class="line">   self.http_client_session = http_client_session <span class="keyword">or</span> requests.Session()</div></pre></td></tr></table></figure>
<p>默认情况下，<code>http_client_session</code>是<code>requests.Session</code>的实例，用于进行接口测试；当需要进行性能测试时，只需要传入<code>locust</code>的<code>HttpSession</code>实例即可。</p>
<blockquote>
<p>具有可扩展性，便于扩展实现Web平台化</p>
</blockquote>
<p>当要将测试平台推广至更广阔的用户群体（例如产品经理、运营人员）时，对框架实现Web化就在所难免了。在Web平台上查看接口测试用例运行情况、对接口模块进行配置、对接口测试用例进行管理，的确会便捷很多。</p>
<p>不过对于接口测试框架来说，<code>Web平台</code>只能算作锦上添花的功能。我们在初期可以优先实现命令行（CLI）调用方式，规范好数据存储结构，后期再结合Web框架（如Flask）增加实现Web平台功能。</p>
<h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>以上便是我对<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>特性的详细介绍，也算是我个人对接口自动化测试<code>最佳工程实践</code>的理念阐述。</p>
<p>当前，<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external"><code>ApiTestEngine</code></a>还处于开发过程中，代码也开源托管在GitHub上，欢迎<code>Star</code>关注。</p>
<p>GitHub项目地址：<a href="https://github.com/debugtalk/ApiTestEngine" target="_blank" rel="external">https://github.com/debugtalk/ApiTestEngine</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://debugtalk.com/post/build-ideal-app-automation-test-framework/">《打造心目中理想的自动化测试框架（AppiumBooster）》</a></li>
<li><a href="http://myzhan.github.io/2016/03/04/giving-up-robotframework/" target="_blank" rel="external">《告别robotframework》</a></li>
<li><a href="https://github.com/svanoort/pyresttest/blob/master/advanced_guide.md" target="_blank" rel="external">《Advanced Guide For PyRestTest》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;当前市面上存在的接口测试工具已经非常多，常见的如&lt;code&gt;Postman&lt;/code&gt;、&lt;code&gt;JMeter&lt;/code&gt;、&lt;code
    
    </summary>
    
    
      <category term="接口测试" scheme="http://debugtalk.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
      <category term="自动化测试" scheme="http://debugtalk.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="测试框架" scheme="http://debugtalk.com/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"/>
    
      <category term="HttpRunner" scheme="http://debugtalk.com/tags/HttpRunner/"/>
    
  </entry>
  
  <entry>
    <title>【科普】互联网测试岗位的工作日常</title>
    <link href="http://debugtalk.com/post/introduction-to-testing-engineer-daily-work/"/>
    <id>http://debugtalk.com/post/introduction-to-testing-engineer-daily-work/</id>
    <published>2017-06-14T16:00:00.000Z</published>
    <updated>2017-09-04T05:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期公司新来了一批实习生，公司也组织了大量的人力物力对实习生的进行培训。不得不说，公司的确在朝”大公司“的方向发展，各项制度福利也在逐步完善。以前别说是实习生了，不管是社招还是校招来的人，都是入职后就直接上岗，哪有这么多培训机会。</p>
<p>分配给我的任务是对我们质量部的岗位进行介绍，给实习生们讲解下我们测试工程师的工作日常情况。由于面向的都是新人，而且各种岗位的都有，因此也只能是科普介绍了。当时也没有准备PPT，就是提前想了几个主题点，然后就简单展开讲了下。</p>
<p>培训结束后感觉这个科普可能对于刚毕业或者还没有毕业的同学还是有一些价值的，因此就将今天讲的内容整理为文字。老司机们就不用看了，我们后续再聊。</p>
<p>——— 分割线 ———</p>
<p>大家好，我是李隆，当前在互联网事业部的质量部做测试开发岗位。在之前的培训中，大家应该知道了，当前我们质量部共分为三类岗位，分别是QA、测试和测试开发。不知道大家有没有想过，为什么要这么划分？这三类岗位的区别和联系在哪里？</p>
<p>这就要从质量部的名称说起了。在日常工作中，通常我们都是说产品、开发、测试、运维，那为什么我们不是叫做测试部，而是叫质量部呢？这是因为，站在软件工程的角度，测试只是手段，而保障项目质量才是我们的最终目的。</p>
<p>那么，”质量“这两个字要怎么理解呢？这是一个非常大的问题，我的确也没法单纯从字面上给大家解释它的完整含义。那我们不妨换个角度，先来看下日常工作中哪些情况会对项目质量造成影响，或者说当出现哪些现象时，就可以说明我们的项目质量存在问题。</p>
<ul>
<li>开发提交的代码里面有bug。这个应该是最常见的，也是大家最熟悉的质量问题了。</li>
<li>产品的需求描述不清楚，或者需求里面有隐藏的业务逻辑问题，甚至压根就没有需求文档，完全是”一句话需求“。可以想象，这种情况通常造成的后果就是开发到后期才会发现与预期需求不符，严重的甚至造成返工的后果。</li>
<li>开发人员没有写单元测试，项目没有版本规划，提测比较随意并且没有自测。这种情况通常就会造成所有人员都很忙，天天加班，但是项目质量问题越来越多。</li>
<li>运维人员操作没有规范指引，也没有风险预案机制，说不定哪天某个运维人员没睡醒，一不小心就”删库“然后”跑路“了。</li>
<li>测试人员没有测试策略，设计的测试用例仅局限于UI功能层面，难以实现核心业务逻辑的覆盖，也无法发现深层次的问题。</li>
<li>测试人员需要做大量的重复性回归测试，也没有引入自动化测试机制，造成要么没有回归测试，要么测试耗费大量人力和时间成本。</li>
</ul>
<p>还可以列出来的内容还有很多，不难看出，以上每一种情况都会造成项目质量出现问题，而且很多看似跟测试不直接相关的情况，往往造成的质量问题比单纯的代码bug更严重。而如果我们只是单纯地从软件测试的角度去考虑的话，我们会遗漏很多问题，项目整体质量也没法得到保障。相信你们这时应该会明白，质量部这个名称的真正含义了。</p>
<p>通过以上实例，可以看出质量部可以做的事情，以及必须要去做的事情非常多，但是这个范围又这么广，毕竟术业有专攻，不可能要求每个人都能做到那么多，所以我们质量部才有了岗位划分。</p>
<p>先来说下QA这个岗位，这个岗位主要是做什么的呢？还是回到前面提到的案例，当项目团队没有规范流程的时候，项目质量是很难保障的，往往都会有事倍功半的情况。当团队处于这种状态的时候，QA应该是第一个站出来，让项目组的所有人员认识到流程规范的重要性，并且牵头来制定和梳理流程，包括产品需求应该写成什么样才算规范，版本发版周期定为怎样才算合适，测试人员的用例规范，验收标准，以及运维人员应该有怎样的操作规范，等等。当规范建立起来后，QA也会参与到日常的测试工作中去，除了单纯的测试工作外，QA还需要对项目规范流程进行监督，发掘在实际工作中有哪些是不符合流程规范的，或者哪些流程规范是可以改进的，然后再协同各方人员来一起优化。可以看出，QA这个岗位可能并不是要特别精通于某项测试技术，但是TA一定是要对项目质量有非常灵敏的嗅觉，总是能及时地发现当前项目中可能会影响项目质量的”坏味道“，及时地暴露问题，并且跟进问题的解决。</p>
<p>然后再来说下测试岗位。测试这个岗位应该是大家从感觉上最直观，也是业界大众普遍认知里负责软件测试的岗位。可能有人会觉得，测试这个岗位是产品开发周期的末端，只有等到研发开发完毕，提测以后才开始工作。其实不是这样的。一个好的测试人员，应该是关注项目开发周期的整个流程的。在产品需求出来后，测试就应该要参与产品需求评审，并利用自身在业务方面的测试经验积累，充分挖掘新版本需求可能存在的业务逻辑漏洞。在开发设计技术方案的时候，测试人员也要参与到技术评审，从软件测试的角度，挖掘技术方案中可能存在的技术漏洞。评审完成后，在开发还在编码实现的时候，就需要根据当前版本需求设计测试策略，编写测试用例。等到开发提交测试以后，才是开始大家普遍认知上的测试工作。具体地，对于测试岗位来说，这本来就是一个技术性的岗位，除了需要掌握多种测试理论方法外，还需要根据系统类型的实际测试需要，熟练使用对应的测试工具。测试类型也会很多，除了最基础的功能测试外，也会根据实际情况，对Web前端进行页面兼容性测试、对app进行客户端性能专项测试（启动时间、启动内存、流畅度、包大小等），对后台服务器端进行性能测试（响应时间、吞吐量等），对系统安全进行测试，等等。</p>
<p>最后再来说下测试开发，也就是当前我所在的这个岗位。那么测试开发要做什么呢？可能我讲一个之前的经历大家就清楚了。</p>
<blockquote>
<p>我上一家公司在阿里巴巴，当时也是做测试开发岗位。刚进公司的时候，组里的同事跟我说，欢迎来到”生促（畜）组“，看到我一脸懵逼，同事解释到，生产力促进组嘛。我说，这名字也太难听了吧。同事说，这还算好的了，知道以前其它组的叫我们什么吗？促（畜）生组，促进生产力组。<br>这么一对比，”生促组“听上去的确是优雅多了。</p>
</blockquote>
<p>可以看到，不管是”生促“还是”促生“，测试开发这个岗位的核心都是围绕着如何提升生产力，也就是工作效率上面。当然，提高生产力也分为两个层面。第一个层面是提高质量部内部测试人员的测试效率，当前我们也主要还停留在这个层面。前面的例子也说道，当测试人员需要进行大量的重复性回归测试的时候，或者在日常工作中存在简单重复低效的工作内容的时候，这个时候就需要测试开发人员来辅助开发相应的工具平台，常见的包括实现接口测试自动化、UI自动化、持续集成等，将测试人员从重复性的工作解放出来，从而能有更多的时间精力投入到探索性测试当中去。第二个层面呢，也是我们后续的工作目标，那就是提高整个研发团队的工作效率。当然这可能不是测试开发岗位就能独立完成的，这也需要联合开发和运维同学，一起梳理整个研发测试运维流程，然后从技术的角度去开发实现一些工具平台，从而让整个项目团队能更高效的运作。</p>
<p>当然，虽然存在着QA、测试、测试开发的岗位划分，但是在实际工作中并不会有特别严格的界限，只是相对来说工作重心有所侧重而已。就比如说，QA和测试开发岗位也是会参与到测试工作中的，因为如果你不熟悉测试，你怎么知道测试过程中存在哪些不规范的地方，你怎么知道测试在哪些地方存在低效的痛点？同样的，测试人员要更好地理解流程和规范，也需要参与到流程规范的制订讨论工作中；而要更好地实现对系统的测试，必定需要用到一些技术手段，甚至自身具备足够的编码能力，来开展专项测试、性能测试等测试工作，从而能更好地应用技术手段来保障项目质量。</p>
<p>以上便是我对质量部各个岗位工作内容的介绍，也非常欢迎各位到质量部来轮岗。</p>
<p>其实也可以毫不夸张地说，测试岗位对于一个刚接触互联网行业的新人来说，的确是一个非常适合从整体上快速了解行业的岗位。为什么这么说？因为从前面的介绍也可以看出来，测试岗位需要参与项目的整个流程，也需要跟各种角色的人员进行沟通交流，只要用心，就能快速地得到成长，并对各个岗位能有一个较清晰的认识，这对你们后续选择职业方向和岗位的时候也是非常有帮助的。</p>
<p>——— 分割线 ———</p>
<p>最后再发点小感悟。这次也算是第一次大量接触”95后“，直观的印象，的确是一个非常活跃的群体。一方面的体现，就是参与度很强，在每个主题讲解完成后，都有大量的提问，交流十分活跃；而另一方面，就是思维活跃，虽然实习生大多都是才大三，但是从提问的问题来看，他们的知识面很广，很多问题都可以看出是经过认真思考的，而且有些问题还很有深度。</p>
<p>不得不佩服的同时，再想想自己的年龄，不禁黯然神伤，啥也不说了，搬砖去了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期公司新来了一批实习生，公司也组织了大量的人力物力对实习生的进行培训。不得不说，公司的确在朝”大公司“的方向发展，各项制度福利也在逐步完善。以前别说是实习生了，不管是社招还是校招来的人，都是入职后就直接上岗，哪有这么多培训机会。&lt;/p&gt;
&lt;p&gt;分配给我的任务是对我们质量部
    
    </summary>
    
    
      <category term="个人成长" scheme="http://debugtalk.com/tags/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"/>
    
      <category term="培训" scheme="http://debugtalk.com/tags/%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用pyenv管理多个Python版本依赖环境</title>
    <link href="http://debugtalk.com/post/use-pyenv-manage-multiple-python-virtualenvs/"/>
    <id>http://debugtalk.com/post/use-pyenv-manage-multiple-python-virtualenvs/</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2017-09-04T05:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从接触Python以来，一直都是采用<a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="external"><code>virtualenv</code></a>和<a href="https://pypi.python.org/pypi/virtualenvwrapper" target="_blank" rel="external"><code>virtualenvwrapper</code></a>来管理不同项目的依赖环境，通过<code>workon</code>、<code>mkvirtualenv</code>等命令进行虚拟环境切换，很是愉快。</p>
<p>然而，最近想让项目能兼容更多的Python版本，例如至少同时兼容<code>Python2.7</code>和<code>Python3.3+</code>，就发现采用之前的方式行不通了。</p>
<p>最大的问题在于，在本地计算机同时安装<code>Python2.7</code>和<code>Python3</code>后，即使分别针对两个Python版本安装了<code>virtualenv</code>和<code>virtualenvwrapper</code>，也无法让两个Python版本的<code>workon</code>、<code>mkvirtualenv</code>命令同时生效。另外一方面，要想在本地计算机安装多个Python版本，会发现安装的成本都比较高，实现方式也不够优雅。</p>
<p>幸运地是，针对该痛点，已经存在一个比较成熟的方案，那就是<a href="https://github.com/pyenv/pyenv" target="_blank" rel="external"><code>pyenv</code></a>。</p>
<p>如下是官方的介绍。</p>
<blockquote>
<p>pyenv lets you easily switch between multiple versions of Python. It’s simple, unobtrusive, and follows the UNIX tradition of single-purpose tools that do one thing well.</p>
<p>This project was forked from <a href="https://github.com/rbenv/rbenv" target="_blank" rel="external">rbenv</a> and <a href="https://github.com/rbenv/ruby-build" target="_blank" rel="external">ruby-build</a>, and modified for Python.</p>
</blockquote>
<p>本文就针对<code>pyenv</code>最核心的功能进行介绍。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>如果要讲解<code>pyenv</code>的工作原理，基本上采用一句话就可以概括，那就是：修改系统环境变量<code>PATH</code>。</p>
<p>对于系统环境变量<code>PATH</code>，相信大家都不陌生，里面包含了一串由冒号分隔的路径，例如<code>/usr/local/bin:/usr/bin:/bin</code>。每当在系统中执行一个命令时，例如<code>python</code>或<code>pip</code>，操作系统就会在<code>PATH</code>的所有路径中从左至右依次寻找对应的命令。因为是依次寻找，因此排在左边的路径具有更高的优先级。</p>
<p>而<code>pyenv</code>做的，就是在<code>PATH</code>最前面插入一个<code>$(pyenv root)/shims</code>目录。这样，<code>pyenv</code>就可以通过控制<code>shims</code>目录中的Python版本号，来灵活地切换至我们所需的Python版本。</p>
<p>如果还想了解更多细节，可以查看<a href="https://github.com/pyenv/pyenv" target="_blank" rel="external"><code>pyenv</code></a>的文档介绍及其源码实现。</p>
<h2 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h2><p><code>pyenv</code>的安装方式包括多种，重点推荐采用<a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="external"><code>pyenv-installer</code></a>的方式，原因主要有两点：</p>
<ul>
<li>通过<code>pyenv-installer</code>可一键安装<code>pyenv</code>全家桶，后续也可以很方便地实现一键升级；</li>
<li><code>pyenv-installer</code>的安装方式基于<code>GitHub</code>，可保证总是使用到最新版本的<code>pyenv</code>，并且<code>Python</code>版本库也是最新最全的。</li>
</ul>
<h3 id="install-amp-amp-config"><a href="#install-amp-amp-config" class="headerlink" title="install &amp;&amp; config"></a>install &amp;&amp; config</h3><p>通过如下命令安装<code>pyenv</code>全家桶。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -L https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash</div></pre></td></tr></table></figure>
<p>内容除了包含<code>pyenv</code>以外，还包含如下插件：</p>
<ul>
<li><code>pyenv-doctor</code></li>
<li><code>pyenv-installer</code></li>
<li><code>pyenv-update</code></li>
<li><code>pyenv-virtualenv</code></li>
<li><code>pyenv-which-ext</code></li>
</ul>
<p>安装完成后，<code>pyenv</code>命令还没有加进系统的环境变量，需要将如下内容加到<code>~/.zshrc</code>中，然后执行<code>source ~/.zshrc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export PATH=$HOME/.pyenv/bin:$PATH</div><div class="line">eval &quot;$(pyenv init -)&quot;</div><div class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</div></pre></td></tr></table></figure>
<p>完成以上操作后，<code>pyenv</code>就安装完成了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pyenv -v</div><div class="line">pyenv 1.0.8</div></pre></td></tr></table></figure>
<p>如果不确定<code>pyenv</code>的环境是否安装正常，可以通过<code>pyenv doctor</code>命令对环境进行检测。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ pyenv doctor</div><div class="line">Cloning /Users/Leo/.pyenv/plugins/pyenv-doctor/bin/.....</div><div class="line">Installing python-pyenv-doctor...</div><div class="line"></div><div class="line">BUILD FAILED (OS X 10.12.3 using python-build 20160602)</div><div class="line"></div><div class="line">Last 10 log lines:</div><div class="line">checking for memory.h... yes</div><div class="line">checking for strings.h... yes</div><div class="line">checking for inttypes.h... yes</div><div class="line">checking for stdint.h... yes</div><div class="line">checking for unistd.h... yes</div><div class="line">checking openssl/ssl.h usability... no</div><div class="line">checking openssl/ssl.h presence... no</div><div class="line">checking for openssl/ssl.h... no</div><div class="line">configure: error: OpenSSL development header is not installed.</div><div class="line">make: *** No targets specified and no makefile found.  Stop.</div><div class="line">Problem(s) detected while checking system.</div></pre></td></tr></table></figure>
<p>通过检测，可以发现本地环境可能存在的问题，例如，从以上输出可以看出，本地的<code>OpenSSL development header</code>还没有安装。根据提示的问题，逐一进行修复，直到检测不再出现问题为止。</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>通过<code>pyenv update</code>命令，可以更新<code>pyenv</code>全家桶的所有内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ pyenv update</div><div class="line">Updating /Users/Leo/.pyenv...</div><div class="line">From https://github.com/yyuu/pyenv</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Already up-to-date.</div><div class="line">Updating /Users/Leo/.pyenv/plugins/pyenv-doctor...</div><div class="line">From https://github.com/yyuu/pyenv-doctor</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Already up-to-date.</div><div class="line">Updating /Users/Leo/.pyenv/plugins/pyenv-installer...</div><div class="line">From https://github.com/yyuu/pyenv-installer</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Already up-to-date.</div><div class="line">Updating /Users/Leo/.pyenv/plugins/pyenv-update...</div><div class="line">From https://github.com/yyuu/pyenv-update</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Already up-to-date.</div><div class="line">Updating /Users/Leo/.pyenv/plugins/pyenv-virtualenv...</div><div class="line">From https://github.com/yyuu/pyenv-virtualenv</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Already up-to-date.</div><div class="line">Updating /Users/Leo/.pyenv/plugins/pyenv-which-ext...</div><div class="line">From https://github.com/yyuu/pyenv-which-ext</div><div class="line"> * branch            master     -&gt; FETCH_HEAD</div><div class="line">Already up-to-date.</div></pre></td></tr></table></figure>
<h2 id="pyenv的核心使用方法"><a href="#pyenv的核心使用方法" class="headerlink" title="pyenv的核心使用方法"></a>pyenv的核心使用方法</h2><p><code>pyenv</code>的主要功能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ pyenv -h</div><div class="line">Usage: pyenv &lt;command&gt; [&lt;args&gt;]</div><div class="line"></div><div class="line">Some useful pyenv commands are:</div><div class="line">   commands    List all available pyenv commands</div><div class="line">   local       Set or show the local application-specific Python version</div><div class="line">   global      Set or show the global Python version</div><div class="line">   shell       Set or show the shell-specific Python version</div><div class="line">   install     Install a Python version using python-build</div><div class="line">   uninstall   Uninstall a specific Python version</div><div class="line">   rehash      Rehash pyenv shims (run this after installing executables)</div><div class="line">   version     Show the current Python version and its origin</div><div class="line">   versions    List all Python versions available to pyenv</div><div class="line">   which       Display the full path to an executable</div><div class="line">   whence      List all Python versions that contain the given executable</div><div class="line"></div><div class="line">See `pyenv help &lt;command&gt;&apos; for information on a specific command.</div><div class="line">For full documentation, see: https://github.com/yyuu/pyenv#readme</div></pre></td></tr></table></figure>
<h3 id="查看所有可安装的Python版本"><a href="#查看所有可安装的Python版本" class="headerlink" title="查看所有可安装的Python版本"></a>查看所有可安装的<code>Python</code>版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ pyenv install --list</div><div class="line">Available versions:</div><div class="line">  2.1.3</div><div class="line">  ...</div><div class="line">  2.7.12</div><div class="line">  2.7.13</div><div class="line">  ...</div><div class="line">  3.5.3</div><div class="line">  3.6.0</div><div class="line">  3.6-dev</div><div class="line">  3.6.1</div><div class="line">  3.7-dev</div></pre></td></tr></table></figure>
<p>需要注意的是，如果是采用<code>brew</code>命令安装的<code>pyenv</code>，可能会发现<code>Python</code>版本库中没有最新的<code>Python</code>版本。所以建议还是通过<code>GitHub</code>源码方式安装<code>pyenv</code>。</p>
<h3 id="安装指定版本的Python环境"><a href="#安装指定版本的Python环境" class="headerlink" title="安装指定版本的Python环境"></a>安装指定版本的<code>Python</code>环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pyenv install 3.6.0</div><div class="line">Downloading Python-3.6.0.tar.xz...</div><div class="line">-&gt; https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tar.xz</div><div class="line">Installing Python-3.6.0...</div><div class="line">Installed Python-3.6.0 to /Users/Leo/.pyenv/versions/3.6.0</div></pre></td></tr></table></figure>
<h3 id="查看当前系统中所有可用的Python版本"><a href="#查看当前系统中所有可用的Python版本" class="headerlink" title="查看当前系统中所有可用的Python版本"></a>查看当前系统中所有可用的<code>Python</code>版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pyenv versions</div><div class="line">* system (set by /Users/Leo/.pyenv/version)</div><div class="line">  2.7.13</div><div class="line">  3.6.0</div></pre></td></tr></table></figure>
<h3 id="切换Python版本"><a href="#切换Python版本" class="headerlink" title="切换Python版本"></a>切换<code>Python</code>版本</h3><p><code>pyenv</code>可以从三个维度来管理<code>Python</code>环境，简称为：<code>当前系统</code>、<code>当前目录</code>、<code>当前shell</code>。这三个维度的优先级从左到右依次升高，即<code>当前系统</code>的优先级最低、<code>当前shell</code>的优先级最高。</p>
<p>如果想修改系统全局的Python环境，可以采用<code>pyenv global PYTHON_VERSION</code>命令。该命令执行后会在<code>$(pyenv root)</code>目录（默认为<code>~/.pyenv</code>）中创建一个名为<code>version</code>的文件（如果该文件已存在，则修改该文件的内容），里面记录着系统全局的Python版本号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ pyenv global 2.7.13</div><div class="line">$ cat ~/.pyenv/version</div><div class="line">2.7.13</div><div class="line">$ pyenv version</div><div class="line">2.7.13 (<span class="built_in">set</span> by /Users/Leo/.pyenv/version)</div><div class="line"></div><div class="line">$ pyenv global 3.6.0</div><div class="line">$ cat ~/.pyenv/version</div><div class="line">3.6.0</div><div class="line">$ pyenv version</div><div class="line">3.6.0 (<span class="built_in">set</span> by /Users/Leo/.pyenv/version)</div></pre></td></tr></table></figure>
<p>通常情况下，对于特定的项目，我们可能需要切换不同的Python环境，这个时候就可以通过<code>pyenv local PYTHON_VERSION</code>命令来修改<code>当前目录</code>的Python环境。命令执行后，会在当前目录中生成一个<code>.python-version</code>文件（如果该文件已存在，则修改该文件的内容），里面记录着当前目录使用的Python版本号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ cat ~/.pyenv/version</div><div class="line">2.7.13</div><div class="line">$ pyenv <span class="built_in">local</span> 3.6.0</div><div class="line">$ cat .python-version</div><div class="line">3.6.0</div><div class="line">$ cat ~/.pyenv/version</div><div class="line">2.7.13</div><div class="line">$ pyenv version</div><div class="line">3.6.0 (<span class="built_in">set</span> by /Users/Leo/MyProjects/.python-version)</div><div class="line">$ pip -V</div><div class="line">pip 9.0.1 from /Users/Leo/.pyenv/versions/3.6.0/lib/python3.6/site-packages (python 3.6)</div></pre></td></tr></table></figure>
<p>可以看出，当前目录中的<code>.python-version</code>配置优先于系统全局的<code>~/.pyenv/version</code>配置。</p>
<p>另外一种情况，通过执行<code>pyenv shell PYTHON_VERSION</code>命令，可以修改<code>当前shell</code>的Python环境。执行该命令后，会在当前<code>shell session</code>（Terminal窗口）中创建一个名为<code>PYENV_VERSION</code>的环境变量，然后在<code>当前shell</code>的任意目录中都会采用该环境变量设定的Python版本。此时，<code>当前系统</code>和<code>当前目录</code>中设定的Python版本均会被忽略。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="variable">$PYENV_VERSION</span></div><div class="line"></div><div class="line">$ pyenv shell 3.6.0</div><div class="line">$ <span class="built_in">echo</span> <span class="variable">$PYENV_VERSION</span></div><div class="line">3.6.0</div><div class="line">$ cat .python-version</div><div class="line">2.7.13</div><div class="line">$ pyenv version</div><div class="line">3.6.0 (<span class="built_in">set</span> by PYENV_VERSION environment variable)</div></pre></td></tr></table></figure>
<p>顾名思义，<code>当前shell</code>的Python环境仅在当前shell中生效，重新打开一个新的shell后，该环境也就失效了。如果想在<code>当前shell</code>中取消shell级别的Python环境，采用<code>unset</code>命令重置<code>PYENV_VERSION</code>环境变量即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat .python-version</div><div class="line">2.7.13</div><div class="line">$ pyenv version</div><div class="line">3.6.0 (<span class="built_in">set</span> by PYENV_VERSION environment variable)</div><div class="line"></div><div class="line">$ <span class="built_in">unset</span> PYENV_VERSION</div><div class="line">$ pyenv version</div><div class="line">2.7.13 (<span class="built_in">set</span> by /Users/Leo/MyProjects/.python-version)</div></pre></td></tr></table></figure>
<h2 id="管理多个依赖库环境"><a href="#管理多个依赖库环境" class="headerlink" title="管理多个依赖库环境"></a>管理多个依赖库环境</h2><p>经过以上操作，我们在本地计算机中就可以安装多个版本的<code>Python</code>运行环境，并可以按照实际需求进行灵活地切换。然而，很多时候在同一个<code>Python</code>版本下，我们仍然希望能根据项目进行环境分离，就跟之前我们使用<code>virtualenv</code>一样。</p>
<p>在<code>pyenv</code>中，也包含这么一个插件，<a href="https://github.com/pyenv/pyenv-virtualenv" target="_blank" rel="external"><code>pyenv-virtualenv</code></a>，可以实现同样的功能。</p>
<p>使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pyenv virtualenv PYTHON_VERSION PROJECT_NAME</div></pre></td></tr></table></figure>
<p>其中，<code>PYTHON_VERSION</code>是具体的Python版本号，例如，<code>3.6.0</code>，<code>PROJECT_NAME</code>是我们自定义的项目名称。比较好的实践方式是，在<code>PROJECT_NAME</code>也带上Python的版本号，以便于识别。</p>
<p>现假设我们有<code>XDiff</code>这么一个项目，想针对<code>Python 2.7.13</code>和<code>Python 3.6.0</code>分别创建一个虚拟环境，那就可以依次执行如下命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pyenv virtualenv 3.6.0 py36_XDiff</div><div class="line">$ pyenv virtualenv 2.7.13 py27_XDiff</div></pre></td></tr></table></figure>
<p>创建完成后，通过执行<code>pyenv virtualenvs</code>命令，就可以看到本地所有的项目环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ pyenv virtualenvs</div><div class="line">  2.7.13/envs/py27_XDiff (created from /Users/Leo/.pyenv/versions/2.7.13)</div><div class="line">* 3.6.0/envs/py36_XDiff (created from /Users/Leo/.pyenv/versions/3.6.0)</div><div class="line">  py27_XDiff (created from /Users/Leo/.pyenv/versions/2.7.13)</div><div class="line">  py36_XDiff (created from /Users/Leo/.pyenv/versions/3.6.0)</div></pre></td></tr></table></figure>
<p>通过这种方式，在同一个Python版本下我们也可以创建多个虚拟环境，然后在各个虚拟环境中分别维护依赖库环境。</p>
<p>例如，<code>py36_XDiff</code>虚拟环境位于<code>/Users/Leo/.pyenv/versions/3.6.0/envs</code>目录下，而其依赖库位于<code>/Users/Leo/.pyenv/versions/3.6.0/lib/python3.6/site-packages</code>中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pip -V</div><div class="line">pip 9.0.1 from /Users/Leo/.pyenv/versions/3.6.0/lib/python3.6/site-packages (python 3.6)</div></pre></td></tr></table></figure>
<p>后续在项目开发过程中，我们就可以通过<code>pyenv local XXX</code>或<code>pyenv activate PROJECT_NAME</code>命令来切换项目的<code>Python</code>环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  MyProjects pyenv <span class="built_in">local</span> py27_XDiff</div><div class="line">(py27_XDiff) ➜  MyProjects pyenv version</div><div class="line">py27_XDiff (<span class="built_in">set</span> by /Users/Leo/MyProjects/.python-version)</div><div class="line">(py27_XDiff) ➜  MyProjects python -V</div><div class="line">Python 2.7.13</div><div class="line">(py27_XDiff) ➜  MyProjects pip -V</div><div class="line">pip 9.0.1 from /Users/Leo/.pyenv/versions/2.7.13/envs/py27_XDiff/lib/python2.7/site-packages (python 2.7)</div></pre></td></tr></table></figure>
<p>可以看出，切换环境后，<code>pip</code>命令对应的目录也随之改变，即始终对应着当前的Python虚拟环境。</p>
<p>对应的，采用<code>pyenv deactivate</code>命令退出当前项目的<code>Python</code>虚拟环境。</p>
<p>如果想移除某个项目环境，可以通过如下命令实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pyenv uninstall PROJECT_NAME</div></pre></td></tr></table></figure>
<p>以上便是日常开发工作中常用的<code>pyenv</code>命令，基本可以满足绝大多数依赖库环境管理方面的需求。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从接触Python以来，一直都是采用&lt;a href=&quot;https://virtualenv.pypa.io/en/stable/&quot; targ
    
    </summary>
    
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="pyenv" scheme="http://debugtalk.com/tags/pyenv/"/>
    
      <category term="virtualenv" scheme="http://debugtalk.com/tags/virtualenv/"/>
    
  </entry>
  
</feed>
