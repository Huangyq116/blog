<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.0.1">


  <link rel="mask-icon" href="/images/safari-pinned-tab.svg?v=7.0.1" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml">





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true,"dimmer":true},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<script>
  (function(i,s,o,g,r,a,m){i["SlardarMonitorObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date;a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://i.snssdk.com/slardar/sdk.js?bid=debugtalk","Slardar");
</script>
<script>
  window.Slardar('config', {
    sampleRate: 1,
    bid: 'debugtalk',
    ignoreAjax: [],
    ignoreStatic: [],
    hookFetch: true,
    enableSizeStats: true
  });
  window.Slardar('send', 'pageview');
</script>



  

<script>
  (function(i,s,o,g,r,a,m){i["SlardarMonitorObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date;a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,"script","https://i.snssdk.com/slardar/sdk.js?bid=debugtalk","Slardar");
</script>
<script>
  window.Slardar('config', {
    sampleRate: 1,
    bid: 'debugtalk',
    ignoreAjax: [],
    ignoreStatic: [],
    hookFetch: true,
    enableSizeStats: true
  });
  window.Slardar('send', 'pageview');
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="DebugTalk">
<meta property="og:url" content="https://debugtalk.com/page/6/index.html">
<meta property="og:site_name" content="DebugTalk">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DebugTalk">



  <link rel="alternate" href="/atom.xml" title="DebugTalk" type="application/atom+xml">




  <link rel="canonical" href="https://debugtalk.com/page/6/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>DebugTalk</title>
  




  <script async src="//www.googletagmanager.com/gtag/js?id=[object Object]"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-81639610-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DebugTalk</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">探索一个软件工程师的无限可能</h1>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/debugtalk" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/iOS-Android-Packing-with-Jenkins/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/iOS-Android-Packing-with-Jenkins/" class="post-title-link" itemprop="url">使用 Jenkins 搭建 iOS/Android 持续集成打包平台</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-28 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-28T00:00:00+08:00">2016-06-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/" itemprop="url" rel="index"><span itemprop="name">4. ToolsNotes</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/Jenkins/" itemprop="url" rel="index"><span itemprop="name">Jenkins</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>根据项目需求，现要在团队内部搭建一个统一的打包平台，实现对iOS和Android项目的打包。而且为了方便团队内部的测试包分发，希望在打包完成后能生成一个二维码，体验用户（产品、运营、测试等人员）通过手机扫描二维码后就能直接安装测试包。</p>
<p>该需求具有一定的普遍性，基本上所有开发APP的团队都可能会用到，因此我将整个需求实现的过程整理后形成此文，并且真正地做到了<code>零基础上手，到手即飞、开箱即用</code>，希望能对大家有所帮助。</p>
<p>首先，先给大家展示下平台建设完成后的整体效果：</p>
<p><img src="/images/Jenkins_Job_Overview.jpg" alt="Overview of Jenkins Job"><br><img src="/images/Jenkins_Job_Build_View.jpg" alt="Build view of Jenkins Job"></p>
<p>该平台主要实现的功能有3点：</p>
<ul>
<li>定期对GitHub仓库进行检测，若有更新则自动执行构建打包；</li>
<li>构建成功后根据ipa/apk生成二维码，并可在历史构建列表中展示各个版本的二维码，通过手机扫描二维码可直接安装对应版本；</li>
<li>在构建结果页面中展示当次构建的成果物（Artifact，如<code>.ipa</code>、<code>.app</code>、<code>.apk</code>、<code>info.plist</code>等文件），供有需要的用户进行下载。</li>
</ul>
<p>接下来，本文就开始对平台建设的完整实现过程进行详细介绍。</p>
<h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><p>Jenkins依赖于Java运行环境，因此需要首先安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Java</a>。</p>
<p>安装Jenkins的方式有多种，可以运行对应系统类型的安装包，可以通过docker获取镜像，也可以直接运行<code>war</code>包。</p>
<p>我个人倾向于直接运行<code>war</code>包的形式，只需下载<code>jenkins.war</code>后，运行如下命令即可启动Jenkins。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup java -jar jenkins_located_path/jenkins.war --httpPort=88 &amp;</span><br></pre></td></tr></table></figure>

<p>如果不指定<code>httpPort</code>，Jenkins的默认端口为8080。</p>
<h2 id="Jenkins插件"><a href="#Jenkins插件" class="headerlink" title="Jenkins插件"></a>Jenkins插件</h2><p>Jenkins有非常多的插件，可以实现各种功能的扩展。</p>
<p>针对搭建的iOS/Android持续集成打包平台，我使用到了如下几个插件。</p>
<ul>
<li>GIT plugin</li>
<li>SSH Credentials Plugin</li>
<li>Git Changelog Plugin: 获取仓库提交的commit log</li>
<li>build-name-setter：用于修改Build名称</li>
<li>description setter plugin：用于在修改Build描述信息，在描述信息中增加显示QRCode（二维码）</li>
<li>Post-Build Script Plug-in：在编译完成后通过执行脚本实现一些额外功能</li>
<li>Xcode integration: iOS专用（可选）</li>
<li>Gradle plugin: Android专用（可选）</li>
</ul>
<p>安装方式也比较简单，直接在Jenkins的插件管理页面搜索上述插件，点击安装即可。</p>
<h2 id="创建项目（Job）"><a href="#创建项目（Job）" class="headerlink" title="创建项目（Job）"></a>创建项目（Job）</h2><p>在Jenkins中，构建项目以Job的形式存在，因此需要针对每个项目创建一个Job。有时候，一个项目中可能有多个分支同时在进行开发，为了分别进行构建，也可以针对每个分支创建一个Job。</p>
<p>创建Job的方式有多种，本次只需要创建<code>Freestyle project</code>类型的即可。</p>
<blockquote>
<p><code>Main page</code> -&gt; <code>New Item</code> -&gt; <code>Freestyle project</code></p>
</blockquote>
<p>对于一个持续集成打包平台，每次打包都由4步组成：触发构建、拉取代码、执行构建、构建后处理。对应的，在每个Job中也对应了这几项的配置。</p>
<h2 id="配置Git代码仓库"><a href="#配置Git代码仓库" class="headerlink" title="配置Git代码仓库"></a>配置Git代码仓库</h2><p>要对项目进行构建，配置项目的代码仓库是必不可少的。由于当前我们的项目托管在GitHub私有仓库中，因此在此需要对<code>Git</code>进行配置。</p>
<p>在<code>【Source Code Management】</code>配置栏目下，如果之前<code>GIT plugin</code>安装成功，则会出现<code>Git</code>选项。</p>
<p>配置Git代码仓库时，有三项是必须配置的：仓库URL地址（<code>Repository URL</code>）、仓库权限校验方式（<code>Credentials</code>），以及当前Job需要构建的代码分支（<code>Branches to build</code>）。</p>
<p>在配置<code>Repository URL</code>时，选择<code>HTTPS URL</code>或<code>SSH URL</code>均可。不过需要注意的是，<code>Credentials</code>要和<code>Repository URL</code>对应，也就是说：</p>
<ul>
<li>如果<code>Repository URL</code>是<code>HTTPS URL</code>形式的，那么<code>Credentials</code>就要采用GitHub用户名密码的校验方式；而且，如果在GitHub中开启了<code>2FA（two-factor authentication）</code>，那么还需要在GitHub中创建一个<code>Personal access token</code>，输入密码时将这个<code>Personal access token</code>作为密码进行输入。</li>
<li>如果<code>Repository URL</code>是<code>SSH URL</code>形式的，那么就需要先在Jenkins所在的服务器上创建一个<code>SSH</code>秘钥对，并将公钥添加到GitHub的<code>SSH keys</code>中，然后在填写<code>Credentials</code>时，选择<code>SSH Username with private key</code>的校验方式，填入GitHub Username、SSH私钥、以及创建<code>SSH</code>秘钥对时设置的<code>Passphrase</code>。</li>
</ul>
<p>如果对Git权限校验的概念还比较模糊，可以参考<a href="/post/head-first-git-authority-verification">《深入浅出Git权限校验》</a>。</p>
<p>在配置<code>Branches to build</code>时，可以采用多种形式，包括分支名称（<code>branchName</code>）、<code>tagName</code>、<code>commitId</code>等。其中分支名称的形式用的最多，例如，若是构建<code>master</code>分支，则填写<code>refs/heads/master</code>，若是构建<code>develop</code>分支，则填写<code>refs/heads/develop</code>。</p>
<p>除了以上关于Git的必填配置项，有时根据项目的实际情况，可能还需要对Jenkins的默认配置项进行修改。</p>
<p>比较常见的一种情况就是对<code>clone</code>的配置进行修改。</p>
<p>在Jenkins的默认配置中，<code>clone</code>代码时会拉取所有历史版本的代码，而且默认的超时时限只有10分钟。这就造成在某些项目中，由于代码量本身就比较大，历史版本也比较多，再加上网络环境不是特别好，Jenkins根本没法在10分钟之内拉取完所有代码，超时后任务就会被自动终止了（错误状态码143）。</p>
<p>这种问题的解决方式也很简单，无非就是两种思路，要么少拉取点代码（不获取历史版本），要么提高超时时限。对应的配置在<code>Advanced clone behaviours</code>中：</p>
<ul>
<li><code>Shallow clone</code>：勾选后不获取历史版本；</li>
<li><code>Timeout (in minutes) for clone and fetch operation</code>：配置后覆盖默认的超时时限。</li>
</ul>
<h2 id="配置构建触发器"><a href="#配置构建触发器" class="headerlink" title="配置构建触发器"></a>配置构建触发器</h2><p>代码仓库配置好了，意味着Jenkins具有了访问GitHub代码仓库的权限，可以成功地拉取代码。</p>
<p>那Jenkins什么时候执行构建呢？</p>
<p>这就需要配置构建触发策略，即构建触发器，配置项位于<code>【Build Triggers】</code>栏目。</p>
<p>触发器支持多种类型，常用的有：</p>
<ul>
<li>定期进行构建（Build periodically）</li>
<li>根据提交进行构建（Build when a change is pushed to GitHub）</li>
<li>定期检测代码更新，如有更新则进行构建（Poll SCM）</li>
</ul>
<p>构建触发器的选择为复合选项，若选择多种类型，则任一类型满足构建条件时就会执行构建工作。如果所有类型都不选择，则该<code>Jenkins Job</code>不执行自动构建，但可通过手动点击<code>【Build Now】</code>触发构建。</p>
<p>关于定时器（Schedule）的格式，简述如下：</p>
<p><code>MINUTE HOUR DOM MONTH DOW</code></p>
<ul>
<li>MINUTE: Minutes within the hour (0-59)</li>
<li>HOUR: The hour of the day (0-23)</li>
<li>DOM: The day of the month (1-31)</li>
<li>MONTH: The month (1-12)</li>
<li>DOW: The day of the week (0-7) where 0 and 7 are Sunday.</li>
</ul>
<p>通常情况下需要指定多个值，这时可以采用如下operator（优先级从上到下）：</p>
<ul>
<li><code>*</code>适配所有有效的值，若不指定某一项，则以<code>*</code>占位；</li>
<li><code>M-N</code>适配值域范围，例如7-9代表7/8/9均满足；</li>
<li><code>M-N/X</code>或<code>*/X</code>：以X作为间隔；</li>
<li><code>A,B,C</code>：枚举多个值。</li>
</ul>
<p>另外，为了避免多个任务在同一时刻同时触发构建，在指定时间段时可以配合使用<code>H</code>字符。添加<code>H</code>字符后，Jenkins会在指定时间段内随机选择一个时间点作为起始时刻，然后加上设定的时间间隔，计算得到后续的时间点。直到下一个周期时，Jenkins又会重新随机选择一个时间点作为起始时刻，依次类推。</p>
<p>为了便于理解，列举几个示例：</p>
<ul>
<li><code>H/15 * * * *</code>：代表每隔15分钟，并且开始时间不确定，这个小时可能是<code>:07,:22,:37,:52</code>，下一个小时就可能是<code>:03,:18,:33,:48</code>；</li>
<li><code>H(0-29)/10 * * * *</code>：代表前半小时内每隔10分钟，并且开始时间不确定，这个小时可能是<code>:04,:14,:24</code>，下一个小时就可能是<code>:09,:19,:29</code>；</li>
<li><code>H 23 * * 1-5</code>：工作日每晚23:00至23:59之间的某一时刻；</li>
</ul>
<h2 id="配置构建方式"><a href="#配置构建方式" class="headerlink" title="配置构建方式"></a>配置构建方式</h2><p>触发策略配置好之后，Jenkins就会按照设定的策略自动执行构建。但如何执行构建操作，这还需要我们通过配置构建方式来进行设定。</p>
<p>常用的构建方式是根据构建对象的具体类型，安装对应的插件，然后采用相应的构建方式。例如，若是构建<code>Android</code>应用，安装<code>Gradle plugin</code>之后，就可以选择<code>Invoke Gradle script</code>，然后采用<code>Gradle</code>进行构建；若是构建<code>iOS</code>应用，安装<code>Xcode integration</code>插件之后，就可以选择<code>Xcode</code>，然后选择<code>Xcode</code>进行构建。</p>
<p>该种方式的优势是操作简单，UI可视化，在场景不复杂的情况下可以快速满足需求。不过缺点就是依赖于插件已有的功能，如果场景较复杂时可能单个插件还无法满足需求，需要再安装其它插件。而且，有些插件可能还存在一些问题，例如对某些操作系统版本或XCode版本兼容不佳，出现问题时我们就会比较被动。</p>
<p>我个人更倾向于另外一种方式，就是自己编写打包脚本，在脚本中自定义实现所有的构建功能，然后在<code>Execute Shell</code>中执行。这种方式的灵活度更高，各种场景的构建需求都能满足，出现问题后也能自行快速修复。</p>
<p>另外，对于iOS应用的构建，还有一个需要额外关注的点，就是开发者证书的配置。</p>
<p>如果是采用<code>Xcode integration</code>插件进行构建，配置会比较复杂，需要在Jenkins中导入开发证书，并填写多个配置项。不过，如果是采用打包脚本进行构建的话，情况就会简单许多。只要在Jenkins所运行的计算机中安装好开发者证书，打包命令在Shell中能正常工作，那么在Jenkins中执行打包脚本也不会有什么问题。</p>
<h2 id="构建后处理"><a href="#构建后处理" class="headerlink" title="构建后处理"></a>构建后处理</h2><p>完成构建后，生成的编译成果物（ipa/apk）会位于指定的目录中。但是，如果要直接在手机中安装<code>ipa/apk</code>文件还比较麻烦，不仅在分发测试包时需要将好几十兆的安装包进行传送，体验用户在安装时也还需要通过数据线将手机与计算机进行连接，然后再使用PP助手或豌豆荚等工具进行安装。</p>
<p>当前比较优雅的一种方式是借助<code>蒲公英（pgyer）</code>或<code>fir.im</code>等平台，将<code>ipa/apk</code>文件上传至平台后由平台生成二维码，然后只需要对二维码链接进行分发，体验用户通过手机扫描二维码后即可实现快速安装，效率得到了极大的提升。</p>
<h3 id="上传安装包文件，生成二维码"><a href="#上传安装包文件，生成二维码" class="headerlink" title="上传安装包文件，生成二维码"></a>上传安装包文件，生成二维码</h3><p>不管是<code>蒲公英</code>还是<code>fir.im</code>，都有对应的Jenkins插件，安装插件后可以在<code>Post-build</code>中实现对安装包的上传。</p>
<p>除了使用Jenkins插件，<code>fir.im</code>还支持命令上传的方式，<code>蒲公英</code>还支持<code>HTTP Post</code>接口上传的方式。</p>
<p>我个人推荐采用命令或接口上传的方法，并在构建脚本中进行调用。灵活是一方面，更大的好处是如果上传失败后还能进行重试，这在网络环境不是很稳定的情况下极其必要。</p>
<p>Jenkins成功完成安装包上传后，<code>pgyer/fir.im</code>平台会生成一个二维码图片，并在响应中将图片的URL链接地址进行返回。</p>
<h3 id="展示二维码图片"><a href="#展示二维码图片" class="headerlink" title="展示二维码图片"></a>展示二维码图片</h3><p>二维码图片的URL链接有了，那要怎样才能将二维码图片展示在Jenkins项目的历史构建列表中呢？</p>
<p>这里需要用到另外一个插件，<code>description setter plugin</code>。安装该插件后，在<code>【Post-build Actions】</code>栏目中会多出<code>description setter</code>功能，可以实现构建完成后设置当次build的描述信息。这个描述信息不仅会显示在build页面中，同时也会显示在历史构建列表中。</p>
<p>有了这个前提，要将二维码图片展示在历史构建列表中貌似就可以实现了，能直观想到的方式就是采用<code>HTML</code>的<code>img</code>标签，将<code>&lt;img src=&#39;qr_code_url&#39;&gt;</code>写入到build描述信息中。</p>
<p>这个方法的思路是正确的，不过这么做以后并不会实现我们预期的效果。</p>
<p>这是因为Jenkins出于安全的考虑，所有描述信息的<code>Markup Formatter</code>默认都是采用<code>Plain text</code>模式，在这种模式下是不会对build描述信息中的HTML编码进行解析的。</p>
<p>要改变也很容易，<code>Manage Jenkins</code> -&gt; <code>Configure Global Security</code>，将<code>Markup Formatter</code>的设置更改为<code>Safe HTML</code>即可。</p>
<p>更改配置后，我们就可以在build描述信息中采用<code>HTML</code>的<code>img</code>标签插入图片了。</p>
<p>另外还需要补充一个点。如果是使用<code>蒲公英（pyger）</code>平台，会发现每次上传安装包后返回的二维码图片是一个短链接，神奇的是这个短连接居然是固定的（对同一个账号而言）。这个短连接总是指向最近生成的二维码图片，但是对于二维码图片的唯一URL地址，平台并没有在响应中进行返回。在这种情况下，我们每次构建完成后保存二维码图片的URL链接就没有意义了。</p>
<p>应对的做法是，每次上传完安装包后，通过返回的二维码图片短链接将二维码图片下载并保存到本地，然后在build描述信息中引用该图片在Jenkins中的地址即可。</p>
<h3 id="收集编译成果物（Artifacts）"><a href="#收集编译成果物（Artifacts）" class="headerlink" title="收集编译成果物（Artifacts）"></a>收集编译成果物（Artifacts）</h3><p>每次完成构建后，编译生成的文件较多，但是并不是所有的文件都是我们需要的。</p>
<p>通常情况下，我们可能只需要其中的部分文件，例如<code>.ipa/.app/.plist/.apk</code>等，这时我们可以将这部分文件单独收集起来，并在构建页面中展示出来，以便在需要时进行下载。</p>
<p>要实现这样一个功能，需要在<code>【Post-build Actions】</code>栏目中新增<code>Archive the artifacts</code>，然后在<code>Files to archive</code>中通过正则表达式指定成果物文件的路径。</p>
<p>设置完毕后，每次构建完成后，Jenkins会在<code>Console Output</code>中采用设定的正则表达式进行搜索匹配，如果能成功匹配到文件，则会将文件收集起来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是对如何使用Jenkins搭建iOS/Android持续集成打包平台的基础概念和实施流程进行了介绍。对于其中涉及到的执行命令、构建脚本（build.py），以及Jenkins的详细配置，出于篇幅长度和阅读体验的考虑，并没有在文中进行详细展开。</p>
<p>为了实现真正的<code>开箱即用</code>，我将Jenkins的配置文件和构建脚本抽离出来形成一套模板，只需要导入到Jenkins中，然后针对具体的项目修改少量配置信息，即可将这一套持续集成打包平台运行起来，实现和文章开头插图中完全相同的功能效果。</p>
<p>详细内容请阅读<a href="/post/iOS-Android-Packing-with-Jenkins-details">《关于持续集成打包平台的Jenkins配置和构建脚本实现细节》</a>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/head-first-git-authority-verification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/head-first-git-authority-verification/" class="post-title-link" itemprop="url">深入浅出 Git 权限校验</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-15T00:00:00+08:00">2016-06-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/" itemprop="url" rel="index"><span itemprop="name">4. ToolsNotes</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>借助上次“掉坑”的经历，我对Git权限校验的两种方式重头进行了梳理，形成了这篇总结记录。</p>
<p>在本地计算机与GitHub（或GitLab）进行通信时，传输主要基于两种协议，<code>HTTPS</code>和<code>SSH</code>，对应的仓库地址就是<code>HTTPS URLs</code>和<code>SSH URLs</code>。</p>
<p>首先需要强调的是，<code>HTTPS URLs</code>和<code>SSH URLs</code>对应的是两套完全独立的权限校验方式，主要的区别就是<code>HTTPS URLs</code>采用账号密码进行校验，<code>SSH URLs</code>采用<code>SSH</code>秘钥对进行校验。平时使用的时候我们可以根据实际情况，选择一种即可。</p>
<h2 id="HTTPS-URLs"><a href="#HTTPS-URLs" class="headerlink" title="HTTPS URLs"></a>HTTPS URLs</h2><p>GitHub官方推荐采用<code>HTTPS URLs</code>的方式，因为该种方式适用面更广（即使在有防火墙或代理的情况下也同样适用），使用更方便（配置更简单）。</p>
<p>采用<code>HTTPS URLs</code>地址<code>clone</code>/<code>fetch</code>/<code>pull</code>/<code>push</code>仓库时，事先无需对本地系统进行任何配置，只需要输入GitHub的账号和密码即可。不过如果每次都要手动输入账号密码，也是一件很繁琐的事情。</p>
<p>好在已经有多个机制可以让操作不用这么麻烦。</p>
<p>在Mac系统中，在启用<code>Keychain</code>机制的情况下，首次输入GitHub账号密码后，认证信息就会自动保存到系统的<code>Keychain</code>中，下次再次访问仓库时就会自动读取<code>Keychain</code>中保存的认证信息。</p>
<p>在非Mac系统中，虽然没有<code>Keychain</code>机制，但是Git提供了<code>credential helper</code>机制，可以将账号密码以cache的形式在内存中缓存一段时间（默认15分钟），或者以文件的形式存储起来（<code>~/.git-credentials</code>）。当然，Mac系统如果不启用<code>Keychain</code>机制，也可以采用这种方式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cache credential in memory</span></span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"><span class="comment"># store credential in ~/.git-credential</span></span><br><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<p>在<code>credential.helper</code>设置为<code>store</code>的情况下，首次输入GitHub账号密码后，就会自动保存到<code>~/.git-credentials</code>文件中，保存形式为<code>https://user:pass@github.com</code>；下次再次访问仓库时就会自动读取<code>~/.git-credentials</code>中保存的认证信息。</p>
<p>另一个需要说明的情况是，如果在GitHub中开启了<code>2FA（two-factor authentication）</code>，那么在本地系统中输入GitHub账号密码时，不能输入原始的密码（即GitHub网站的登录密码），而是需要事先在GitHub网站中创建一个<code>Personal access token</code>，后续在访问代码仓库需要进行权限校验的时候，采用<code>access token</code>作为密码进行输入。</p>
<h2 id="SSH-URLs"><a href="#SSH-URLs" class="headerlink" title="SSH URLs"></a>SSH URLs</h2><p>除了<code>HTTPS URLs</code>，还可以采用<code>SSH URLs</code>的方式访问GitHub代码仓库。</p>
<p>采用<code>SSH URLs</code>方式之前，需要先在本地计算机中生成<code>SSH keypair</code>（秘钥对，包括私钥和公钥）。默认情况下，生成的秘钥位于<code>$HOME/.ssh/</code>目录中，文件名称分别为<code>id_rsa</code>和<code>id_rsa.pub</code>，通常无需修改，保持默认即可。不过，如果一台计算机中存在多个秘钥对，就需要修改秘钥文件名，名称没有强制的命名规范，便于自己辨识即可。</p>
<p>如下是创建秘钥对的过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh-keygen -t rsa -b 4096 -C <span class="string">"mail@debugtalk.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/Leo/.ssh/id_rsa): /Users/Leo/.ssh/debugtalk_id_rsa</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): &lt;myPassphrase&gt;</span><br><span class="line">Enter same passphrase again: &lt;myPassphrase&gt;</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/Leo/.ssh/debugtalk_id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/Leo/.ssh/debugtalk_id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:jCyEEKjlCU1klROnuBg+UH08GJ1u252rQMADdD9kYMo mail@debugtalk.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 4096]----+</span></span><br><span class="line"><span class="string">|+*BoBO+.         |</span></span><br><span class="line"><span class="string">|o=oO=**          |</span></span><br><span class="line"><span class="string">|++E.*+o.         |</span></span><br><span class="line"><span class="string">|+ooo +o+         |</span></span><br><span class="line"><span class="string">|.o. ..+oS. .     |</span></span><br><span class="line"><span class="string">|  .  o. . o      |</span></span><br><span class="line"><span class="string">|      .    .     |</span></span><br><span class="line"><span class="string">|       .  .      |</span></span><br><span class="line"><span class="string">|        ..       |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>

<p>在创建秘钥的过程中，系统还建议创建一个名为<code>passphrase</code>的东西，这是用来干嘛的呢？</p>
<blockquote>
<p>首先，单独采用密码肯定是不够安全的。如果密码太简单，那么就很容易被暴力破解，如果密码太复杂，那么用户就很难记忆，记录到小本子里面更不安全。</p>
</blockquote>
<blockquote>
<p>因此，<code>SSH keys</code>诞生了。<code>SSH</code>秘钥对的可靠性非常高，被暴力破解的可能性基本没有。不过，这要求用户非常谨慎地保管好私钥，如果别人使用你的计算机时偷偷地将你的私钥拷走了，那么就好比是别人拿到了你家里的钥匙，也能随时打开你家的门。</p>
</blockquote>
<blockquote>
<p>基于以上情况，解决办法就是在<code>SSH keys</code>之外再增加一个密码，即<code>passphrase</code>。只有同时具备<code>SSH private key</code>和<code>passphrase</code>的情况下，才能通过<code>SSH</code>的权限校验，这就大大地增加了安全性。当然，这个<code>passphrase</code>也不是必须的，在创建秘钥对时也可以不设置<code>passphrase</code>。</p>
</blockquote>
<blockquote>
<p>另外，如果每次权限校验时都要输入<code>passphrase</code>，这也是挺麻烦的。好在我们不用再担心这个问题，因为<code>ssh-agent</code>可以帮我们记住<code>passphrase</code>，Mac系统的Keychain也可以记住<code>passphrase</code>，这样我们在同一台计算机中就不用重新输入密码了。</p>
</blockquote>
<p>秘钥对创建好以后，私钥存放于本地计算机（<code>~/.ssh/id_rsa</code>），将公钥（<code>~/.ssh/id_rsa.pub</code>）中的内容添加至GitHub账户。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy the contents of id_rsa.pub to the clipboard</span></span><br><span class="line">➜ pbcopy &lt; ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># paste to GitHub</span></span><br><span class="line"><span class="comment"># Login GitHub, 【Settings】-&gt;【SSH and GPG keys】-&gt;【New SSH Key】</span></span><br></pre></td></tr></table></figure>

<p>不过，如果此时检测本地计算机与GitHub的连接状态，会发现系统仍提示权限校验失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh -T git@github.com</span><br><span class="line">Permission denied (publickey).</span><br></pre></td></tr></table></figure>

<p>这是因为在本地计算机与GitHub建立连接的时候，实际上是本机计算机的<code>ssh-agent</code>与GitHub服务器进行通信。虽然本地计算机有了私钥，但是<code>ssh-agent</code>并不知道私钥存储在哪儿。因此，要想正常使用秘钥对，需要先将私钥加入到本地计算机的<code>ssh-agent</code>中（添加过程中需要输入<code>passphrase</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start ssh-agent in the background</span></span><br><span class="line">➜ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">Agent pid 78370</span><br><span class="line"></span><br><span class="line">➜ ssh-add ~/.ssh/id_rsa</span><br><span class="line">Enter passphrase <span class="keyword">for</span> /Users/Leo/.ssh/id_rsa: &lt;myPassphrase&gt;</span><br><span class="line">Identity added: /Users/Leo/.ssh/id_rsa (/Users/Leo/.ssh/id_rsa)</span><br></pre></td></tr></table></figure>

<p>添加完成后，就可以查看到当前计算机中存储的密钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh-add -l</span><br><span class="line">4096 SHA256:xRg49AgTxxxxxxxx8q2SPPOfxxxxxxxxRlBY /Users/Leo/.ssh/id_rsa (RSA)</span><br></pre></td></tr></table></figure>

<p>再次检测本地计算机与GitHub的连接状态，校验就正常通过了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh -T git@github.com</span><br><span class="line">Hi leolee! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<p>后续再进行<code>clone</code>/<code>fetch</code>/<code>pull</code>/<code>push</code>操作时，就可以正常访问GitHub代码仓库了，并且也不需要再重新输入账号密码。</p>
<p>而且，将私钥加入<code>ssh-agent</code>后，即使删除私钥文件，本地计算机仍可以正常访问GitHub代码仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ rm -rf ~/.ssh</span><br><span class="line">➜ ssh-add -l</span><br><span class="line">4096 SHA256:xRg49AgTxxxxxxxx8q2SPPOfxxxxxxxxRlBY /Users/Leo/.ssh/id_rsa (RSA)</span><br><span class="line">➜ ssh -T git@github.com</span><br><span class="line">The authenticity of host <span class="string">'github.com (192.30.252.130)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>github.com,192.30.252.130<span class="string">' (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Hi leolee! You'</span>ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>只有执行<code>ssh-add -D</code>或<code>ssh-add -d pub_key</code>命令，将私钥从<code>ssh-agent</code>删除后，认证信息才会失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh-add -d ~/.ssh/id_rsa.pub</span><br><span class="line">Identity removed: /Users/Leo/.ssh/id_rsa.pub (mail@debugtalk.com)</span><br><span class="line">➜ ssh-add -l</span><br><span class="line">The agent has no identities.</span><br><span class="line">➜ ssh -T git@github.com</span><br><span class="line">Permission denied (publickey).</span><br></pre></td></tr></table></figure>

<h2 id="同时使用多个GitHub账号"><a href="#同时使用多个GitHub账号" class="headerlink" title="同时使用多个GitHub账号"></a>同时使用多个GitHub账号</h2><p>熟悉了<code>HTTPS URLs</code>和<code>SSH URLs</code>这两种校验方式之后，我们再来看之前遇到的问题。要想在一台计算机上同时使用多个GitHub账号访问不同的仓库，需要怎么做呢？</p>
<p>为了更好地演示，现假设有两个GitHub账号，<code>debugtalk</code>和<code>leolee</code>，在两个账号中各自有一个仓库，<code>debugtalk/DroidMeter</code>和<code>DebugTalk/MobileStore</code>（公司私有库）。</p>
<p>前面已经说过，<code>HTTPS URLs</code>和<code>SSH URLs</code>对应着两套独立的权限校验方式，因此这两套方式应该是都能单独实现我们的需求的。</p>
<p>不过在详细讲解Git权限校验的问题之前，我们先来回顾下Git配置文件的优先级。</p>
<h3 id="Git配置存储位置及其优先级"><a href="#Git配置存储位置及其优先级" class="headerlink" title="Git配置存储位置及其优先级"></a>Git配置存储位置及其优先级</h3><p><code>Unix-like</code>系统中，保存Git用户信息的主要有3个地方（Mac系统多一个<code>Keychain</code>）：</p>
<ul>
<li><code>/etc/gitconfig</code>：存储当前系统所有用户的git配置信息，使用带有<code>--system</code>选项的<code>git config</code>时，配置信息会写入该文件；</li>
<li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>：存储当前用户的git配置信息，使用带有<code>--global</code>选项的<code>git config</code>时，配置信息会写入该文件；</li>
<li><code>Keychain Access</code>：在开启<code>Keychain</code>机制的情况下，进行权限校验后会自动将账号密码保存至<code>Keychain Access</code>。</li>
<li>仓库的Git目录中的config文件（即<code>repo/.git/config</code>）：存储当前仓库的git配置信息，在仓库中使用带有<code>--local</code>选项的<code>git config</code>时，配置信息会写入该文件；</li>
</ul>
<p>在优先级方面，以上4个配置项的优先级从上往下依次上升，即<code>repo/.git/config</code>的优先级最高，然后<code>Keychain Access</code>会覆盖<code>~/.gitconfig</code>中的配置，<code>~/.gitconfig</code>会覆盖<code>/etc/gitconfig</code>中的配置。</p>
<h3 id="基于SSH协议实现多账号共存"><a href="#基于SSH协议实现多账号共存" class="headerlink" title="基于SSH协议实现多账号共存"></a>基于<code>SSH</code>协议实现多账号共存</h3><p>先来看下如何采用<code>SSH URLs</code>实现我们的需求。</p>
<p>在处理多账号共存问题之前，两个账号均已分别创建<code>SSH</code>秘钥对，并且<code>SSH-key</code>均已加入本地计算机的<code>ssh-agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh-add -l</span><br><span class="line">4096 SHA256:lqujbjkWM1xxxxxxxxxxG6ERK6DNYj9tXExxxxxx8ew /Users/Leo/.ssh/debugtalk_id_rsa (RSA)</span><br><span class="line">4096 SHA256:II2O9vZutdQr8xxxxxxxxxxD7EYvxxxxxxbynx2hHtg /Users/Leo/.ssh/id_rsa (RSA)</span><br></pre></td></tr></table></figure>

<p>在详细讲解多账号共存的问题之前，我们先来回想下平时在Terminal中与GitHub仓库进行交互的场景。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  DroidMeter git:(master) git pull</span><br><span class="line">Already up-to-date.</span><br><span class="line">➜  DroidMeter git:(master) touch README.md</span><br><span class="line">➜  DroidMeter git:(master) ✗ git add .</span><br><span class="line">➜  DroidMeter git:(master) ✗ git commit -m <span class="string">"add README"</span></span><br><span class="line">➜  DroidMeter git:(master) git push</span><br><span class="line">Counting objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 310 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@debugtalk:debugtalk/DroidMeter.git</span><br><span class="line">   7df6839..68d085b  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>在操作过程中，本地计算机的<code>ssh-agent</code>与GitHub服务器建立了连接，并进行了账号权限校验。</p>
<p>当本地计算机只有一个GitHub账号时，这个行为并不难理解，系统应该会采用这个唯一的GitHub账号进行操作。那如果本地计算机中有多个Github账号时，系统是根据什么来判断应该选择哪个账号呢？</p>
<p>实际情况是，系统没法进行判断。系统只会有一个默认的账号，然后采用这个默认的账号去操作所有的代码仓库，当账号与仓库不匹配时，就会报权限校验失败的错误。</p>
<p>那要怎样才能让系统正确区分账号呢？这就需要我们手动进行配置，配置文件即是<code>~/.ssh/config</code>。</p>
<p>创建<code>~/.ssh/config</code>文件，在其中填写如下内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debugtalk</span></span><br><span class="line">Host debugtalk</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># DT</span></span><br><span class="line">Host leolee</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/dt_id_rsa</span><br></pre></td></tr></table></figure>

<p>要理解以上配置文件的含义并不难，我们可以对比看下两个项目的<code>SSH URLs</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git@github.com:debugtalk/DroidMeter.git</span><br><span class="line">git@github.com:DTSZ/Store_Android.git</span><br></pre></td></tr></table></figure>

<p>其中，<code>git</code>是本地<code>ssh-agent</code>与GitHub服务器建立<code>SSH</code>连接采用的用户名（即<code>User</code>），<code>github.com</code>是GitHub服务器的主机（即<code>HostName</code>）。</p>
<p>可以看出，如果采用原始的<code>SSH URLs</code>，由于<code>User</code>和<code>HostName</code>都相同，本地计算机并不知道应该采用哪个<code>SSH-key</code>去建立连接。</p>
<p>因此，通过创建<code>~/.ssh/config</code>文件，在<code>Host</code>中进行区分，然后经过<code>CNAME</code>映射到<code>HostName</code>，然后分别指向不同的<code>SSH-key</code>，即<code>IdentityFile</code>。由于<code>HostName</code>才是真正指定GitHub服务器主机的字段，因此这么配置不会对本地<code>ssh-agent</code>连接GitHub主机产生影响，再加上<code>Host</code>别名指向了不同的<code>SSH-key</code>，从而实现了对两个GitHub账号的分离。</p>
<p>配置完毕后，两个GitHub账号就可以通过<code>Host</code>别名来进行区分了。后续再与GitHub服务器进行通信时，就可以采用<code>Host</code>别名代替原先的<code>github.com</code>。例如，测试本地<code>ssh-agent</code>与GitHub服务器的连通性时，可采用如下方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ ssh -T git@debugtalk</span><br><span class="line">Hi debugtalk! You have successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">➜ ssh -T git@leolee</span><br><span class="line">Hi leolee! You have successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>可以看出，此时两个账号各司其职，不会再出现混淆的情况。</p>
<p>不过，我们还遗漏了很重要的一点。在本地代码仓库中执行<code>push</code>/<code>pull</code>/<code>fetch</code>等操作的时候，命令中并不会包含<code>Host</code>信息，那系统怎么知道我们要采用哪个GitHub账号进行操作呢？</p>
<p>答案是，系统还是没法判断，需要我们进行配置指定。</p>
<p>显然，不同的仓库可能对应着不同的GitHub账号，因此这个配置不能配置成全局的，而只能在各个项目中分别进行配置，即<code>repo/.git/config</code>文件。</p>
<p>配置的方式如下：</p>
<p>在<code>debugtalk/DroidMeter</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git remote add origin git@debugtalk:debugtalk/DroidMeter.git</span><br></pre></td></tr></table></figure>

<p>在<code>DebugTalk/MobileStore.git</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git remote add origin git@leolee:DebugTalk/MobileStore.git</span><br></pre></td></tr></table></figure>

<p>配置的原理也很容易理解，就是将仓库的<code>Host</code>更换为之前设置的别名。添加完毕后，后续再在两个仓库中执行任何<code>git</code>操作时，系统就可以选择正确的<code>SSH-key</code>与GitHub服务器进行交互了。</p>
<h3 id="基于HTTPS协议实现多账号共存"><a href="#基于HTTPS协议实现多账号共存" class="headerlink" title="基于HTTPS协议实现多账号共存"></a>基于<code>HTTPS</code>协议实现多账号共存</h3><p>再来看下如何采用<code>HTTPS URLs</code>实现我们的需求。</p>
<p>有了前面的经验，我们的思路就清晰了许多。采用<code>HTTPS URLs</code>的方式进行Git权限校验后，系统会将GitHub账号密码存储到<code>Keychain</code>中（Mac系统），或者存储到<code>~/.git-credentials</code>文件中（<code>Git credential helper</code>）。</p>
<p>不管是存储到哪里，我们面临的问题都是相同的，即如何在代码仓库中区分采用哪个GitHub账号。</p>
<p>配置的方式其实也很简单：</p>
<p>在<code>debugtalk/DroidMeter</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git remote add origin https://debugtalk@github.com/debugtalk/DroidMeter.git</span><br></pre></td></tr></table></figure>

<p>在<code>DebugTalk/MobileStore.git</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git remote add origin https://leolee@github.com/DebugTalk/MobileStore.git</span><br></pre></td></tr></table></figure>

<p>配置的原理也很容易理解，将GitHub用户名添加到仓库的Git地址中，这样在执行git命令的时候，系统就会采用指定的GitHub用户名去<code>Keychain</code>或<code>~/.git-credentials</code>中寻找对应的认证信息，账号使用错乱的问题也就不复存在了。</p>
<p><code>Done!</code></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/trap-in-GitHub-authority-verification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/trap-in-GitHub-authority-verification/" class="post-title-link" itemprop="url">GitHub 权限校验失败给我的启发</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-14 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-14T00:00:00+08:00">2016-06-14</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/" itemprop="url" rel="index"><span itemprop="name">4. ToolsNotes</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>众所周知，在GitHub中，每个仓库都有两个地址，分别基于<code>HTTPS</code>协议和<code>SSH</code>协议，两个协议对应的URL地址（repository_url）形式如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTPS</span></span><br><span class="line">https://github.com/XY/MobileStore.git</span><br><span class="line"><span class="comment"># SSH</span></span><br><span class="line">git@github.com:XY/MobileStore.git</span><br></pre></td></tr></table></figure>

<p>正常情况下，只要在本地正确地配置好了<code>git</code>账号，采用这两个地址中的任意一个，都可以通过<code>git clone repository_url</code>获取代码。</p>
<p>但最近我在Macbook Air中<code>clone</code>公司托管在GitHub私有库中的代码时，发现无法通过<code>HTTPS</code>协议的地址<code>clone</code>代码，始终提示<code>remote: Repository not found.</code>的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="built_in">clone</span> https://github.com/XY/MobileStore.git</span><br><span class="line">Cloning into <span class="string">'MobileStore'</span>...</span><br><span class="line">remote: Repository not found.</span><br><span class="line">fatal: repository <span class="string">'https://github.com/XY/MobileStore.git/'</span> not found</span><br></pre></td></tr></table></figure>

<p>首先，这个代码仓库是确实存在的，而且地址肯定也是没有问题的，通过URL地址也能在浏览器中访问到对应的GitHub仓库页面。</p>
<p>其次，在本地对<code>git</code>的配置也是没有问题的，通过<code>SSH</code>协议的地址是可以正常<code>clone</code>代码的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="built_in">clone</span> git@github.com:XY/MobileStore.git</span><br><span class="line">Cloning into <span class="string">'MobileStore'</span>...</span><br><span class="line">Warning: Permanently added the RSA host key <span class="keyword">for</span> IP address <span class="string">'192.30.252.131'</span> to the list of known hosts.</span><br><span class="line">remote: Counting objects: 355, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>并且，如果在<code>HTTPS</code>协议的URL地址中加上GitHub账号，也是可以正常<code>clone</code>代码的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ git <span class="built_in">clone</span> https://leolee@github.com/XY/MobileStore.git</span><br><span class="line">Cloning into <span class="string">'MobileStore'</span>...</span><br><span class="line">remote: Counting objects: 355, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (3/3), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>更奇怪的是，在我的另一台Mac Mini中，采用同样的账号配置，两种协议的URL地址却都能正常<code>clone</code>代码，仔细地对比了两台电脑的<code>git</code>配置，都是一样的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜ cat ~/.git-credentials</span><br><span class="line">https://leolee:340d247cxxxxxxxxf39556e38fe2b0baxxxxxxxx@github.com</span><br><span class="line">➜</span><br><span class="line">➜ cat ~/.gitconfig</span><br><span class="line">[credential]</span><br><span class="line">truehelper = store</span><br></pre></td></tr></table></figure>

<p>那问题出在哪儿呢？</p>
<h2 id="定位分析"><a href="#定位分析" class="headerlink" title="定位分析"></a>定位分析</h2><p>通过Google得知，产生<code>remote: Repository not found.</code>报错的原因主要有两个，一是仓库地址错误，二是权限校验不通过。显然，第一个原因可以直接排除，在Macbook Air中出现该问题应该就是账号权限校验失败造成的。</p>
<p>对背景描述中的现象进行整理，重点关注两个疑点：</p>
<ul>
<li>通过<code>HTTPS</code>协议的URL地址进行<code>git clone</code>时，系统没有提示让输入用户名密码，就直接返回权限校验失败的异常；</li>
<li>在<code>HTTPS</code>协议的URL地址中加上GitHub用户名，就可以正常<code>clone</code>，而且，系统也没有提示输入密码。</li>
</ul>
<p>这说明，在系统中的某个地方，应该是保存了GitHub账号密码的，所以在未指定账号的情况下，<code>git clone</code>时系统就不再要求用户输入账号密码，而是直接读取那个保存好的账号信息；但是，那个保存的GitHub账号密码应该是存在问题的，这就造成采用那个账号信息去GitHub校验时无法通过，从而返回异常报错。</p>
<p>基于以上推测，寻找问题根源的当务之急是找到保存GitHub账号密码的地方。</p>
<p>通过查看Git官方文档，存储Git用户信息的地方有三个：</p>
<ul>
<li><code>/etc/gitconfig</code>：存储当前系统所有用户的git配置信息；</li>
<li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>：存储当前用户的git配置信息；</li>
<li>仓库的Git目录中的config文件（即<code>repo/.git/config</code>）：存储当前仓库的git配置信息。</li>
</ul>
<p>这三个配置项的优先级从上往下依次上升，即<code>repo/.git/config</code>会覆盖<code>~/.gitconfig</code>中的配置，<code>~/.gitconfig</code>会覆盖<code>/etc/gitconfig</code>中的配置。</p>
<p>回到当前问题，由于还没有进入到具体的Git仓库，因此<code>repo/.git/config</code>可直接排除；然后是查看当前用户的git配置，在当前用户HOME目录下没有<code>~/.config/git/config</code>文件，只有<code>~/.gitconfig</code>，不过在<code>~/.gitconfig</code>中并没有账号信息；再去查看系统级的git配置信息，即<code>/etc/gitconfig</code>文件，但发现当前系统中并没有该文件。</p>
<p>找遍了Git用户信息可能存储的地方，都没有看到账号配置信息，那还可能存储在哪儿呢？</p>
<p>这时基本上是毫无思路了，只能靠各种胡乱猜测，甚至尝试采用Wireshark分别在两台Mac上对<code>git clone</code>的过程进行抓包，对比通讯数据的差异，但都没有找到答案。</p>
<p>最后，无意中想到了Mac的<code>Keychain</code>机制。在Mac OSX的<code>Keychain</code>中，可以保存用户的账号密码等<code>credentials</code>，那git账号会不会也保存到<code>Keychain</code>中了呢？</p>
<p>在Macbook Air中打开<code>Keychain Access</code>应用软件，搜索<code>github</code>，果然发现存在记录。</p>
<p><img src="/images/Mac_Keychain_GitHub.jpg" alt="Mac Keychain of GitHub"></p>
<p>而且，<code>github.com</code>这一项还存在两条记录。一条是我的个人账号<code>debugtalk</code>，另一条是公司的工作账号<code>leolee</code>。</p>
<p><strong>至此，真相大白！！！</strong></p>
<p>在我的Macbook Air中，<code>Keychain Access</code>中保存了我的GitHub个人账号（<code>debugtalk</code>），该账号是没有权限访问公司私有仓库的。但是在Terminal中执行<code>git clone</code>命令时，系统优先读取了我的个人账号，并用该账号向GitHub发起校验请求，从而造成读取公司私有仓库时权限校验失败。然而，在<code>HTTPS</code>协议的URL地址中加上GitHub工作账号（<code>leolee</code>）时，由于此时指定了账号名称，因此在<code>Keychain</code>中读取账号信息时就可以找到对应账号（包含密码），并且在无需输入密码的情况下就能成功通过GitHub的权限校验，进而成功<code>clone</code>得到代码。</p>
<p>原因弄清楚之后，解决方式就很简单了，在<code>Keychain</code>中删除个人账号，然后就正常了。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>但是，问题真的解决了么？</p>
<p>并没有！</p>
<p>简单粗暴地在Keychain中将个人GitHub账号删除了，虽然再次访问公司代码仓库时正常了，那我要再访问个人仓库时该怎么办呢？</p>
<p>貌似并没有清晰的思路。虽然网上也有不少操作指导教程，但是对于操作背后的原理，还是有很多不清晰的地方。</p>
<p>再回到前面的背景描述，以及定位问题的整个过程，不由地悲从中来。使用GitHub好歹也有好几年了，但是连最基本的概念都还一头雾水，所以遇到问题后只能靠瞎猜，东碰西撞，最后瞎猫碰到死耗子。</p>
<p>GitHub的<code>HTTPS</code>协议和<code>SSH</code>协议，这本来就对应着两套完全独立的权限校验方式，而我在<code>HTTPS</code>协议不正常的情况下还去查看<code>SSH</code>协议，这本来就实属多余。</p>
<p>借助这次“掉坑”的经历，我对<code>Git</code>权限校验的两种方式重头进行了梳理，并单独写了一篇博客，《深入浅出Git权限校验》，虽然花了些时间，但总算是扫清了萦绕多年的迷雾，感觉倍儿爽！</p>
<p>如果你也对<code>Git的权限校验</code>没有清晰的了解，遇到权限校验出错时只能“换一种方法试试”，也不知道怎么让一台计算机同时支持多个GitHub账号，那么也推荐看下那篇博客。</p>
<p>在微信公众号<code>debugtalk</code>中输入<code>Git权限校验</code>，获取《深入浅出Git权限校验》。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/promotion-page-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/promotion-page-test/" class="post-title-link" itemprop="url">关于促销活动页面测试的那些事儿</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-09T00:00:00+08:00">2016-06-09</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-Testing/" itemprop="url" rel="index"><span itemprop="name">3. Testing</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-Testing/功能测试/" itemprop="url" rel="index"><span itemprop="name">功能测试</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章来说说促销活动页面测试的那些事儿。</p>
<h2 id="什么是促销活动页面？"><a href="#什么是促销活动页面？" class="headerlink" title="什么是促销活动页面？"></a>什么是促销活动页面？</h2><p>通常电商平台在节假日会做一些促销活动，而活动的宣传方式，主要会采用H5静态页面的形式，也就是本文中要讲的促销活动页面。</p>
<p>这些活动页面的特点是元素构成很简单，在页面中只包含一些促销商品的图片及其价格，而且价格往往都是写死在页面中，不会涉及到从数据库中读取，完完全全的静态页面；当然，促销活动页面的目的是将用户流量导向电商平台，因此在页面的图片或购买按钮背后会配上URL链接，用户点击链接后会跳转至电商平台对应的购买页面，活动页面也就完成了使命，这往往就是活动页面的全部内容。</p>
<p>这么看来，促销活动页面跟街上发的传单非常相似，只是传单是纸质的，而活动页面是网页的罢了。</p>
<h2 id="促销活动页面为什么要这么做呢？"><a href="#促销活动页面为什么要这么做呢？" class="headerlink" title="促销活动页面为什么要这么做呢？"></a>促销活动页面为什么要这么做呢？</h2><p>四方面原因。</p>
<p>第一，促销活动页面的目的性很强，就是为了主推几款特价商品，因此，商品和价格完全写死也不会有任何问题。</p>
<p>第二，促销活动页面的时效性很强，为促销活动而生，生命周期就那么几天，促销活动结束后这个活动页面也就作废了，因此也不用考虑复用的问题。</p>
<p>第三，从投入的人力成本和工作量考虑，促销活动页面的制作只需要设计师和前端工程师就能完成，无需后台开发人员进行配合，也无需对当前的电商平台进行任何功能调整。</p>
<p>第四，电商平台在做促销活动时，往往会通过各种渠道进行推广，因此活动页面的访问流量是非常巨大的；而采用静态页面的形式，不仅可以极大地提高页面加载速度（图片等静态资源可以通过CDN存储），而且可以极大地减轻流量对电商平台服务器端的压力（用户在浏览活动页面的时候并不会与电商平台进行任何交互）。至于点击链接进入电商平台的流量嘛，毕竟转换率总是存在的，转换以后的流量会小很多，而这部分流量才是真正有效的。</p>
<h2 id="如何对活动页面进行测试"><a href="#如何对活动页面进行测试" class="headerlink" title="如何对活动页面进行测试"></a>如何对活动页面进行测试</h2><p>那么，就这么简单的一个静态页面，还需要对它进行测试么？</p>
<p>咋一看，貌似还真没有可测试的内容，因为页面中就找不到一个真正意义上的功能点。</p>
<p>然而，历史经验表明，在软件工程中无论多简单的功能，都是有可能出现bug的。针对活动页面的形式，我们需要重点关注如下几点。</p>
<h3 id="1、商品信息一致性"><a href="#1、商品信息一致性" class="headerlink" title="1、商品信息一致性"></a>1、商品信息一致性</h3><p>促销活动页面中的商品信息都是由前端工程师写死的，而非从电商平台的数据库中读取后进行展示。因此，在实际操作中，活动页面上的信息，特别是价格数据，有可能和电商平台中的商品不一致，这个是我们在测试的时候需要重点关注的。</p>
<p>测试方式很简单，依次点击各个商品的链接，验证跳转的商品页面是否与促销活动页面中的商品信息一致即可。</p>
<h3 id="2、页面跳转行为一致性"><a href="#2、页面跳转行为一致性" class="headerlink" title="2、页面跳转行为一致性"></a>2、页面跳转行为一致性</h3><p>点击链接跳转页面，应该算是活动页面中唯一具有动作行为的功能了。而对于链接跳转而言，会存在两种形式，一种是在当前页面中加载商品页面，另一种是在新窗口中加载商品页面。</p>
<p>本来两种形式区别并不大，采用哪种形式都可以，但是从追求完美的角度出发，我们还是需要保证活动页面中的所有链接的跳转行为都是相同的。</p>
<p>因此，在测试时，逐一点击所有的链接，验证所有链接跳转行为是否一致即可。</p>
<h3 id="3、页面兼容性"><a href="#3、页面兼容性" class="headerlink" title="3、页面兼容性"></a>3、页面兼容性</h3><p>作为促销活动页面，虽然商品信息是最核心的内容，但是为了能吸引尽量多的用户，页面的设计往往花了很多功夫，力求精美。然而，用户访问活动页面的设备和浏览器五花八门，有可能是采用PC浏览器，有可能是采用iPhone设备，也可能是采用各种品牌和型号的Android设备，精心设计的活动页面在某些设备或浏览器上很有可能就出现样式混乱的情况。因此，促销活动页面的浏览器兼容性也是z在测试时需要重点关注的。</p>
<p>差异在哪儿呢？差异就是不同的浏览器内核，不同的设备操作系统，不同的屏幕分辨率。</p>
<p>当然，我们也不可能在所有类型的设备和浏览器上都测一遍，但是主流的浏览器内核和移动设备还是要尽量覆盖的。</p>
<p>推荐的测试方式如下：</p>
<ul>
<li>针对不同浏览器内核的测试，在电脑上采用Chrome、IE、Firefox、Safari浏览器分别加载活动页面；</li>
<li>针对不同移动设备类型的测试，在iPhone和Android设备上加载活动页面，iPhone和Android设备均只选一款即可；</li>
<li>针对不同屏幕分辨率的测试，可以在PC浏览器中打开开发者工具，里面可以模拟不同分辨率的设备加载页面，前面提到的浏览器基本都支持这个功能。</li>
</ul>
<h3 id="4、文案准确性"><a href="#4、文案准确性" class="headerlink" title="4、文案准确性"></a>4、文案准确性</h3><p>对于促销活动而言，吸引眼球的文案肯定是必不可少的，这也是在测试时需要重点关注的。</p>
<p>对于文案方面的测试，可以重点从以下几个方面进行考核。</p>
<p>首先，由于文案通常是由需求方提供，而活动页面是由设计师或前端工程师制作，因此有可能在制作页面的过程中出现了偏差，这个需要测试时仔细核对。</p>
<p>另外，文案中出现错别字的情况也比较多，这个也需要格外注意，尽量杜绝这样的低级错误。</p>
<p>还有一种情况，活动促销页面是面向某个国家的用户，语言可能是非汉语也非英语，这个时候周围谁也看不懂文案里面到底写的是啥。这个时候，只能请需求方再三进行确认，文案描述正确是一方面，另一方面就是需要考虑到目标国家的地域文化，不要出现产生歧义和误解的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容便是从促销活动页面进行展开，联想到的关于测试的一些内容。</p>
<p>可以看出，即使是再简单的东西，也是需要进行测试的，而且测试需要考虑的因素也非常多。另一方面，这也说明测试并不应该仅仅局限于技术层面，只有当我们站在业务和质量保障的角度，才会有更开阔的视野。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/confluence-simple-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/confluence-simple-tutorial/" class="post-title-link" itemprop="url">敏捷团队协作：Confluence简易教程</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-06-07 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-07T00:00:00+08:00">2016-06-07</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/" itemprop="url" rel="index"><span itemprop="name">4. ToolsNotes</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/4-ToolsNotes/others/" itemprop="url" rel="index"><span itemprop="name">others</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0、Confluence简介"><a href="#0、Confluence简介" class="headerlink" title="0、Confluence简介"></a>0、Confluence简介</h2><p>Confluence是一个企业级的Wiki软件，可用于在企业、部门、团队内部进行信息共享和协同编辑。</p>
<h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><p>Confluence的使用并不复杂，只需掌握如下几个基础概念。</p>
<h3 id="空间（Space）"><a href="#空间（Space）" class="headerlink" title="空间（Space）"></a>空间（Space）</h3><p>空间是Confluence系统中的一个区域，用于存储wiki页面，并可实现对空间中的所有文档进行统一的权限管理。</p>
<p>通常，我们可以针对每个项目单独创建一个空间，然后将与该项目相关的文档信息放置到该空间中，并只对项目成员开设访问/编辑权限。</p>
<p>除了项目空间，每个成员都有一个个人空间。平时成员可以将工作总结或笔记等文档放置到自己的空间中；对于对团队有帮助的文档，就可以将文档移动至团队项目空间中。</p>
<h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><p>Dashboard是Confluence系统的主页，在Dashboard界面中包含了Confluence站点中的所有空间列表，以及最近更新内容的列表。</p>
<h3 id="页面（Page）"><a href="#页面（Page）" class="headerlink" title="页面（Page）"></a>页面（Page）</h3><p>在Confluence系统中，页面是存储和共享信息的主要方式。页面可以互相链接、连接、组织和访问，并以树状结构进行组织，放置于空间之中。</p>
<p>页面遵循所见即所得的编辑方式，操作上简单易用。更强大的地方在于，页面支持大量的内容展现形式，除了富文本文档外，还包括图表、视频、附件（可预览）、流程图、公式等等；如果还不够，还可以通过海量的第三方插件进行扩展。</p>
<p>在页面中可以通过<code>@</code>其它成员，通知相关成员查看文档。文档保存成功后，被<code>@</code>的成员就会收到邮件，并可根据邮件中的链接访问到该文档，然后进行评论或者协同编辑。</p>
<h3 id="模板（template）"><a href="#模板（template）" class="headerlink" title="模板（template）"></a>模板（template）</h3><p>创建页面时除了采用空白文档，也可以选择模板。模板是在空白文档的基础上，根据特定需求添加了一些文档要素，可辅助用户更好更快地创建文档。</p>
<p>Confluence内置了大量的模板，可辅助用于项目工作的各个环节，包括产品需求、会议记录、决策记录、指导手册（How-to）、回顾记录、工作计划、任务报告等等。并且由于Confluence和JIRA是同一家公司的产品，在Confluence中可以和JIRA进行无缝衔接，实现对产品质量实现更好的展现。</p>
<p>如果对Confluence自带的模板不满意，还可以对模板进行调整，或者根据自己的需求创建其它类型的模板。</p>
<h3 id="权限（Permission）"><a href="#权限（Permission）" class="headerlink" title="权限（Permission）"></a>权限（Permission）</h3><p>在安全性方面，Confluence具有完善和精细的权限控制，可以很好地控制用户在Wiki中创建、编辑内容和添加注释。</p>
<p>权限控制分3个维度，分别是团队（Group），个人（Individual Users），匿名用户（Anonymous）。</p>
<p>使用团队级的权限控制时，需要在Confluence服务器中对公司员工进行分组，好处在于配置比较方便，只需要对整个团队进行统一的权限配置。</p>
<p>但在实际项目中，经常会存在同一个项目包含多个跨团队成员的情况，这个时候就不适合采用团队权限配置方式，只能采用逐个添加成员的方式，并对各个成员分别配置权限。</p>
<p>另外一种情况，就是对于未登录的用户，以及项目成员以外的用户，可以开设部分权限，例如只读（View）。</p>
<h2 id="2、常见操作"><a href="#2、常见操作" class="headerlink" title="2、常见操作"></a>2、常见操作</h2><p>熟悉了Confluence的基础概念，基本上就可以摸索着对Confluence进行上手了。不过，为了减少摸索时间，在这里我再将Confluence中的常用操作进行说明。</p>
<h3 id="创建空间（Space）"><a href="#创建空间（Space）" class="headerlink" title="创建空间（Space）"></a>创建空间（Space）</h3><p>新建一个项目时，首先要做的就是创建一个空间，并进行初始化配置。</p>
<p>创建空间的方式很简单，可以从顶部菜单进行创建：【Spaces】-&gt;【Create Space】；也可以从Dashboard页面的Spaces页面中进行创建。</p>
<p><img src="/images/Confluence_Dashboard.png" alt="Confluence Dashboard"></p>
<p>进入创建空间页面后，需要选择空间类型。这个需要根据空间的用途进行选择，对于团队协作的空间，推荐选择“Team Space”，如果实在不知道选择什么类型，选择“Blank Space”也是可以的。</p>
<p><img src="/images/Confluence_Create_Space.png" alt="Create space in Confluence"></p>
<p>然后是填写空间的基本信息。所有类型的空间都有两个必填字段，Space name和Space key。Space key可以理解为空间的ID，不同空间的Space key不能重复，但Space name是可以重复的。</p>
<p>另外，对于“Team Space”类型的空间，多了一个“Team members”字段，用于添加空间的成员。成员的名称是其公司邮箱的前缀。</p>
<p>需要说明的是，空间创建完成后，Space key字段是不能修改的，其它字段以及团队成员都可以进行修改。</p>
<p><img src="/images/Confluence_Create_Team_Space.png" alt="Create team space in Confluence"></p>
<h3 id="配置空间权限"><a href="#配置空间权限" class="headerlink" title="配置空间权限"></a>配置空间权限</h3><p>创建空间后，根据项目需要，可以给空间设置权限。只有空间的管理员才能对空间权限进行配置。</p>
<p>操作方式如下：首先进入空间的页面，在空间左下角中，【Space tools】-&gt;【Permissions】，进入权限管理页面。</p>
<p><img src="/images/Confluence_Permissions_menu.png" alt="Permissions menu of Confluence"></p>
<p>Confluence的权限控制比较完善，可以根据团队规范进行较为精细粒度的设置。</p>
<p><img src="/images/Confluence_Permissions_Setting.png" alt="Permissions settings of Confluence"></p>
<h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>在Confluence中文件以树状结构进行组织。</p>
<p>推荐的创建方式是，先进入父目录的页面，然后再点击【Create】进行创建。在创建文档页面中，可以看到新建文档的“Parent”，表示新文档创建后将位于“Parent”文件的下一个层级中。</p>
<p><img src="/images/Confluence_Create_Page.png" alt="Create page in Confluence"></p>
<p>在新建文档时，需要选择文档模板。这个就根据文档的实际类型或用途进行选择即可，如果觉得都不合适，就选择“Blank page”。</p>
<h3 id="编写文档"><a href="#编写文档" class="headerlink" title="编写文档"></a>编写文档</h3><p>在编写文档时，页面遵循所见即所得的编辑方式，基本上跟在MS Word中的操作类似。</p>
<p>Confluence也集成了许多编辑工具，可以很方便地插入图表、链接、附件、代办列表等等。如果还不满足需求，可以点击【Insert】-&gt;【Other macros】，查找更多的扩展插件。</p>
<p><img src="/images/Confluence_Edit_Page.png" alt="Edit page of Confluence"></p>
<p>例如，Confluence默认是不支持Markdown编辑模式的，如果想采用Markdown来编写文档，就可以通过上述方式到插件市场寻找Markdown的插件。</p>
<p>不过根据实践发现，当前Confluence的Markdown插件支持的还不够好，使用体验上不尽如人意。比较推荐的做法，还是在单独的Markdown编辑器上采用markdown语法进行编辑，编辑完成后进行预览，然后将渲染后的文档内容复制粘贴到Confluence中。</p>
<h3 id="移动文档"><a href="#移动文档" class="headerlink" title="移动文档"></a>移动文档</h3><p>很多时候我们需要调整目录结构，这就涉及到需要将文档移动到别的目录层级下。</p>
<p>操作方式如下：先进入到待移动的文档页面中，点击页面右上角的【…】-&gt;【Move】；</p>
<p><img src="/images/Confluence_Move_Page_menu.png" alt="Move page menu of Confluence"></p>
<p>然后选择新的目录即可。</p>
<p><img src="/images/Confluence_Move_Page.png" alt="Move page of Confluence"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-write-iOS-testcase-scripts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/build-app-automated-test-platform-from-0-to-1-write-iOS-testcase-scripts/" class="post-title-link" itemprop="url">从0到1搭建移动App功能自动化测试平台（3）：编写iOS自动化测试脚本</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-30 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-30T00:00:00+08:00">2016-05-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/AppiumBooster/" itemprop="url" rel="index"><span itemprop="name">AppiumBooster</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过前面三篇文章，我们已经将iOS自动化功能测试的开发环境全部准备就绪，也学习了iOS UI控件交互操作的一般性方法，接下来，就可以开始编写自动化测试脚本了。</p>
<p>在本文中，我将在M项目中挑选一个功能点，对其编写自动化测试脚本，演示编写自动化测试用例的整个流程。</p>
<h2 id="语言的选择：Python-or-Ruby？"><a href="#语言的选择：Python-or-Ruby？" class="headerlink" title="语言的选择：Python or Ruby？"></a>语言的选择：Python or Ruby？</h2><p>之前介绍Appium的时候也提到，Appium采用Client-Server的架构设计，并采用标准的HTTP通信协议；Client端基本上可以采用任意主流编程语言编写测试用例，包括但不限于C#、Ruby、Objective-C、Java、node.js、Python、PHP。</p>
<p>因此，在开始编写自动化测试脚本之前，首先需要选定一门编程语言。</p>
<p>这个选择因人而异，并不涉及到太大的优劣之分，基本上在上述几门语言中选择自己最熟悉的就好。</p>
<p>但对我而言，选择却没有那么干脆，前段时间在Python和Ruby之间犹豫了很久，经过艰难的决定，最终选择了Ruby。为什么不考虑Java？不熟是一方面，另一方面是觉得采用编译型语言写测试用例总感觉太重，这活儿还是解释型语言来做更合适些。</p>
<p>其实，最开始本来是想选择Python的，因为Python在软件测试领域比Ruby应用得更广，至少在国内，不管是公司团队，还是测试人员群体，使用Python的会比使用Ruby的多很多。</p>
<p>那为什么还是选择了Ruby呢？</p>
<p>我主要是基于如下几点考虑的：</p>
<ul>
<li>从Appium的官方文档来看，Appium对Ruby的支持力度，或者说是偏爱程度，貌似会更大些；在<a href="http://appium.io/downloads.html" target="_blank" rel="noopener">Appium Client Libraries</a>列表中将Ruby排在第一位就不说了，在<a href="http://appium.io/tutorial.html?lang=en" target="_blank" rel="noopener">Appium Tutorials</a>中示例语言就只采用了Ruby和Java进行描述。</li>
<li><a href="https://github.com/appium/ruby_lib" target="_blank" rel="noopener">Appium_Console</a>是采用Ruby编写的，在Console中执行的命令基本上可直接用在Ruby脚本中。</li>
<li>后续打算引入BDD（行为驱动开发）的测试模式，而不管是cucumber还是RSpec，都是采用Ruby开发的。</li>
</ul>
<p>当然，还有最最重要的一点，身处于珠江三角洲最大的Ruby阵营，周围Ruby大牛云集，公司的好多业务系统也都是采用Rails作为后台语言，完全没理由不选择Ruby啊。</p>
<h2 id="第一个测试用例：系统登录"><a href="#第一个测试用例：系统登录" class="headerlink" title="第一个测试用例：系统登录"></a>第一个测试用例：系统登录</h2><p>在测试领域中，系统登录这个功能点的地位，堪比软件开发中的<code>Hello World</code>，因此第一个测试用例就毫无悬念地选择系统登录了。</p>
<p>在编写自动化测试脚本之前，我们首先需要清楚用例执行的路径，路径中操作涉及到的控件，以及被操作控件的属性信息。</p>
<p>对于本次演示的APP来说，登录时需要先进入【My Account】页面，然后点击【Login】进入登录页面，接着在登录页面中输入账号密码后再点击【Login】按钮，完成登录操作。</p>
<p><img src="/images/DebugTalk_Plus_Login.jpg" alt="Preview of DebugTalk Plus login"></p>
<p>确定了操作路径以后，就可以在<code>Appium Ruby Console</code>中依次操作一遍，目的是确保代码能正确地对控件进行操作。</p>
<p>第一步要点击【My Account】按钮，因此先查看下Button控件属性。要是不确定目标控件的类型，可以直接执行<code>page</code>命令，然后在返回结果中根据控件名称进行查找。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1] pry(main)&gt; page :button</span><br><span class="line">...（略）</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: My Account</span><br><span class="line">   id: My Account =&gt; My Account</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>通过返回结果，可以看到【My Account】按钮的name、label属性就是“My Account”，因此可以通过<code>button_exact(&#39;My Account&#39;)</code>方式来定位控件，并进行点击操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2] pry(main)&gt; button_exact('My Account').click</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>执行命令后，观察iOS模拟器中APP的响应情况，看是否成功进入“My Account”页面。</p>
<p>第二步也是类似的，操作代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3] pry(main)&gt; button_exact('Login').click</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>进入到登录页面后，再次查看页面中的控件信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[4] pry(main)&gt; page</span><br><span class="line">...（略）</span><br><span class="line">UIATextField</span><br><span class="line">   value: Email Address</span><br><span class="line">   id: Email Address =&gt; Email Address</span><br><span class="line">UIASecureTextField</span><br><span class="line">   value: Password (6-16 characters)</span><br><span class="line">   id: Password (6-16 characters) =&gt; Password (6-16 characters)</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: Login</span><br><span class="line">   id: Log In =&gt; Login</span><br><span class="line">       登录     =&gt; Login</span><br><span class="line">...（略）</span><br></pre></td></tr></table></figure>

<p>第三步需要填写账号密码，账号密码的控件属性分别是<code>UIATextField</code>和<code>UIASecureTextField</code>。由于这两个控件的类型在登录页面都是唯一的，因此可以采用控件的类型来进行定位，然后进行输入操作，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[5] pry(main)&gt; tag('UIATextField').type 'leo.lee@debugtalk.com'</span><br><span class="line">""</span><br><span class="line">[6] pry(main)&gt; tag('UIASecureTextField').type '123456'</span><br><span class="line">""</span><br></pre></td></tr></table></figure>

<p>执行完输入命令后，在iOS模拟器中可以看到账号密码输入框都成功输入了内容。</p>
<p>最后第四步点击【Login】按钮，操作上和第二步完全一致。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[7] pry(main)&gt; button_exact('Login').click</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>执行完以上四个步骤后，在iOS模拟器中看到成功完成账号登录操作，这说明我们的执行命令没有问题，可以用于编写自动化测试代码。整合起来，测试脚本就是下面这样。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button_exact(<span class="string">'My Account'</span>).click</span><br><span class="line">button_exact(<span class="string">'Login'</span>).click</span><br><span class="line">tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@debugtalk.com'</span></span><br><span class="line">tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'12345678'</span></span><br><span class="line">button_exact(<span class="string">'Login'</span>).click</span><br></pre></td></tr></table></figure>

<p>将以上脚本保存为<code>login.rb</code>文件。</p>
<p>但当我们直接运行<code>login.rb</code>文件时，并不能运行成功。原因很简单，脚本中的<code>button_exact</code>、<code>tag</code>这些方法并没有定义，我们在文件中也没有引入相关库文件。</p>
<p>在上一篇文章中有介绍过，通过<code>arc</code>启动虚拟机时，会从<code>appium.txt</code>中读取虚拟机的配置信息。类似的，我们在脚本中执行自动化测试时，也会加载虚拟机，因此同样需要在脚本中指定虚拟机的配置信息，并初始化<code>Appium Driver</code>的实例。</p>
<p>初始化代码可以通过<code>Appium Inspector</code>生成，基本上为固定模式，我们暂时不用深究。</p>
<p>添加初始化部分的代码后，测试脚本如下所示。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'appium_lib'</span></span><br><span class="line"></span><br><span class="line">capabilities = &#123;</span><br><span class="line">  <span class="string">'appium-version'</span> =&gt; <span class="string">'1.0'</span>,</span><br><span class="line">  <span class="string">'platformName'</span> =&gt; <span class="string">'iOS'</span>,</span><br><span class="line">  <span class="string">'platformVersion'</span> =&gt; <span class="string">'9.3'</span>,</span><br><span class="line">&#125;</span><br><span class="line">Appium::Driver.new(<span class="symbol">caps:</span> capabilities).start_driver</span><br><span class="line">Appium.promote_appium_methods Object</span><br><span class="line"></span><br><span class="line"><span class="comment"># testcase: login</span></span><br><span class="line">button_exact(<span class="string">'My Account'</span>).click</span><br><span class="line">button_exact(<span class="string">'Login'</span>).click</span><br><span class="line">tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@debugtalk.com'</span></span><br><span class="line">tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'123456'</span></span><br><span class="line">button_exact(<span class="string">'Login'</span>).click</span><br><span class="line"></span><br><span class="line">driver_quit</span><br></pre></td></tr></table></figure>

<h2 id="优化测试脚本：加入等待机制"><a href="#优化测试脚本：加入等待机制" class="headerlink" title="优化测试脚本：加入等待机制"></a>优化测试脚本：加入等待机制</h2><p>如上测试脚本编写好后，在Terminal中运行<code>ruby login.rb</code>，就可以执行脚本了。</p>
<p>运行命令后，会看到iOS虚拟机成功启动，接着App成功进行加载，然后自动按照前面设计的路径，执行系统登录流程。</p>
<p>但是，在实际操作过程中，发现有时候运行脚本时会出现找不到控件的异常，异常信息如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜ ruby login.rb</span><br><span class="line">/Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/common/helper.rb:218:in `_no_such_element': An element could not be located on the page using the given search parameters. (Selenium::WebDriver::Error::NoSuchElementError)</span><br><span class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/ios/helper.rb:578:in `ele_by_json'</span><br><span class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/ios/helper.rb:367:in `ele_by_json_visible_exact'</span><br><span class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/ios/element/button.rb:41:in `button_exact'</span><br><span class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/driver.rb:226:in `rescue in block (4 levels) in promote_appium_methods'</span><br><span class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/driver.rb:217:in `block (4 levels) in promote_appium_methods'</span><br><span class="line">truefrom login.rb:28:in `&lt;main&gt;'</span><br></pre></td></tr></table></figure>

<p>更奇怪的是，这个异常并不是稳定出现的，有时候能正常运行整个用例，但有时在某个步骤就会抛出找不到控件的异常。这是什么原因呢？为什么在<code>Appium Ruby Console</code>中单步操作时就不会出现这个问题，但是在执行脚本的时候就会偶尔出现异常呢？</p>
<p>原来，在我们之前的脚本中，两条命令之间并没有间隔时间，有可能前一条命令执行完后，模拟器中的应用还没有完成下一个页面的加载，下一条命令就又开始查找控件，然后由于找不到控件就抛出异常了。</p>
<p>这也是为什么我们在<code>Appium Ruby Console</code>中没有出现这样的问题。因为手工输入命令多少会有一些耗时，输入两条命令的间隔时间足够虚拟机中的APP完成下一页面的加载了。</p>
<p>那针对这种情况，我们要怎么修改测试脚本呢？难道要在每一行代码之间都添加休眠（sleep）函数么？</p>
<p>也不用这么麻烦，针对这类情况，<code>ruby_lib</code>实现了<code>wait</code>机制。将执行命令放入到<code>wait{}</code>中后，执行脚本时就会等待该命令执行完成后再去执行下一条命令。当然，等待也不是无休止的，如果等待30秒后还是没有执行完，仍然会抛出异常。</p>
<p>登录流程的测试脚本修改后如下所示（已省略初始化部分的代码）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait &#123; button_exact(<span class="string">'My Account'</span>).click &#125;</span><br><span class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</span><br><span class="line">wait &#123; tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@debugtalk.com'</span> &#125;</span><br><span class="line">wait &#123; tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'123456'</span> &#125;</span><br><span class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</span><br></pre></td></tr></table></figure>

<p>对脚本添加<code>wait</code>机制后，之前出现的找不到控件的异常就不再出现了。</p>
<h2 id="优化测试脚本：加入结果检测机制"><a href="#优化测试脚本：加入结果检测机制" class="headerlink" title="优化测试脚本：加入结果检测机制"></a>优化测试脚本：加入结果检测机制</h2><p>然而，现在脚本仍然不够完善。</p>
<p>我们在<code>Appium Ruby Console</code>中手工执行命令后，都是由人工肉眼确认虚拟机中APP是否成功进入下一个页面，或者返回结果是否正确。</p>
<p>但是在执行自动化测试脚本时，我们不可能一直去盯着模拟器。因此，我们还需要在脚本中加入结果检测机制，通过脚本实现结果正确性的检测。</p>
<p>具体怎么做呢？</p>
<p>原理也很简单，只需要在下一个页面中，寻找一个在前一个页面中没有的控件。</p>
<p>例如，由A页面跳转至B页面，在B页面中会存在“Welcome”的文本控件，但是在A页面中是没有这个“Welcome”文本控件的；那么，我们就可以在脚本中的跳转页面语句之后，加入一条检测“Welcome”文本控件的语句；后续在执行测试脚本的时候，如果页面跳转失败，就会因为找不到控件而抛出异常，我们也能通过这个异常知道测试执行失败了。</p>
<p>当然，对下一页面中的控件进行检测时同样需要加入等待机制的。</p>
<p>登录流程的测试脚本修改后如下所示（已省略初始化部分的代码）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wait &#123; button_exact(<span class="string">'My Account'</span>).click &#125;</span><br><span class="line">wait &#123; text_exact <span class="string">'System Settings'</span> &#125;</span><br><span class="line"></span><br><span class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</span><br><span class="line">wait &#123; button_exact <span class="string">'Forget password?'</span> &#125;</span><br><span class="line"></span><br><span class="line">wait &#123; tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@debugtalk.com'</span> &#125;</span><br><span class="line">wait &#123; tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'12345678'</span> &#125;</span><br><span class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</span><br><span class="line">wait &#123; text_exact <span class="string">'My Message'</span> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，系统登录流程的自动化测试脚本我们就编写完成了。</p>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>在本文中，我们通过系统登录这一典型功能点，演示了编写自动化测试用例的整个流程。</p>
<p>在下一篇文章中，我们还会对自动化测试脚本的结构进行进一步优化，并实现测试代码工程化。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-interrogate-iOS-UI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/build-app-automated-test-platform-from-0-to-1-Appium-interrogate-iOS-UI/" class="post-title-link" itemprop="url">从0到1搭建移动App功能自动化测试平台（2）：操作iOS应用的控件</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-29 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-29T00:00:00+08:00">2016-05-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/AppiumBooster/" itemprop="url" rel="index"><span itemprop="name">AppiumBooster</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前两天微信突然发来一条系统消息，提示<code>DebugTalk</code>可以开通原创标识了（同时也有了评论功能），虽然一直在期待，但没想到来得这么快，着实是个不小的惊喜。</p>
<p>另外，最近在公众号后台也收到好几个朋友的信息，有的是询问某某部分什么时候能发布，有的是希望能加快更新速度。说实话，收到这样的信息虽然会有压力，但真的挺开心的，因为这说明<code>DebugTalk</code>至少能给一部分人带去价值，这说明这件事本身还是值得坚持去做的。</p>
<p>不过，在更新频率这件事儿上，的确是要跟大家说抱歉了。因为<code>DebugTalk</code>发布的内容全都是原创，主题基本上都是来源于我日常测试工作的经验积累，或者我近期学习一些测试技术的收获总结，这也意味着，我写的东西很多时候并不是自己完全熟悉的（完全掌握的东西也没有足够的动力专门花时间去写）。</p>
<p>就拿最近连载的《从0到1搭建移动App功能自动化测试平台》系列来说，由于我也是边探索边总结，因此中途难免会遇到一些意想不到的坑，造成额外的耗时，而且为了保证文章能尽量通俗易通，我也需要对涉及到的内容充分进行理解，并且经过大量实践进行验证，然后才能站在半个初学者、半个过来人的角度，重新整理思路，最后以尽可能流畅的思路将主题内容讲解清楚。</p>
<p>基于这些原因，<code>DebugTalk</code>要做到每日更新是很难了，但是保证每周发布1~2篇还是可以的，希望大家能理解。</p>
<h2 id="关于UI控件"><a href="#关于UI控件" class="headerlink" title="关于UI控件"></a>关于UI控件</h2><p>在上一篇文章中，我们成功地通过Appium Inspector调用模拟器并运行iOS应用，iOS的自动化测试环境也已全部准备就绪了。</p>
<p>那么接下来，我们就可以开始实现自动化测试了么？</p>
<p>貌似还不行。在开始之前，我们先想下什么是APP功能自动化测试。</p>
<p>APP的功能自动化测试，简单地来说，就是让功能测试用例自动地在APP上执行。具体到每一个测试用例，就是能模拟用户行为对UI控件进行操作，自动化地实现一个功能点或者一个流程的操作。再细分到每一步，就是对UI控件进行操作。</p>
<p>因此，在正式开始编写自动化测试用例之前，我们还需要熟悉如何与APP的UI控件进行交互操作。</p>
<p>在iOS系统中，UI控件有多种类型，常见的有按钮（UIAButton）、文本（UIAStaticText）、输入框（UIATextField）等等。但不管是对什么类型的UI控件进行操作，基本都可以分解为三步，首先是获取目标控件的属性信息，然后是对目标控件进行定位，最后是对定位到的控件执行动作。</p>
<h2 id="获取UI控件信息"><a href="#获取UI控件信息" class="headerlink" title="获取UI控件信息"></a>获取UI控件信息</h2><p>在Appium中，要获取iOS的UI控件元素信息，可以采用两种方式：一种是在前一篇文章中提到的Appium Inspector，另一种是借助Ruby实现的<code>appium_console</code>，在Terminal中通过命令进行查询。</p>
<h3 id="Appium-Inspector"><a href="#Appium-Inspector" class="headerlink" title="Appium Inspector"></a>Appium Inspector</h3><p>运行Appium Server，并启动【Inspector】后，整体界面如下图所示。</p>
<p><img src="/images/Appium_inspector_introduction.jpg" alt="Appium inspector introduction"></p>
<p>现对照着这张图对Appium Inspector进行介绍。</p>
<p>在右边部分，是启动的模拟器，里面运行着我们的待测APP。我们可以像在真机中一样，在模拟器中执行任意功能的操作，当然，模拟器跟真机毕竟还是有区别的，跟传感器相关的功能，例如摄像头、重力感应等，是没法实现的。</p>
<p>在左边部分，就是<code>Appium Inspector</code>。Inspector主要由如下四个部分组成：</p>
<ul>
<li>预览界面区：显示画面与模拟器界面一致；不过，当我们在模拟器中切换界面后，Inspector的预览区中显示图像并不会自动同步，若要同步，需要点击【Refresh】按钮，然后Inspector会将模拟器当前UI信息dump后显示到预览区；在预览区中，可以点击选择任意UI控件。</li>
<li>UI信息展示区：展示当前界面预览区中所有UI元素的层级关系和UI元素的详细信息；在预览区中点击选择任意UI控件后，在“Details”信息框中展示选中控件的详细信息，包括name、label、value、xpath等属性值；通过层级关系，我们也能了解选中控件在当前界面树状结构中所处的具体位置。</li>
<li>交互操作区：模拟用户在设备上的操作，例如单击（tap）、滑动（swipe）、晃动（shake）、输入（input）等；操作动作是针对预览界面区选中的控件，因此在操作之前，务必需要先在预览区点击选择UI元素。</li>
<li>脚本生成区：将用户行为转换为脚本代码；点击【Record】按钮后，会弹出代码区域；在交互操作区进行操作后，就会实时生成对应的脚本代码；代码语言可通过下拉框进行选择，当前支持的语言类型有：C#、Ruby、Objective-C、Java、node.js、Python。</li>
</ul>
<p>在实践操作中，Inspector最大的用途就是在可以可视化地查看UI元素信息，并且可以将操作转换为脚本代码，这对初学者尤为有用。</p>
<p>例如，在预览区点击选中按钮“BUY NOW”，然后在UI信息展示区的Details窗口就可以看到该按钮的所有属性信息。在交互操作区点击【Tap】按钮后，就会模拟用户点击“BUY NOW”按钮，并且在脚本区域生成当次按钮点击的脚本（选择Ruby语言）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_element(<span class="symbol">:name</span>, <span class="string">"BUY NOW &gt;"</span>).click</span><br></pre></td></tr></table></figure>

<p>如上就是使用<code>Appium Inspector</code>的一般性流程。</p>
<h3 id="Appium-Ruby-Console"><a href="#Appium-Ruby-Console" class="headerlink" title="Appium Ruby Console"></a>Appium Ruby Console</h3><p>有了<code>Appium Inspector</code>，为什么还需要<code>Appium Ruby Console</code>呢？</p>
<p>其实，<code>Appium Ruby Console</code>也并不是必须的。经过与多个熟悉<code>Appium</code>的前辈交流，他们也从未用过<code>Appium Ruby Console</code>，这说明<code>Appium Ruby Console</code>并不是必须的，没有它也不会影响我们对<code>Appium</code>的使用。</p>
<p>但是，这并不意味着<code>Appium Ruby Console</code>是多余的。经过这些天对<code>Appium</code>的摸索，我越发地喜欢上<code>Appium Ruby Console</code>，并且使用的频率越来越高，现在已基本上很少使用<code>Appium Inspector</code>了。这种感觉怎么说呢？<code>Inspector</code>相比于<code>Ruby Conosle</code>，就像是<code>GUI</code>相比于<code>Linux Terminal</code>，大家应该能体会了吧。</p>
<p><code>Appium Inspector</code>的功能是很齐全，GUI操作也很方便，但是，最大的问题就是使用的时候非常慢，在预览界面区切换一个页面常常需要好几秒，甚至数十秒，这是很难让人接受的。</p>
<p>在上一节中也说到了，Inspector最大的用途就是在可以可视化地查看UI元素信息，并且可以将操作转换为脚本代码。但是当我们对<code>Appium</code>的常用API熟悉以后，我们就不再需要由工具来生成脚本，因为自己直接写会更快，前提是我们能知道目标控件的属性信息（type、name、label、value）。</p>
<p>在这种情况下，如果能有一种方式可以供我们快速查看当前屏幕的控件属性信息，那该有多好。</p>
<p>庆幸的是，在阅读<code>Appium</code>官方文档时，发现<code>Appium</code>的确是支持命令行方式的，这就是<code>Appium Ruby Console</code>。</p>
<p><code>Appium Ruby Console</code>是采用Ruby语言开发的，在使用方式上面和Ruby的<code>irb</code>很类似。</p>
<p>在使用<code>Appium Ruby Console</code>时，虚拟机的配置信息并不会从GUI中读取，而是要通过配置文件进行指定。</p>
<p>配置文件的名称统一要求为<code>appium.txt</code>，内容形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[caps]</span><br><span class="line">platformName = &quot;ios&quot;</span><br><span class="line">platformVersion = &apos;9.3&apos;,</span><br><span class="line">app = &quot;/path/to/UICatalog.app.zip&quot;</span><br><span class="line">deviceName = &quot;iPhone Simulator&quot;</span><br></pre></td></tr></table></figure>

<p>其中，<code>platformName</code>指定虚拟机操作系统类型，“ios”或者”android”；<code>platformVersion</code>指定操作系统的版本，例如iOS的’9.3’，或者Android的’5.1’；<code>app</code>指定被测应用安装包的路径。这三个参数是必须的，与Inspector中的配置也能对应上。</p>
<p>在使用<code>Appium Ruby Console</code>时，首先需要启动<code>Appium Server</code>，通过<code>GUI</code>或者<code>Terminal</code>均可。</p>
<p>然后，在Terminal中，进入到<code>appium.txt</code>文件所在的目录，执行<code>arc</code>命令即可启动<code>Appium Ruby Console</code>。<code>arc</code>，即是appium ruby console首字母的组合。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ ls</span><br><span class="line">appium.txt</span><br><span class="line">➜ arc</span><br><span class="line">[1] pry(main)&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，就可以通过执行命令查询当前设备屏幕中的控件信息。</p>
<p>使用频率最高的一个命令是<code>page</code>，通过这个命令可以查看到当前屏幕中所有控件的基本信息。</p>
<p>例如，当屏幕停留在前面截图中的页面时，执行<code>page</code>命令可以得到如下内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[1] pry(main)&gt; page</span><br><span class="line">UIANavigationBar</span><br><span class="line">   name: HomeView</span><br><span class="line">   id: Home =&gt; Home</span><br><span class="line">       米    =&gt; m</span><br><span class="line">       去看看  =&gt; View</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: tabbar category gray</span><br><span class="line">UIAImage</span><br><span class="line">   name: debugtalk_logo.png</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: tabbar cart gray</span><br><span class="line">UIATableView</span><br><span class="line">   value: rows 1 to 4 of 15</span><br><span class="line">UIAPageIndicator</span><br><span class="line">   value: page 2 of 2</span><br><span class="line">UIATableCell</span><br><span class="line">   name: For the first time ever in a hand held camera, the Osmo brings professional, realtime cinema-quality stabilization.</span><br><span class="line">   id: 米 =&gt; m</span><br><span class="line">UIAStaticText</span><br><span class="line">   name, label, value: For the first time ever in a hand held camera, the Osmo brings professional, realtime cinema-quality stabilization.</span><br><span class="line">   id: 米 =&gt; m</span><br><span class="line">UIAStaticText</span><br><span class="line">   name, label, value: OSMO</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: SHOP NOW &gt;</span><br><span class="line">UIATableCell</span><br><span class="line">   name: Ronin</span><br><span class="line">UIAStaticText</span><br><span class="line">   name, label, value: Ronin</span><br><span class="line">UIAStaticText</span><br><span class="line">   name, label, value: Phantom</span><br><span class="line">   id: 米 =&gt; m</span><br><span class="line">... (略)</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: Store</span><br><span class="line">   value: 1</span><br><span class="line">   id: 门店 =&gt; Store</span><br><span class="line">... (略)</span><br><span class="line">UIAButton</span><br><span class="line">   name, label: My Account</span><br><span class="line">   id: My Account =&gt; My Account</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>通过返回信息，我们就可以看到所有控件的type、name、label、value属性值。如果在某个控件下没有显示label或value，这是因为这个值为空，我们可以不予理会。</p>
<p>由于<code>page</code>返回的信息太多，可能不便于查看，因此在使用<code>page</code>命令时，也可以指定控件的类型，相当于对当前屏幕的控件进行筛选，只返回指定类型的控件信息。</p>
<p>指定控件类型时，可以通过string类型进行指定（如 page “Image”），也可通过symbol类型进行指定（如 page :cell）。指定的类型可只填写部分内容，并且不分区大小写。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[2] pry(main)&gt; page "Image"</span><br><span class="line">UIAImage</span><br><span class="line">   name: debugtalk_logo.png</span><br><span class="line">nil</span><br><span class="line">[3] pry(main)&gt; page :cell</span><br><span class="line">UIATableCell</span><br><span class="line">   name: DebugTalk’s smartest flying camera ever.</span><br><span class="line">   id: 米 =&gt; m</span><br><span class="line">UIATableCell</span><br><span class="line">   name: Ronin</span><br><span class="line">UIATableCell</span><br><span class="line">   name: Phantom</span><br><span class="line">   id: 米 =&gt; m</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>如果需要查看当前屏幕的所有控件类型，可以执行<code>page_class</code>命令进行查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[4] pry(main)&gt; page_class</span><br><span class="line">14x UIAButton</span><br><span class="line">8x UIAStaticText</span><br><span class="line">4x UIAElement</span><br><span class="line">4x UIATableCell</span><br><span class="line">2x UIAImage</span><br><span class="line">2x UIAWindow</span><br><span class="line">1x UIAPageIndicator</span><br><span class="line">1x UIATableView</span><br><span class="line">1x UIAStatusBar</span><br><span class="line">1x UIANavigationBar</span><br><span class="line">1x UIATabBar</span><br><span class="line">1x UIAApplication</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>基本上，<code>page</code>返回的控件信息已经足够满足绝大多数场景需求，但有时候情况比较特殊，需要<code>enabled</code>、<code>xpath</code>、<code>visible</code>、坐标等属性信息，这时就可以通过执行<code>source</code>命令。执行<code>source</code>命令后，就可以返回当前屏幕中所有控件的所有信息，以xml格式进行展现。</p>
<h2 id="定位UI控件"><a href="#定位UI控件" class="headerlink" title="定位UI控件"></a>定位UI控件</h2><p>获取到UI控件的属性信息后，就可以对控件进行定位了。</p>
<p>首先介绍下最通用的定位方式，<code>find</code>。通过<code>find</code>命令，可以实现在控件的诸多属性值（<code>name</code>、<code>label</code>、<code>value</code>、<code>hint</code>）中查找目标值。查询时不区分大小写，如果匹配结果有多个，则只返回第一个结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[5] pry(main)&gt; find('osmo')</span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;Selenium::WebDriver::Element:0x..febd52a30dcdfea32 id=<span class="string">"2"</span>&gt;</span></span><br><span class="line">[6] pry(main)&gt; find('osmo').label</span><br><span class="line">"Osmo"</span><br></pre></td></tr></table></figure>

<p>另一个通用的定位方式是<code>find_element</code>，它也可以实现对所有控件进行查找，但是相对于<code>find</code>，可以对属性类型进行指定。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[7] pry(main)&gt; find_element(:class_name, 'UIATextField')</span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;Selenium::WebDriver::Element:0x31d87e3848df8804 id=<span class="string">"3"</span>&gt;</span></span><br><span class="line">[8] pry(main)&gt; find_element(:class_name, 'UIATextField').value</span><br><span class="line">"Email Address"</span><br></pre></td></tr></table></figure>

<p>不过在实践中发现，采用<code>find</code>、<code>find_element</code>这类通用的定位方式并不好用，因为定位结果经常不是我们期望的。</p>
<p>经过反复摸索，我推荐根据目标控件的类型，选择对应的定位方式。总结起来，主要有以下三种方式。</p>
<p>针对Button类型的控件（UIAButton），采用<code>button_exact</code>进行定位：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[9] pry(main)&gt; button_exact('Login')</span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;Selenium::WebDriver::Element:0x..feaebd8302b6d77cc id=<span class="string">"4"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>针对Text类型的控件（UIAStaticText），采用<code>text_exact</code>进行定位：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[10] pry(main)&gt; text_exact('Phantom')</span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;Selenium::WebDriver::Element:0x1347e89100fdcee2 id=<span class="string">"5"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>针对控件类型进行定位时，采用<code>tag</code>；如下方式等价于<code>find_element(:class_name, &#39;UIASecureTextField&#39;)</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[11] pry(main)&gt; tag('UIASecureTextField')</span><br><span class="line"><span class="meta">#</span><span class="bash">&lt;Selenium::WebDriver::Element:0x..fc6f5efd05a82cdca id=<span class="string">"6"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本上，这三种方式就已经足够应付绝大多数测试场景了。当然，这三种方式只是我个人经过实践后选择的定位方式，除了这三种，<code>Appium</code>还支持很多种其它定位方式，大家可自行查看<code>Appium</code>官方文档进行选择。</p>
<p>另外，除了对控件进行定位，有时候我们还想判断当前屏幕中是否存在某个控件（通常用于结果检测判断），这要怎么做呢？</p>
<p>一种方式是借助于<code>Appium</code>的控件查找机制，即找不到控件时会抛出异常（<code>Selenium::WebDriver::Error::NoSuchElementError</code>）；反过来，当查找某个控件抛出异常时，则说明当前屏幕中不存在该控件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[12] pry(main)&gt; button_exact('Login_invalid')</span><br><span class="line">Selenium::WebDriver::Error::NoSuchElementError: An element could not be located on the page using the given search parameters.</span><br><span class="line">from /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/common/helper.rb:218:in `_no_such_element'</span><br></pre></td></tr></table></figure>

<p>该种方式可行，但比较暴力，基本上不会采用这种方式。</p>
<p>另一种更好的方式是，查找当前屏幕中指定控件的个数，若个数不为零，则说明控件存在。具体操作上，将<code>button_exact</code>替换为<code>buttons_exact</code>，将<code>text_exact</code>替换为<code>texts_exact</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[12] pry(main)&gt; buttons_exact('Login').count</span><br><span class="line">1</span><br><span class="line">[13] pry(main)&gt; buttons_exact('Login_invalid').count</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>除此之外，基于Ruby实现的<code>appium_lib</code>还支持<code>exists</code>方法，可直接返回Boolean值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[14] pry(main)&gt; exists &#123; button_exact('Login') &#125;</span><br><span class="line">true</span><br><span class="line">[15] pry(main)&gt; exists &#123; button_exact('Login_invalid') &#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h2 id="对控件执行操作"><a href="#对控件执行操作" class="headerlink" title="对控件执行操作"></a>对控件执行操作</h2><p>定位到具体的控件后，操作就比较容易了。</p>
<p>操作类型不多，最常用就是点击（click）和输入（type），这两个操作能覆盖80%以上的场景。</p>
<p>对于点击操作，才定位到的控件后面添加<code>.click</code>方法；对于输入操作，在定位到的输入框控件后面添加<code>.type</code>方法，并传入输入值。</p>
<p>例如，账号登录操作就包含输入和点击两种操作类型。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[16] pry(main)&gt; find_element(:class_name, 'UIATextField').type 'leo.lee@debugtalk.com'</span><br><span class="line">""</span><br><span class="line">[17] pry(main)&gt; find_element(:class_name, 'UIASecureTextField').type '123456'</span><br><span class="line">""</span><br><span class="line">[18] pry(main)&gt; button_exact('Login').click</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>在本文中，我们学习了对iOS UI控件进行交互操作的一般性方法，为编写自动化测试脚本打好了基础。</p>
<p>在下一篇文章中，我们就要正式开始针对iOS应用编写自动化测试脚本了。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/" class="post-title-link" itemprop="url">从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-21 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-21T00:00:00+08:00">2016-05-21</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/AppiumBooster/" itemprop="url" rel="index"><span itemprop="name">AppiumBooster</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇文章中，我对本系列教程的项目背景进行了介绍，并对自动化测试平台的建设进行了规划。</p>
<p>在本文中，我将在已准备就绪的iOS自动化测试环境的基础上，通过Appium调用模拟器运行iOS应用。内容很是基础，熟悉的同学可直接略过。</p>
<h2 id="iOS应用安装包的基础知识"><a href="#iOS应用安装包的基础知识" class="headerlink" title="iOS应用安装包的基础知识"></a>iOS应用安装包的基础知识</h2><p>作为完全的iOS新手，困惑的第一个问题就是iOS安装包文件。</p>
<p>在Android系统中，安装App的途径很多，除了各类应用市场，普通用户也经常直接下载apk安装包文件后手动进行安装，因此大家对Android的安装包文件都比较熟悉。</p>
<p>但是对于iOS系统就不一样了，由于我们普通用户在iOS上安装应用的时候基本上只能通过Apple Store进行安装（未越狱），没有机会接触原始的安装包文件，因此往往连iOS应用的安装包到底是什么格式后缀都不清楚。</p>
<p>现在我们想在Appium App中通过模拟器运行被测应用，需要指定iOS app的安装包路径，因此需要首先获得一个iOS app安装包。</p>
<p><img src="/images/Appium_iOS_Settings_init.jpg" alt="Appium initialize iOS Settings"></p>
<p>那么iOS app的安装包长啥样呢？</p>
<p>或者在这个问题之前，我们先来看下另一个问题：对于iOS设备来说，如果不通过Apple Store，我们可以怎样安装一个应用？</p>
<p>针对这个问题，我搜了些资料，也请教了周围的同事，了解到的途径有如下几个：</p>
<ul>
<li>企业证书：该种方式适用于企业内部；通过企业证书编译出的iOS应用，无需上传至Apple Store，即可无限制的安装到企业员工的iOS设备中。只是需要解决的一个问题是，由于iOS设备没有文件管理器，没法将安装包拷贝到iOS设备中，因此常用的做法是将安装包（<code>.ipa</code>文件）上传至一些下载服务器（例如<code>fir.im</code>），并生成二维码，然后用户扫描二维码后即可通过浏览器下载安装包并进行安装。由此联想到另外一个方法，通过微信文件传输助手将安装包（<code>.ipa</code>）传输至iOS设备，然后再进行安装应该也是可以的吧？这种方法不知在原理上是否可行，因为在试验时由于安装包大于30M，微信无法传输，所以没能进行验证。</li>
<li>Xcode：该种方式适用于iOS开发者；开发者在Xcode中连上iOS设备对源码进行编译，编译生成的应用会自动安装至iOS设备。当然，该种方式也是需要iOS开发者证书。</li>
<li>PP助手：该种方式适用于普通用户；PP助手是一个非苹果官方的设备资源管理工具，可以实现对未越狱的iOS设备进行应用管理，也可以安装本地<code>.ipa</code>文件，前提是<code>.ipa</code>文件具有合适的签名。</li>
</ul>
<p>在上面列举的安装应用的途径中，反复提到了<code>.ipa</code>文件，那<code>.ipa</code>应该就是iOS应用程序的后缀了吧？暂且这么认为吧。</p>
<p>再回到前面的场景，要在iOS模拟器中运行iOS应用，我们是否可以找研发人员要一个<code>.ipa</code>安装包文件，然后就能在模拟器中加载运行应用呢？</p>
<p>刚开始的时候我是这么认为的。于是我获取到<code>.ipa</code>文件后，在<code>App Path</code>中填写该文件的路径，然后启动Appium Server；接着我再打开Inspector时，发现iOS模拟器启动了，但是在应用启动的时候就出问题了，始终无法正常启动，感觉像是启动崩溃，反复尝试多次仍然如此。</p>
<p>再次经过Google，总算是明白出现问题的原因了，总结下来有如下几点：</p>
<ul>
<li>不管是从Apple Store或iTunes上下载的应用，还是在Xcode中针对真机设备编译生成的<code>.ipa</code>文件，都是面向于ARM处理器的iOS设备，只能在真机设备中进行安装；</li>
<li>而在Mac OSX系统中运行的iOS模拟器，运行环境是基于Intel处理器的；</li>
<li>因此，若是针对真机设备编译生成的<code>.ipa</code>文件，是无法在iOS模拟器中正常运行的，毕竟处理器架构都不一样；</li>
<li>要想在iOS模拟器中运行应用，则必须在Xcode中编译时选择模拟器类型；编译生成的文件后缀为<code>.app</code>。</li>
</ul>
<h2 id="准备-app文件"><a href="#准备-app文件" class="headerlink" title="准备.app文件"></a>准备<code>.app</code>文件</h2><p>接下来，就说下如何获取<code>.app</code>文件。</p>
<p>虽然是测试人员，不会对被测iOS项目贡献代码，但是也不能总是找研发帮忙编译生成<code>.app</code>文件。所以，在本地搭建完整的iOS项目开发环境还是很有必要的。</p>
<p>对于iOS开发环境的搭建，当前社区中应该已经有了很多完整的教程，我在这儿就不详细描述了，只简单说下我搭建过程中涉及到的几个点。</p>
<p>首先，Mac OSX、Xcode、Apple Developer Tools这些基础环境的安装，在上一篇文章中已经进行说明了；</p>
<p>然后，申请项目源码的访问权限，<code>git clone</code>到本地；</p>
<p>接着是项目依赖环境的问题；通常一个较大型的iOS项目都会引用许多第三方库，而这些依赖库并不会直接保存到项目仓库中，通常是采用<code>CocoaPods</code>进行管理；简单地说，<code>CocoaPods</code>是针对<code>Swift</code>和<code>Objective-C</code>项目的依赖管理器，类似于Java中的<code>Maven</code>，Ruby中的<code>Gem</code>，Python中的<code>pip</code>。</p>
<p>当然，iOS项目的依赖管理工具也不是只有<code>CocoaPods</code>一个，如果是采用的别的依赖管理器，请自行查找对应的资料。</p>
<p>采用<code>CocoaPods</code>管理的项目，在项目根目录下会包含<code>Podfile</code>和<code>Podfile.lock</code>文件，里面记录了当前项目依赖的第三方库以及对应的版本号。</p>
<p>安装<code>CocoaPods</code>很简单，采用<code>gem</code>即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure>

<p>然后，进入到iOS项目的目录，执行<code>pod install</code>命令即可安装当前项目的所有依赖。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Project_Folder</span><br><span class="line">$ pod install</span><br><span class="line">Re-creating CocoaPods due to major version update.</span><br><span class="line">Analyzing dependencies</span><br><span class="line">.....（略）</span><br><span class="line">Downloading dependencies</span><br><span class="line">.....（略）</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line">Sending stats</span><br><span class="line">Pod installation complete! There are 27 dependencies from the Podfile and 28 total pods installed.</span><br></pre></td></tr></table></figure>

<p>关于<code>CocoaPods</code>的更多信息，请自行查看<a href="https://cocoapods.org" target="_blank" rel="noopener">官方网站</a></p>
<p>在依赖安装完成后，正常情况下，就可以在Xcode中编译项目了。</p>
<p>没有别的需要注意的，将target选择为模拟器（iOS Simulator）即可。而且针对模拟器进行编译时，也不会涉及到开发者证书的问题，项目配置上会简单很多。待后续讲到真机上的自动化测试时，我再对证书方面的内容进行补充。</p>
<p>编译完成后，在Products目录下，就可以看到<code>XXX.app</code>文件，这里的<code>XXX</code>就是项目名称；然后，选中<code>XXX.app</code>文件，【Show in Finder】，即可在文件目录中定位到该文件。</p>
<p>接下来，将<code>XXX.app</code>文件拷贝出来，或者复制该文件的<code>Full path</code>，怎样都行，只要在<code>Appium</code>的<code>App Path</code>中能定位到该文件就行。</p>
<h2 id="模拟器中运行iOS应用"><a href="#模拟器中运行iOS应用" class="headerlink" title="模拟器中运行iOS应用"></a>模拟器中运行iOS应用</h2><p>被测应用<code>.app</code>准备就绪后，接下来就可以在iOS模拟器中运行了。</p>
<p>回到前面的那张图。启动<code>Appium app</code>后，对于模拟器运行的情况，在<code>iOS Settings</code>中必须设置的参数项就3个，<code>App Path</code>、<code>Force Device</code>和<code>Platform Version</code>。对于真机运行的情况，后续再单独进行说明。</p>
<p>设置完毕后，点击【Launch】，启动<code>Appium Server</code>。</p>
<p><img src="/images/Appium_Inspector_Button.jpg" alt="Appium inspector button"></p>
<p>然后，点击图中红框处的按钮，即可通过<code>Inspector</code>启动模拟器，并在模拟器中加载iOS应用。</p>
<p><img src="/images/Appium_iOS_Simulator_Console.jpg" alt="Appium iOS Simulator Console"></p>
<p>在模拟器中，我们可以像在真机中一样，体验被测应用的各项功能；并且，在Appium的日志台中，可以实时查看到日志信息。</p>
<h2 id="经历的一个坑"><a href="#经历的一个坑" class="headerlink" title="经历的一个坑"></a>经历的一个坑</h2><p>整个过程是挺简单的，不过，在探索过程中我还是有遇到一个坑。</p>
<p>通过<code>Inspector</code>启动模拟器时，总是弹框报错，报错形式如下。</p>
<p><img src="/images/Appium_Inspector_Error.jpg" alt="Appium Inspector Error"></p>
<p>刚开始出现这问题时百思不得其解，因为提示的信息并不明显，Google了好一阵也没找到原因。最后只有详细去看日志信息，才发现问题所在。</p>
<p>在日志中，发现的报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[iOS] Error: Could not find a device to launch. You requested &apos;iPhone 6 (8.4)&apos;, but the available devices were: [&quot;Apple TV 1080p (9.2) [98638D25-7C82-48DF-BDCA-7F682F951533] (Simulator)&quot;,&quot;iPad 2 (9.2) [5E22F53E-EAB3-45DF-A1DD-10F58E920679] (Simulator)&quot;,&quot;iPad 2 (9.3) [4B2D2F9A-C099-4C13-8DE9-27C826A521C2] (Simulator)&quot;,&quot;iPad Air (9.2) [825E4997-9CD8-4225-9977-4C7AE2C98389] (Simulator)&quot;,&quot;iPad Air (9.3) [E4523799-E35F-4499-832B-12CF33F09144] (Simulator)&quot;,&quot;iPad Air 2 (9.2) [8057039D-F848-453E-97EC-2F75CAEA2E77] (Simulator)&quot;,&quot;iPad Air 2 (9.3) [0B8F49DA-832A-4248-BA1D-9DA5D11E31FD] (Simulator)&quot;,&quot;iPad Pro (9.2) [AF1F2D06-3067-41B5-AC2B-4B0ED88BF5D9] (Simulator)&quot;,&quot;iPad Pro (9.3) [C39617A6-9D91-4C0B-B25B-741BD57B016C] (Simulator)&quot;,&quot;iPad Retina (9.2) [D3C694E1-E3B4-47BE-AB5E-80B3D4E22FC2] (Simulator)&quot;,&quot;iPad Retina (9.3) [907C7B06-ED2C-48AC-AC46-04E4AD6E0CA3] (Simulator)&quot;,&quot;iPhone 4s (9.2) [1A786195-94E3-4908-8309-7B66D84E4619] (Simulator)&quot;,&quot;iPhone 4s (9.3) [3F76F34B-5A8F-4FD1-928D-56F84C192DDD] (Simulator)&quot;,&quot;iPhone 5 (9.2) [0D79A4CA-71EB-48A6-9EE4-172BEF3EB4E0] (Simulator)&quot;,&quot;iPhone 5 (9.3) [04270D44-F831-4253-95F2-3D205D2BC0D9] (Simulator)&quot;,&quot;iPhone 5s (9.2) [13A16C07-3C5B-4B04-A94B-B40A63238958] (Simulator)&quot;,&quot;iPhone 5s (9.3) [D30A7B34-BA01-4203-80DA-FAEA436725F9] (Simulator)&quot;,&quot;iPhone 6 (9.2) [5D01650F-2A31-4D53-A47A-CCF7FD552ADD] (Simulator)&quot;,&quot;iPhone 6 (9.3) [2F0810F6-C73B-4BA4-93BA-06D4B6D96BDA] (Simulator)&quot;,&quot;iPhone 6 Plus (9.2) [9A840B78-E6CE-4D18-BE83-16B590411641] (Simulator)&quot;,&quot;iPhone 6 Plus (9.3) [27C6557A-B09D-4D8A-9846-DA8FE0A8E8D5] (Simulator)&quot;,&quot;iPhone 6s (9.2) [E7F5B8A5-0E85-404F-A4D4-191D63E7EC1B] (Simulator)&quot;,&quot;iPhone 6s (9.3) [6F702911-13C2-472C-9ECD-BADD4385CB77] (Simulator)&quot;,&quot;iPhone 6s (9.3) + Apple Watch - 38mm (2.2) [B63FFAA4-00A4-473B-9462-3664F41F9001] (Simulator)&quot;,&quot;iPhone 6s Plus (9.2) [58837F78-511A-4F0B-9DDF-782E3B9935BD] (Simulator)&quot;,&quot;iPhone 6s Plus (9.3) [C31003C6-DCE2-414D-AD7F-376F6FA995B0] (Simulator)&quot;,&quot;iPhone 6s Plus (9.3) + Apple Watch - 42mm (2.2) [E3154768-CA23-45CC-90E5-2D0386A57B7D] (Simulator)&quot;]</span><br></pre></td></tr></table></figure>

<p>问题在于，我设置<code>iOS Settings</code>时，将<code>Force Device</code>设置为”iPhone 6”，将<code>Platform Version</code>设置为“8.4”，但是经过组合，<code>iPhone 6 (8.4)</code>并不在可用的模拟器设备列表中。</p>
<p>再来看日志中提示的可用设备，发现“iPhone 6”设备对应的<code>Platform Version</code>只有“9.2”和“9.3”。然后回到<code>iOS Settings</code>，发现<code>Platform Version</code>的下拉框可选项就没有“9.2”和“9.3”，最新的一个可选版本也就是“8.4”。</p>
<p><img src="/images/Appium_iOS_Settings_bug.jpg" alt="Appium iOS Settings bug"></p>
<p>这应该是<code>Appium app</code>的一个bug吧。不过好在<code>Platform Version</code>参数虽然是通过下拉框选择，但是也可以在框内直接填写内容。于是我在<code>Platform Version</code>设置框内填写为“9.3”，然后再次启动时，发现iOS模拟器就可以正常启动了。</p>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>现在，我们已经成功地通过Appium Inspector调用模拟器并运行iOS应用，接下来，我们就要开始尝试编写自动化测试用例了。</p>
<p>在下一篇文章中，我们将对Appium Inspector的功能进行熟悉，通过Inspector来查看iOS应用的UI元素信息，并尝试采用脚本语言与UI进行交互操作。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-backgroud-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/build-app-automated-test-platform-from-0-to-1-backgroud-introduction/" class="post-title-link" itemprop="url">从0到1搭建移动App功能自动化测试平台（0）：背景介绍和平台规划</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-20T00:00:00+08:00">2016-05-20</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/" itemprop="url" rel="index"><span itemprop="name">1. OpenSource</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/1-OpenSource/AppiumBooster/" itemprop="url" rel="index"><span itemprop="name">AppiumBooster</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近新加入某项目组（以下均已M指代），需要从零开始搭建功能自动化测试平台。</p>
<p>简单地说，M是一个典型的移动互联网产品，客户端包括iOS和Android，并在app中通过WebView嵌入了H5，后端基于Ruby on Rails实现。</p>
<p>当前阶段，M项目除了Rails Server端采用Jenkins+RSpec实现了部分的持续集成功能外，客户端部分的部署和测试工作都还是完全依赖于手工操作。</p>
<p>基于当前项目的开发模式，我对整个M项目实现持续集成自动化测试的架构流程进行了规划，初步计划的架构图如下图所示。最终的目标是希望能实现：不管是Rails Server，还是App(iOS/Android)，以及H5，当任意部分存在代码提交时，系统能自动拉取最新代码进行部署并执行自动化回归测试，及时地将执行情况反馈给开发人员。</p>
<p><img src="/images/DebugTalk_Plus_Automated_Test_Platform.jpg" alt></p>
<p>目标确定后，便是分阶段进行实现，需要开发的模块包括：</p>
<ul>
<li>自动化测试平台（Automated Test Platform）：满足iOS/Android/H5的自动化功能测试，包括模拟器和真机的测试；</li>
<li>测试管理平台（Test Management Platform）：实现自动化测试用例管理、手动下发测试任务、测试结果报表展现、Dashboard等功能；</li>
<li>打包平台（Pack System）：实现iOS/Android的自动化构建；</li>
<li>服务端自动化测试（Rails）：将服务端Rails的自动化测试接入测试管理平台；</li>
<li>持续集成流程打通：对Jenkins进行二次开发，与测试管理平台打通，实现全流程的持续集成自动化测试。</li>
</ul>
<p>而本系列教程，《从0到1搭建移动App功能自动化测试平台》，便是对整个实践过程的一个记录。</p>
<p>需要说明的是，之前我个人的工作经历主要在服务端性能测试、Android客户端性能测试（测试开发）方向，对于客户端的自动化测试基本上没有经验积累，特别是iOS系统的测试，以前更是完全没有接触过。因此本系列教程只能算是个人在探索路上的学习总结和记录，可能会存在一些错误的观点，还请前辈们多多指教。</p>
<h2 id="自动化测试框架的选择"><a href="#自动化测试框架的选择" class="headerlink" title="自动化测试框架的选择"></a>自动化测试框架的选择</h2><p>在愿景图中，绿色方框（Automated Test Platform）负责移动应用客户端（iOS/Android/H5）自动化测试的调度和执行，是整个自动化测试平台的核心。</p>
<p>因此，在搭建自动化测试平台之前，首先需要选择一个合适的自动化测试框架。</p>
<p>对于移动应用的自动化测试框架，当前市面上已经有很多成熟的开源项目。针对当前项目的实际情况，我主要参考如下选择标准：</p>
<ul>
<li>同时支持iOS、Android、H5，且尽量能保持接口统一，减少开发维护成本；</li>
<li>编程语言支持Python/Ruby；</li>
<li>用户量大，文档丰富。</li>
</ul>
<p>经过筛选，Appium无疑是最佳的选择。</p>
<h2 id="Appium-简介"><a href="#Appium-简介" class="headerlink" title="Appium 简介"></a>Appium 简介</h2><p>对于Appium的详细介绍，大家可参考<a href="http://appium.io/" target="_blank" rel="noopener">Appium</a>官方文档，我就不再重复引用。</p>
<p>不过对于Appium，仍然有几点很赞的理念值得强调。</p>
<ul>
<li>采用Appium时，无需对被测应用做任何修改，也无需嵌入任何东西；</li>
<li>Appium对iOS和Android的原生自动化测试框架进行了封装，并提供了统一的API（WebDriver API），减少了自动化测试代码的维护工作量；</li>
<li>Appium采用Client-Server的架构设计，并采用标准的HTTP通信协议；Server端负责与iOS/Android原生测试框架交互，无需测试人员关注细节实现；Client端基本上可以采用任意主流编程语言编写测试用例，减少了学习成本。</li>
</ul>
<h2 id="环境准备（iOS）"><a href="#环境准备（iOS）" class="headerlink" title="环境准备（iOS）"></a>环境准备（iOS）</h2><p>在Appium中测试iOS时，依赖于Apple开发环境，因此，在运行Appium之前需要先确保如下环境安装正确。</p>
<ul>
<li>Mac OS X &gt;= 10.7</li>
<li>XCode &gt;= 4.6.3</li>
<li>Apple Developer Tools (iPhone simulator SDK, command line tools)</li>
</ul>
<p>如上几个环境安装比较简单，直接在Apple Store中安装即可。</p>
<p>在安装Appium之前，为了确保Appium的相关依赖已经准备就绪，可以使用<code>appium-doctor</code>来进行验证。</p>
<p><a href="https://github.com/appium/appium-doctor" target="_blank" rel="noopener"><code>appium-doctor</code></a>是一个用于验证appium安装环境的工具，可以诊断出<code>Node/iOS/Android</code>环境配置方面的常见问题。</p>
<p><code>appium-doctor</code>采用<code>node.js</code>编写，采用<code>npm</code>即可在Terminal中进行安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install appium-doctor -g</span><br></pre></td></tr></table></figure>

<p>安装完毕后，执行<code>appium-doctor</code>命令即可对<code>Appium</code>的环境依赖情况进行检测；指定<code>--ios</code>时只针对iOS环境配置进行检测，指定<code>--android</code>参数时只针对Android环境配置进行检测，若不指定则同时对iOS和Android环境进行检测。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ appium-doctor --ios</span><br><span class="line">info AppiumDoctor <span class="comment">### Diagnostic starting ###</span></span><br><span class="line">info AppiumDoctor  ✔ Xcode is installed at: /Applications/Xcode.app/Contents/Developer</span><br><span class="line">info AppiumDoctor  ✔ Xcode Command Line Tools are installed.</span><br><span class="line">info AppiumDoctor  ✔ DevToolsSecurity is enabled.</span><br><span class="line">info AppiumDoctor  ✔ The Authorization DB is <span class="built_in">set</span> up properly.</span><br><span class="line">info AppiumDoctor  ✔ The Node.js binary was found at: /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line">info AppiumDoctor  ✔ HOME is <span class="built_in">set</span> to: /Users/Leo</span><br><span class="line">info AppiumDoctor <span class="comment">### Diagnostic completed, no fix needed. ###</span></span><br><span class="line">info AppiumDoctor</span><br><span class="line">info AppiumDoctor Everything looks good, <span class="built_in">bye</span>!</span><br><span class="line">info AppiumDoctor</span><br></pre></td></tr></table></figure>

<p>若检测结果全部通过，则说明Appium的相关依赖已经准备就绪，接下来可以继续安装Appium。</p>
<h2 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h2><p>根据前面的介绍，Appium采用Client-Server的架构设计，因此安装Appium时需要分别安装Server部分和Client部分。</p>
<p>通常情况下，我们说的Appium都是指代的Server部分。Appium的安装有多种方式：可以通过源码编译安装，也可以在Terminal中通过<code>npm</code>命令安装，另一种是直接下载<a href="https://github.com/appium/appium/releases" target="_blank" rel="noopener"><code>appium.dmg</code></a>后安装应用程序。</p>
<p>在这里推荐运行<code>Appium app</code>的方式，除了GUI界面操作更直观以外，更重要的一个原因是，相比于命令行运行方式，<code>Appium app</code>多了一个<code>Inspector</code>模块，可以调用模拟器运行被测应用程序，并且可以很方便地在预览页面中查看UI元素的层级结构和详细控件属性，极大地提高编写测试脚本的效率。</p>
<p>至于Client部分，其实我们原本可以不安装任何东西，只需要任意选择一门开发语言，然后直接基于WebDriver的C/S协议（JSON Wire Protocol）即可编写自动化测试代码。但是这样做的话工作量会比较大，因为要去处理一些跟协议相关的工作。所幸Appium项目已经针对众多主流的编程语言，将底层协议处理相关的工作封装为Library，通过调用这些Library，可以极大地简化我们编写测试用例的工作量。</p>
<p>而说的需要安装的Client部分，其实也就是安装这些Library。选定编写测试用例的语言后，我们就可以针对性地进行安装。</p>
<p>例如，如果选择Ruby语言，那么需要安装的Library就是<code>appium_lib</code>，安装方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install appium_lib</span><br></pre></td></tr></table></figure>

<p>如果选择Python语言，那么需要安装的Library就是<code>Appium-Python-Client</code>，安装方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install Appium-Python-Client</span><br></pre></td></tr></table></figure>

<p>对于其它编程语言，请自行参考官方文档。</p>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>iOS的自动化测试环境已基本准备就绪了，接下来我们想做的第一件事，就是在模拟器中运行iOS应用。</p>
<p>在下一篇文章中，我们将从clone项目源码为起点，编译生成iOS app，在Appium中调用模拟器中运行iOS app，并分享实践过程中遇到的一些坑。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://debugtalk.com/post/Android-performance-test-start-traffic-uid-stat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="debugtalk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/xiaojianguo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DebugTalk">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/post/Android-performance-test-start-traffic-uid-stat/" class="post-title-link" itemprop="url">Android App持续集成性能测试：启动流量（1）</a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-03 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-03T00:00:00+08:00">2016-05-03</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-Testing/" itemprop="url" rel="index"><span itemprop="name">3. Testing</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/3-Testing/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文对Android App的启动流量测试进行介绍。这里的启动流量指的是网络流量，即App在启动时发起网络请求和接收网络响应时传输的网络数据量。</p>
<p>说起流量，也许大家的第一反应就是tcpdump/wireshark这类网络抓包工具。的确，Android系统确实也支持<code>tcpdump</code>工具，通过<code>tcpdump</code>，我们可以实现非常精准的流量测试。但<code>tcpdump</code>也有个问题，就是它捕捉到的流量是系统层面的，我们很难区分捕捉得到的流量数据是否都是当前apk产生的。</p>
<p>其实，对于特定apk的整体流量数据，在Android系统中都会存储到对应文件中，我们完全可以通过读取对应文件来获得当前apk的流量信息。</p>
<h2 id="get-app-UID"><a href="#get-app-UID" class="headerlink" title="get app UID"></a>get app UID</h2><p>与流量相关的状态数据存储在<code>/proc/uid_stat/&lt;UID&gt;/</code>目录下，其中，<code>&lt;UID&gt;</code>表示apk对应的UID。</p>
<p>关于UID，简单地进行下说明。在Linux系统中，UID表示的是User Identifier，主要用于表示是哪位用户运行了该程序。但在Android系统中，由于Android系统本身就为单用户系统，这时UID就被赋予了新的使命，主要用于实现数据共享。具体地，Android系统为每个应用都分配了一个UID，不同apk的UID几乎都是互不相同的，而对于不同UID的apk，不能共享数据资源。之所以用“几乎”，是因为有时候同一厂家会存在多个产品，并且希望能在多个apk之间实现数据共享，这个时候，便可通过在menifest配置文件中指定相同的sharedUserId，然后在Android系统中安装应用时便会分配相同的UID。</p>
<p>获取app UID的方式有多种，最简单的方式应该还是从<code>/data/system/packages.list</code>中读取，并通过apk的<code>&lt;PKGNAME&gt;</code>找到对应的UID。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/ # cat /data/system/packages.list | grep com.UCMobile.trunk</span><br><span class="line">com.UCMobile.trunk 10084 0 /data/data/com.UCMobile.trunk default 3003,1028,1015</span><br></pre></td></tr></table></figure>

<p>在这里，10084即是<code>com.UCMobile.trunk</code>的UID。</p>
<h2 id="获取流量数据"><a href="#获取流量数据" class="headerlink" title="获取流量数据"></a>获取流量数据</h2><p>流量数据分为接收流量（tcp_rcv）和发送流量（tcp_snd）两部分，这两个状态数值我们可以通过读取<code>/proc/uid_stat/&lt;UID&gt;</code>目录下的两个文件得到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell@hammerhead:/ $ cat /proc/uid_stat/10084/tcp_rcv</span><br><span class="line">3446837</span><br><span class="line">shell@hammerhead:/ $ cat /proc/uid_stat/10084/tcp_snd</span><br><span class="line">134366</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们就可以读取得到指定apk在当前时刻的累计流量数值。</p>
<h2 id="获得启动流量数据"><a href="#获得启动流量数据" class="headerlink" title="获得启动流量数据"></a>获得启动流量数据</h2><p>有了前面的基础，我们要测试启动流量就很好实现了。只需要在启动前采集下累计流量数值，然后启动应用，完成启动后再采集一次累计流量数值，前后两次累计数值的差值便是当次启动耗费的流量数。需要注意的是，由于很多时候apk在启动后，会在系统后台异步加载一些数据资源，因此为了保证我们采集到当次启动耗费的全部流量数值，我们在启动应用后最好能等待一段时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@hammerhead:/ # cat /proc/uid_stat/10084/tcp_snd</span><br><span class="line">15068</span><br><span class="line">root@hammerhead:/ # cat /proc/uid_stat/10084/tcp_rcv</span><br><span class="line">98021</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> start app activity, sleep 10s</span></span><br><span class="line"></span><br><span class="line">root@hammerhead:/ # cat /proc/uid_stat/10142/tcp_snd</span><br><span class="line">23268</span><br><span class="line">root@hammerhead:/ # cat /proc/uid_stat/10142/tcp_rcv</span><br><span class="line">965651</span><br></pre></td></tr></table></figure>

<p>采集到前后两次流量数值后，即可计算得到当次启动耗费的总流量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当次启动总流量 = (23268 + 965651) - (15068 + 98021) = 875830 bytes</span><br></pre></td></tr></table></figure>

<p>当然，这里的启动还分为好几种，包括首次安装启动、非首次安装启动、覆盖安装启动等。具体的启动方式可根据实际场景来定，但在统计流量的方法方面都是相同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲解了Android App启动流量测试的一种方法。然而，本次介绍的方法也存在一定局限性，因为<code>/proc/uid_stat/&lt;UID&gt;/</code>目录下的<code>tcp_rcv</code>和<code>tcp_snd</code>文件中都只记录了总值，如果我们只关注总体的流量数值还好，但要是我们希望能测试得到更细化的数据，该方法就没法满足我们的测试需求了。</p>
<p>举个例子，UC浏览器国际版在启动后，会和美国的服务器进行通讯交互。现在，我们想测试UC浏览器国际版在启动后与美国服务器的通讯流量。</p>
<p>显然，本文中介绍的方法是没法实现上述例子中的测试需求的。那例子中的场景要怎么测呢？这就还是得用到<code>tcpdump</code>，在下一篇文章中我会再详细进行介绍。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/xiaojianguo.jpg" alt="debugtalk">
            
              <p class="site-author-name" itemprop="name">debugtalk</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">91</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/debugtalk" title="GitHub &rarr; https://github.com/debugtalk" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mail@debugtalk.com" title="E-Mail &rarr; mailto:mail@debugtalk.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  
    <div id="sidebar-dimmer"></div>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">debugtalk</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>







  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1257477005&web_id=1257477005"></script>
  </div>



        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  

  


  <script src="/js/src/bootstrap.js?v=7.0.1"></script>


  
  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      
        // ref: https://github.com/ForbesLindesay/unescape-html
        var unescapeHtml = function(html) {
          return String(html)
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, '\'')
            .replace(/&#x3A;/g, ':')
            // replace all the other &#x; chars
            .replace(/&#(\d+);/g, function (m, p) { return String.fromCharCode(p); })
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
        };
      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                content = unescapeHtml(content);
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

</body>
</html>
